
Usage_Example_CM0PLUS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08020000  08020000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002c64  080200c0  080200c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000000c4  08022d24  08022d24  00012d24  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08022de8  08022de8  0001800c  2**0
                  CONTENTS
  4 .ARM          00000000  08022de8  08022de8  0001800c  2**0
                  CONTENTS
  5 .preinit_array 00000000  08022de8  08022de8  0001800c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08022de8  08022de8  00012de8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08022dec  08022dec  00012dec  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000000c  20008000  08022df0  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000003f4  2000800c  08022dfc  0001800c  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20008400  08022dfc  00018400  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  0001800c  2**0
                  CONTENTS, READONLY
 12 .debug_info   0000b0e5  00000000  00000000  00018034  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000235b  00000000  00000000  00023119  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000d10  00000000  00000000  00025478  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000c08  00000000  00000000  00026188  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0001ae62  00000000  00000000  00026d90  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0000c7b2  00000000  00000000  00041bf2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    000ab080  00000000  00000000  0004e3a4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000050  00000000  00000000  000f9424  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00002d60  00000000  00000000  000f9474  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080200c0 <__do_global_dtors_aux>:
 80200c0:	b510      	push	{r4, lr}
 80200c2:	4c06      	ldr	r4, [pc, #24]	; (80200dc <__do_global_dtors_aux+0x1c>)
 80200c4:	7823      	ldrb	r3, [r4, #0]
 80200c6:	2b00      	cmp	r3, #0
 80200c8:	d107      	bne.n	80200da <__do_global_dtors_aux+0x1a>
 80200ca:	4b05      	ldr	r3, [pc, #20]	; (80200e0 <__do_global_dtors_aux+0x20>)
 80200cc:	2b00      	cmp	r3, #0
 80200ce:	d002      	beq.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d0:	4804      	ldr	r0, [pc, #16]	; (80200e4 <__do_global_dtors_aux+0x24>)
 80200d2:	e000      	b.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d4:	bf00      	nop
 80200d6:	2301      	movs	r3, #1
 80200d8:	7023      	strb	r3, [r4, #0]
 80200da:	bd10      	pop	{r4, pc}
 80200dc:	2000800c 	.word	0x2000800c
 80200e0:	00000000 	.word	0x00000000
 80200e4:	08022d0c 	.word	0x08022d0c

080200e8 <frame_dummy>:
 80200e8:	4b04      	ldr	r3, [pc, #16]	; (80200fc <frame_dummy+0x14>)
 80200ea:	b510      	push	{r4, lr}
 80200ec:	2b00      	cmp	r3, #0
 80200ee:	d003      	beq.n	80200f8 <frame_dummy+0x10>
 80200f0:	4903      	ldr	r1, [pc, #12]	; (8020100 <frame_dummy+0x18>)
 80200f2:	4804      	ldr	r0, [pc, #16]	; (8020104 <frame_dummy+0x1c>)
 80200f4:	e000      	b.n	80200f8 <frame_dummy+0x10>
 80200f6:	bf00      	nop
 80200f8:	bd10      	pop	{r4, pc}
 80200fa:	46c0      	nop			; (mov r8, r8)
 80200fc:	00000000 	.word	0x00000000
 8020100:	20008010 	.word	0x20008010
 8020104:	08022d0c 	.word	0x08022d0c

08020108 <__udivsi3>:
 8020108:	2200      	movs	r2, #0
 802010a:	0843      	lsrs	r3, r0, #1
 802010c:	428b      	cmp	r3, r1
 802010e:	d374      	bcc.n	80201fa <__udivsi3+0xf2>
 8020110:	0903      	lsrs	r3, r0, #4
 8020112:	428b      	cmp	r3, r1
 8020114:	d35f      	bcc.n	80201d6 <__udivsi3+0xce>
 8020116:	0a03      	lsrs	r3, r0, #8
 8020118:	428b      	cmp	r3, r1
 802011a:	d344      	bcc.n	80201a6 <__udivsi3+0x9e>
 802011c:	0b03      	lsrs	r3, r0, #12
 802011e:	428b      	cmp	r3, r1
 8020120:	d328      	bcc.n	8020174 <__udivsi3+0x6c>
 8020122:	0c03      	lsrs	r3, r0, #16
 8020124:	428b      	cmp	r3, r1
 8020126:	d30d      	bcc.n	8020144 <__udivsi3+0x3c>
 8020128:	22ff      	movs	r2, #255	; 0xff
 802012a:	0209      	lsls	r1, r1, #8
 802012c:	ba12      	rev	r2, r2
 802012e:	0c03      	lsrs	r3, r0, #16
 8020130:	428b      	cmp	r3, r1
 8020132:	d302      	bcc.n	802013a <__udivsi3+0x32>
 8020134:	1212      	asrs	r2, r2, #8
 8020136:	0209      	lsls	r1, r1, #8
 8020138:	d065      	beq.n	8020206 <__udivsi3+0xfe>
 802013a:	0b03      	lsrs	r3, r0, #12
 802013c:	428b      	cmp	r3, r1
 802013e:	d319      	bcc.n	8020174 <__udivsi3+0x6c>
 8020140:	e000      	b.n	8020144 <__udivsi3+0x3c>
 8020142:	0a09      	lsrs	r1, r1, #8
 8020144:	0bc3      	lsrs	r3, r0, #15
 8020146:	428b      	cmp	r3, r1
 8020148:	d301      	bcc.n	802014e <__udivsi3+0x46>
 802014a:	03cb      	lsls	r3, r1, #15
 802014c:	1ac0      	subs	r0, r0, r3
 802014e:	4152      	adcs	r2, r2
 8020150:	0b83      	lsrs	r3, r0, #14
 8020152:	428b      	cmp	r3, r1
 8020154:	d301      	bcc.n	802015a <__udivsi3+0x52>
 8020156:	038b      	lsls	r3, r1, #14
 8020158:	1ac0      	subs	r0, r0, r3
 802015a:	4152      	adcs	r2, r2
 802015c:	0b43      	lsrs	r3, r0, #13
 802015e:	428b      	cmp	r3, r1
 8020160:	d301      	bcc.n	8020166 <__udivsi3+0x5e>
 8020162:	034b      	lsls	r3, r1, #13
 8020164:	1ac0      	subs	r0, r0, r3
 8020166:	4152      	adcs	r2, r2
 8020168:	0b03      	lsrs	r3, r0, #12
 802016a:	428b      	cmp	r3, r1
 802016c:	d301      	bcc.n	8020172 <__udivsi3+0x6a>
 802016e:	030b      	lsls	r3, r1, #12
 8020170:	1ac0      	subs	r0, r0, r3
 8020172:	4152      	adcs	r2, r2
 8020174:	0ac3      	lsrs	r3, r0, #11
 8020176:	428b      	cmp	r3, r1
 8020178:	d301      	bcc.n	802017e <__udivsi3+0x76>
 802017a:	02cb      	lsls	r3, r1, #11
 802017c:	1ac0      	subs	r0, r0, r3
 802017e:	4152      	adcs	r2, r2
 8020180:	0a83      	lsrs	r3, r0, #10
 8020182:	428b      	cmp	r3, r1
 8020184:	d301      	bcc.n	802018a <__udivsi3+0x82>
 8020186:	028b      	lsls	r3, r1, #10
 8020188:	1ac0      	subs	r0, r0, r3
 802018a:	4152      	adcs	r2, r2
 802018c:	0a43      	lsrs	r3, r0, #9
 802018e:	428b      	cmp	r3, r1
 8020190:	d301      	bcc.n	8020196 <__udivsi3+0x8e>
 8020192:	024b      	lsls	r3, r1, #9
 8020194:	1ac0      	subs	r0, r0, r3
 8020196:	4152      	adcs	r2, r2
 8020198:	0a03      	lsrs	r3, r0, #8
 802019a:	428b      	cmp	r3, r1
 802019c:	d301      	bcc.n	80201a2 <__udivsi3+0x9a>
 802019e:	020b      	lsls	r3, r1, #8
 80201a0:	1ac0      	subs	r0, r0, r3
 80201a2:	4152      	adcs	r2, r2
 80201a4:	d2cd      	bcs.n	8020142 <__udivsi3+0x3a>
 80201a6:	09c3      	lsrs	r3, r0, #7
 80201a8:	428b      	cmp	r3, r1
 80201aa:	d301      	bcc.n	80201b0 <__udivsi3+0xa8>
 80201ac:	01cb      	lsls	r3, r1, #7
 80201ae:	1ac0      	subs	r0, r0, r3
 80201b0:	4152      	adcs	r2, r2
 80201b2:	0983      	lsrs	r3, r0, #6
 80201b4:	428b      	cmp	r3, r1
 80201b6:	d301      	bcc.n	80201bc <__udivsi3+0xb4>
 80201b8:	018b      	lsls	r3, r1, #6
 80201ba:	1ac0      	subs	r0, r0, r3
 80201bc:	4152      	adcs	r2, r2
 80201be:	0943      	lsrs	r3, r0, #5
 80201c0:	428b      	cmp	r3, r1
 80201c2:	d301      	bcc.n	80201c8 <__udivsi3+0xc0>
 80201c4:	014b      	lsls	r3, r1, #5
 80201c6:	1ac0      	subs	r0, r0, r3
 80201c8:	4152      	adcs	r2, r2
 80201ca:	0903      	lsrs	r3, r0, #4
 80201cc:	428b      	cmp	r3, r1
 80201ce:	d301      	bcc.n	80201d4 <__udivsi3+0xcc>
 80201d0:	010b      	lsls	r3, r1, #4
 80201d2:	1ac0      	subs	r0, r0, r3
 80201d4:	4152      	adcs	r2, r2
 80201d6:	08c3      	lsrs	r3, r0, #3
 80201d8:	428b      	cmp	r3, r1
 80201da:	d301      	bcc.n	80201e0 <__udivsi3+0xd8>
 80201dc:	00cb      	lsls	r3, r1, #3
 80201de:	1ac0      	subs	r0, r0, r3
 80201e0:	4152      	adcs	r2, r2
 80201e2:	0883      	lsrs	r3, r0, #2
 80201e4:	428b      	cmp	r3, r1
 80201e6:	d301      	bcc.n	80201ec <__udivsi3+0xe4>
 80201e8:	008b      	lsls	r3, r1, #2
 80201ea:	1ac0      	subs	r0, r0, r3
 80201ec:	4152      	adcs	r2, r2
 80201ee:	0843      	lsrs	r3, r0, #1
 80201f0:	428b      	cmp	r3, r1
 80201f2:	d301      	bcc.n	80201f8 <__udivsi3+0xf0>
 80201f4:	004b      	lsls	r3, r1, #1
 80201f6:	1ac0      	subs	r0, r0, r3
 80201f8:	4152      	adcs	r2, r2
 80201fa:	1a41      	subs	r1, r0, r1
 80201fc:	d200      	bcs.n	8020200 <__udivsi3+0xf8>
 80201fe:	4601      	mov	r1, r0
 8020200:	4152      	adcs	r2, r2
 8020202:	4610      	mov	r0, r2
 8020204:	4770      	bx	lr
 8020206:	e7ff      	b.n	8020208 <__udivsi3+0x100>
 8020208:	b501      	push	{r0, lr}
 802020a:	2000      	movs	r0, #0
 802020c:	f000 f806 	bl	802021c <__aeabi_idiv0>
 8020210:	bd02      	pop	{r1, pc}
 8020212:	46c0      	nop			; (mov r8, r8)

08020214 <__aeabi_uidivmod>:
 8020214:	2900      	cmp	r1, #0
 8020216:	d0f7      	beq.n	8020208 <__udivsi3+0x100>
 8020218:	e776      	b.n	8020108 <__udivsi3>
 802021a:	4770      	bx	lr

0802021c <__aeabi_idiv0>:
 802021c:	4770      	bx	lr
 802021e:	46c0      	nop			; (mov r8, r8)

08020220 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8020220:	b580      	push	{r7, lr}
 8020222:	af00      	add	r7, sp, #0

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif
}
 8020224:	46c0      	nop			; (mov r8, r8)
 8020226:	46bd      	mov	sp, r7
 8020228:	bd80      	pop	{r7, pc}
	...

0802022c <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 802022c:	b590      	push	{r4, r7, lr}
 802022e:	b095      	sub	sp, #84	; 0x54
 8020230:	af02      	add	r7, sp, #8
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8020232:	f000 f9c1 	bl	80205b8 <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_RTC_Init();
 8020236:	f000 f841 	bl	80202bc <MX_RTC_Init>
  /* USER CODE BEGIN 2 */

  // initialize the calendar module
  calendar_init(&hrtc);
 802023a:	4b1d      	ldr	r3, [pc, #116]	; (80202b0 <main+0x84>)
 802023c:	0018      	movs	r0, r3
 802023e:	f001 fdfb 	bl	8021e38 <calendar_init>

  // set the date and time
  DateTime now = {23, 9, 29, 17, 0, 0};
 8020242:	203c      	movs	r0, #60	; 0x3c
 8020244:	183b      	adds	r3, r7, r0
 8020246:	4a1b      	ldr	r2, [pc, #108]	; (80202b4 <main+0x88>)
 8020248:	6811      	ldr	r1, [r2, #0]
 802024a:	6019      	str	r1, [r3, #0]
 802024c:	8892      	ldrh	r2, [r2, #4]
 802024e:	809a      	strh	r2, [r3, #4]
  calendar_setDateTime(now);
 8020250:	183b      	adds	r3, r7, r0
 8020252:	6818      	ldr	r0, [r3, #0]
 8020254:	6859      	ldr	r1, [r3, #4]
 8020256:	f001 fe35 	bl	8021ec4 <calendar_setDateTime>

  // add a few events five seconds apart from each other lasting two
  // seconds each
  CalendarEvent someEvents[3] = {
 802025a:	003a      	movs	r2, r7
 802025c:	4b16      	ldr	r3, [pc, #88]	; (80202b8 <main+0x8c>)
 802025e:	0010      	movs	r0, r2
 8020260:	0019      	movs	r1, r3
 8020262:	233c      	movs	r3, #60	; 0x3c
 8020264:	001a      	movs	r2, r3
 8020266:	f002 fd3f 	bl	8022ce8 <memcpy>
		  [2] = {.start = {23, 9, 29, 17, 0, 15},
				  .end = {23, 9, 29, 17, 0, 17},
				  .start_callback = (void*)&startEventCallback,
				  .end_callback = (void*)&endEventCallback}
  };
  for (int i = 0; i < 3; i++)
 802026a:	2300      	movs	r3, #0
 802026c:	647b      	str	r3, [r7, #68]	; 0x44
 802026e:	e017      	b.n	80202a0 <main+0x74>
	  calendar_addEvent(someEvents[i]);
 8020270:	003c      	movs	r4, r7
 8020272:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8020274:	0013      	movs	r3, r2
 8020276:	009b      	lsls	r3, r3, #2
 8020278:	189b      	adds	r3, r3, r2
 802027a:	009b      	lsls	r3, r3, #2
 802027c:	2110      	movs	r1, #16
 802027e:	18e2      	adds	r2, r4, r3
 8020280:	1851      	adds	r1, r2, r1
 8020282:	466a      	mov	r2, sp
 8020284:	6809      	ldr	r1, [r1, #0]
 8020286:	6011      	str	r1, [r2, #0]
 8020288:	5918      	ldr	r0, [r3, r4]
 802028a:	18e2      	adds	r2, r4, r3
 802028c:	6851      	ldr	r1, [r2, #4]
 802028e:	18e2      	adds	r2, r4, r3
 8020290:	6892      	ldr	r2, [r2, #8]
 8020292:	18e3      	adds	r3, r4, r3
 8020294:	68db      	ldr	r3, [r3, #12]
 8020296:	f001 fe45 	bl	8021f24 <calendar_addEvent>
  for (int i = 0; i < 3; i++)
 802029a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802029c:	3301      	adds	r3, #1
 802029e:	647b      	str	r3, [r7, #68]	; 0x44
 80202a0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80202a2:	2b02      	cmp	r3, #2
 80202a4:	dde4      	ble.n	8020270 <main+0x44>

  // and start the calendar
  calendar_startScheduler();
 80202a6:	f001 fdef 	bl	8021e88 <calendar_startScheduler>
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */

	  // update the calendar
	  calendar_updateScheduler();
 80202aa:	f001 fe73 	bl	8021f94 <calendar_updateScheduler>
 80202ae:	e7fc      	b.n	80202aa <main+0x7e>
 80202b0:	20008028 	.word	0x20008028
 80202b4:	08022d24 	.word	0x08022d24
 80202b8:	08022d2c 	.word	0x08022d2c

080202bc <MX_RTC_Init>:
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{
 80202bc:	b580      	push	{r7, lr}
 80202be:	b092      	sub	sp, #72	; 0x48
 80202c0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_TimeTypeDef sTime = {0};
 80202c2:	2334      	movs	r3, #52	; 0x34
 80202c4:	18fb      	adds	r3, r7, r3
 80202c6:	0018      	movs	r0, r3
 80202c8:	2314      	movs	r3, #20
 80202ca:	001a      	movs	r2, r3
 80202cc:	2100      	movs	r1, #0
 80202ce:	f002 fd14 	bl	8022cfa <memset>
  RTC_DateTypeDef sDate = {0};
 80202d2:	2330      	movs	r3, #48	; 0x30
 80202d4:	18fb      	adds	r3, r7, r3
 80202d6:	2200      	movs	r2, #0
 80202d8:	601a      	str	r2, [r3, #0]
  RTC_AlarmTypeDef sAlarm = {0};
 80202da:	1d3b      	adds	r3, r7, #4
 80202dc:	0018      	movs	r0, r3
 80202de:	232c      	movs	r3, #44	; 0x2c
 80202e0:	001a      	movs	r2, r3
 80202e2:	2100      	movs	r1, #0
 80202e4:	f002 fd09 	bl	8022cfa <memset>

  /* USER CODE END RTC_Init 1 */

  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 80202e8:	4b44      	ldr	r3, [pc, #272]	; (80203fc <MX_RTC_Init+0x140>)
 80202ea:	4a45      	ldr	r2, [pc, #276]	; (8020400 <MX_RTC_Init+0x144>)
 80202ec:	601a      	str	r2, [r3, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 80202ee:	4b43      	ldr	r3, [pc, #268]	; (80203fc <MX_RTC_Init+0x140>)
 80202f0:	2200      	movs	r2, #0
 80202f2:	605a      	str	r2, [r3, #4]
  hrtc.Init.AsynchPrediv = 127;
 80202f4:	4b41      	ldr	r3, [pc, #260]	; (80203fc <MX_RTC_Init+0x140>)
 80202f6:	227f      	movs	r2, #127	; 0x7f
 80202f8:	609a      	str	r2, [r3, #8]
  hrtc.Init.SynchPrediv = 255;
 80202fa:	4b40      	ldr	r3, [pc, #256]	; (80203fc <MX_RTC_Init+0x140>)
 80202fc:	22ff      	movs	r2, #255	; 0xff
 80202fe:	60da      	str	r2, [r3, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 8020300:	4b3e      	ldr	r3, [pc, #248]	; (80203fc <MX_RTC_Init+0x140>)
 8020302:	2200      	movs	r2, #0
 8020304:	611a      	str	r2, [r3, #16]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 8020306:	4b3d      	ldr	r3, [pc, #244]	; (80203fc <MX_RTC_Init+0x140>)
 8020308:	2200      	movs	r2, #0
 802030a:	615a      	str	r2, [r3, #20]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 802030c:	4b3b      	ldr	r3, [pc, #236]	; (80203fc <MX_RTC_Init+0x140>)
 802030e:	2200      	movs	r2, #0
 8020310:	619a      	str	r2, [r3, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8020312:	4b3a      	ldr	r3, [pc, #232]	; (80203fc <MX_RTC_Init+0x140>)
 8020314:	2280      	movs	r2, #128	; 0x80
 8020316:	05d2      	lsls	r2, r2, #23
 8020318:	61da      	str	r2, [r3, #28]
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
 802031a:	4b38      	ldr	r3, [pc, #224]	; (80203fc <MX_RTC_Init+0x140>)
 802031c:	2200      	movs	r2, #0
 802031e:	621a      	str	r2, [r3, #32]
  hrtc.Init.BinMode = RTC_BINARY_NONE;
 8020320:	4b36      	ldr	r3, [pc, #216]	; (80203fc <MX_RTC_Init+0x140>)
 8020322:	2200      	movs	r2, #0
 8020324:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8020326:	4b35      	ldr	r3, [pc, #212]	; (80203fc <MX_RTC_Init+0x140>)
 8020328:	0018      	movs	r0, r3
 802032a:	f001 f86b 	bl	8021404 <HAL_RTC_Init>
 802032e:	1e03      	subs	r3, r0, #0
 8020330:	d001      	beq.n	8020336 <MX_RTC_Init+0x7a>
  {
    Error_Handler();
 8020332:	f000 f885 	bl	8020440 <Error_Handler>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  sTime.Hours = 0x0;
 8020336:	2134      	movs	r1, #52	; 0x34
 8020338:	187b      	adds	r3, r7, r1
 802033a:	2200      	movs	r2, #0
 802033c:	701a      	strb	r2, [r3, #0]
  sTime.Minutes = 0x0;
 802033e:	187b      	adds	r3, r7, r1
 8020340:	2200      	movs	r2, #0
 8020342:	705a      	strb	r2, [r3, #1]
  sTime.Seconds = 0x0;
 8020344:	187b      	adds	r3, r7, r1
 8020346:	2200      	movs	r2, #0
 8020348:	709a      	strb	r2, [r3, #2]
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 802034a:	187b      	adds	r3, r7, r1
 802034c:	2200      	movs	r2, #0
 802034e:	60da      	str	r2, [r3, #12]
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
 8020350:	187b      	adds	r3, r7, r1
 8020352:	2200      	movs	r2, #0
 8020354:	611a      	str	r2, [r3, #16]
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
 8020356:	1879      	adds	r1, r7, r1
 8020358:	4b28      	ldr	r3, [pc, #160]	; (80203fc <MX_RTC_Init+0x140>)
 802035a:	2201      	movs	r2, #1
 802035c:	0018      	movs	r0, r3
 802035e:	f001 f8e9 	bl	8021534 <HAL_RTC_SetTime>
 8020362:	1e03      	subs	r3, r0, #0
 8020364:	d001      	beq.n	802036a <MX_RTC_Init+0xae>
  {
    Error_Handler();
 8020366:	f000 f86b 	bl	8020440 <Error_Handler>
  }
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 802036a:	2130      	movs	r1, #48	; 0x30
 802036c:	187b      	adds	r3, r7, r1
 802036e:	2201      	movs	r2, #1
 8020370:	701a      	strb	r2, [r3, #0]
  sDate.Month = RTC_MONTH_JANUARY;
 8020372:	187b      	adds	r3, r7, r1
 8020374:	2201      	movs	r2, #1
 8020376:	705a      	strb	r2, [r3, #1]
  sDate.Date = 0x1;
 8020378:	187b      	adds	r3, r7, r1
 802037a:	2201      	movs	r2, #1
 802037c:	709a      	strb	r2, [r3, #2]
  sDate.Year = 0x0;
 802037e:	187b      	adds	r3, r7, r1
 8020380:	2200      	movs	r2, #0
 8020382:	70da      	strb	r2, [r3, #3]

  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
 8020384:	1879      	adds	r1, r7, r1
 8020386:	4b1d      	ldr	r3, [pc, #116]	; (80203fc <MX_RTC_Init+0x140>)
 8020388:	2201      	movs	r2, #1
 802038a:	0018      	movs	r0, r3
 802038c:	f001 f9de 	bl	802174c <HAL_RTC_SetDate>
 8020390:	1e03      	subs	r3, r0, #0
 8020392:	d001      	beq.n	8020398 <MX_RTC_Init+0xdc>
  {
    Error_Handler();
 8020394:	f000 f854 	bl	8020440 <Error_Handler>
  }

  /** Enable the Alarm A
  */
  sAlarm.AlarmTime.Hours = 0x0;
 8020398:	1d3b      	adds	r3, r7, #4
 802039a:	2200      	movs	r2, #0
 802039c:	701a      	strb	r2, [r3, #0]
  sAlarm.AlarmTime.Minutes = 0x0;
 802039e:	1d3b      	adds	r3, r7, #4
 80203a0:	2200      	movs	r2, #0
 80203a2:	705a      	strb	r2, [r3, #1]
  sAlarm.AlarmTime.Seconds = 0x0;
 80203a4:	1d3b      	adds	r3, r7, #4
 80203a6:	2200      	movs	r2, #0
 80203a8:	709a      	strb	r2, [r3, #2]
  sAlarm.AlarmTime.SubSeconds = 0x0;
 80203aa:	1d3b      	adds	r3, r7, #4
 80203ac:	2200      	movs	r2, #0
 80203ae:	605a      	str	r2, [r3, #4]
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 80203b0:	1d3b      	adds	r3, r7, #4
 80203b2:	2200      	movs	r2, #0
 80203b4:	60da      	str	r2, [r3, #12]
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 80203b6:	1d3b      	adds	r3, r7, #4
 80203b8:	2200      	movs	r2, #0
 80203ba:	611a      	str	r2, [r3, #16]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 80203bc:	1d3b      	adds	r3, r7, #4
 80203be:	2200      	movs	r2, #0
 80203c0:	615a      	str	r2, [r3, #20]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 80203c2:	1d3b      	adds	r3, r7, #4
 80203c4:	2200      	movs	r2, #0
 80203c6:	619a      	str	r2, [r3, #24]
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 80203c8:	1d3b      	adds	r3, r7, #4
 80203ca:	2200      	movs	r2, #0
 80203cc:	621a      	str	r2, [r3, #32]
  sAlarm.AlarmDateWeekDay = 0x1;
 80203ce:	1d3b      	adds	r3, r7, #4
 80203d0:	2224      	movs	r2, #36	; 0x24
 80203d2:	2101      	movs	r1, #1
 80203d4:	5499      	strb	r1, [r3, r2]
  sAlarm.Alarm = RTC_ALARM_A;
 80203d6:	1d3b      	adds	r3, r7, #4
 80203d8:	2280      	movs	r2, #128	; 0x80
 80203da:	0052      	lsls	r2, r2, #1
 80203dc:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 80203de:	1d39      	adds	r1, r7, #4
 80203e0:	4b06      	ldr	r3, [pc, #24]	; (80203fc <MX_RTC_Init+0x140>)
 80203e2:	2201      	movs	r2, #1
 80203e4:	0018      	movs	r0, r3
 80203e6:	f001 fa8f 	bl	8021908 <HAL_RTC_SetAlarm_IT>
 80203ea:	1e03      	subs	r3, r0, #0
 80203ec:	d001      	beq.n	80203f2 <MX_RTC_Init+0x136>
  {
    Error_Handler();
 80203ee:	f000 f827 	bl	8020440 <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 80203f2:	46c0      	nop			; (mov r8, r8)
 80203f4:	46bd      	mov	sp, r7
 80203f6:	b012      	add	sp, #72	; 0x48
 80203f8:	bd80      	pop	{r7, pc}
 80203fa:	46c0      	nop			; (mov r8, r8)
 80203fc:	20008028 	.word	0x20008028
 8020400:	40002800 	.word	0x40002800

08020404 <startEventCallback>:

/*
 * Function to execute once an event is entered.
 */
void startEventCallback(void)
{
 8020404:	b580      	push	{r7, lr}
 8020406:	af00      	add	r7, sp, #0
	activate_led(BLUE_LED);
 8020408:	2380      	movs	r3, #128	; 0x80
 802040a:	021b      	lsls	r3, r3, #8
 802040c:	0018      	movs	r0, r3
 802040e:	f002 fbe9 	bl	8022be4 <activate_led>
}
 8020412:	46c0      	nop			; (mov r8, r8)
 8020414:	46bd      	mov	sp, r7
 8020416:	bd80      	pop	{r7, pc}

08020418 <endEventCallback>:

/*
 * Function to execute once an event is exited.
 */
void endEventCallback(void)
{
 8020418:	b580      	push	{r7, lr}
 802041a:	af00      	add	r7, sp, #0
	deactivate_led(BLUE_LED);
 802041c:	2380      	movs	r3, #128	; 0x80
 802041e:	021b      	lsls	r3, r3, #8
 8020420:	0018      	movs	r0, r3
 8020422:	f002 fc19 	bl	8022c58 <deactivate_led>
}
 8020426:	46c0      	nop			; (mov r8, r8)
 8020428:	46bd      	mov	sp, r7
 802042a:	bd80      	pop	{r7, pc}

0802042c <HAL_RTC_AlarmAEventCallback>:

/*
 * Alarm A callback.
 */
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
{
 802042c:	b580      	push	{r7, lr}
 802042e:	b082      	sub	sp, #8
 8020430:	af00      	add	r7, sp, #0
 8020432:	6078      	str	r0, [r7, #4]
	// call ISR for handling calendar events
	calendar_AlarmA_ISR();
 8020434:	f001 fdd0 	bl	8021fd8 <calendar_AlarmA_ISR>
}
 8020438:	46c0      	nop			; (mov r8, r8)
 802043a:	46bd      	mov	sp, r7
 802043c:	b002      	add	sp, #8
 802043e:	bd80      	pop	{r7, pc}

08020440 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8020440:	b580      	push	{r7, lr}
 8020442:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8020444:	b672      	cpsid	i
}
 8020446:	46c0      	nop			; (mov r8, r8)
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8020448:	e7fe      	b.n	8020448 <Error_Handler+0x8>

0802044a <LL_RCC_EnableRTC>:
  * @brief  Enable RTC
  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_EnableRTC(void)
{
 802044a:	b580      	push	{r7, lr}
 802044c:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 802044e:	23b0      	movs	r3, #176	; 0xb0
 8020450:	05db      	lsls	r3, r3, #23
 8020452:	2290      	movs	r2, #144	; 0x90
 8020454:	589a      	ldr	r2, [r3, r2]
 8020456:	23b0      	movs	r3, #176	; 0xb0
 8020458:	05db      	lsls	r3, r3, #23
 802045a:	2180      	movs	r1, #128	; 0x80
 802045c:	0209      	lsls	r1, r1, #8
 802045e:	430a      	orrs	r2, r1
 8020460:	2190      	movs	r1, #144	; 0x90
 8020462:	505a      	str	r2, [r3, r1]
}
 8020464:	46c0      	nop			; (mov r8, r8)
 8020466:	46bd      	mov	sp, r7
 8020468:	bd80      	pop	{r7, pc}

0802046a <LL_C2_APB1_GRP1_EnableClock>:
  *         @arg @ref LL_C2_APB1_GRP1_PERIPH_LPTIM1

  * @retval None
  */
__STATIC_INLINE void LL_C2_APB1_GRP1_EnableClock(uint32_t Periphs)
{
 802046a:	b580      	push	{r7, lr}
 802046c:	b084      	sub	sp, #16
 802046e:	af00      	add	r7, sp, #0
 8020470:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2APB1ENR1, Periphs);
 8020472:	23b0      	movs	r3, #176	; 0xb0
 8020474:	05da      	lsls	r2, r3, #23
 8020476:	23ac      	movs	r3, #172	; 0xac
 8020478:	005b      	lsls	r3, r3, #1
 802047a:	58d1      	ldr	r1, [r2, r3]
 802047c:	23b0      	movs	r3, #176	; 0xb0
 802047e:	05da      	lsls	r2, r3, #23
 8020480:	687b      	ldr	r3, [r7, #4]
 8020482:	4319      	orrs	r1, r3
 8020484:	23ac      	movs	r3, #172	; 0xac
 8020486:	005b      	lsls	r3, r3, #1
 8020488:	50d1      	str	r1, [r2, r3]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2APB1ENR1, Periphs);
 802048a:	23b0      	movs	r3, #176	; 0xb0
 802048c:	05da      	lsls	r2, r3, #23
 802048e:	23ac      	movs	r3, #172	; 0xac
 8020490:	005b      	lsls	r3, r3, #1
 8020492:	58d3      	ldr	r3, [r2, r3]
 8020494:	687a      	ldr	r2, [r7, #4]
 8020496:	4013      	ands	r3, r2
 8020498:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 802049a:	68fb      	ldr	r3, [r7, #12]
}
 802049c:	46c0      	nop			; (mov r8, r8)
 802049e:	46bd      	mov	sp, r7
 80204a0:	b004      	add	sp, #16
 80204a2:	bd80      	pop	{r7, pc}

080204a4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80204a4:	b580      	push	{r7, lr}
 80204a6:	af00      	add	r7, sp, #0
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80204a8:	46c0      	nop			; (mov r8, r8)
 80204aa:	46bd      	mov	sp, r7
 80204ac:	bd80      	pop	{r7, pc}
	...

080204b0 <HAL_RTC_MspInit>:
* This function configures the hardware resources used in this example
* @param hrtc: RTC handle pointer
* @retval None
*/
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
 80204b0:	b590      	push	{r4, r7, lr}
 80204b2:	b091      	sub	sp, #68	; 0x44
 80204b4:	af00      	add	r7, sp, #0
 80204b6:	6078      	str	r0, [r7, #4]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80204b8:	2408      	movs	r4, #8
 80204ba:	193b      	adds	r3, r7, r4
 80204bc:	0018      	movs	r0, r3
 80204be:	2338      	movs	r3, #56	; 0x38
 80204c0:	001a      	movs	r2, r3
 80204c2:	2100      	movs	r1, #0
 80204c4:	f002 fc19 	bl	8022cfa <memset>
  if(hrtc->Instance==RTC)
 80204c8:	687b      	ldr	r3, [r7, #4]
 80204ca:	681b      	ldr	r3, [r3, #0]
 80204cc:	4a12      	ldr	r2, [pc, #72]	; (8020518 <HAL_RTC_MspInit+0x68>)
 80204ce:	4293      	cmp	r3, r2
 80204d0:	d11e      	bne.n	8020510 <HAL_RTC_MspInit+0x60>

  /* USER CODE END RTC_MspInit 0 */

  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 80204d2:	193b      	adds	r3, r7, r4
 80204d4:	2280      	movs	r2, #128	; 0x80
 80204d6:	0252      	lsls	r2, r2, #9
 80204d8:	601a      	str	r2, [r3, #0]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 80204da:	193b      	adds	r3, r7, r4
 80204dc:	2280      	movs	r2, #128	; 0x80
 80204de:	0092      	lsls	r2, r2, #2
 80204e0:	635a      	str	r2, [r3, #52]	; 0x34

    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80204e2:	193b      	adds	r3, r7, r4
 80204e4:	0018      	movs	r0, r3
 80204e6:	f000 fe57 	bl	8021198 <HAL_RCCEx_PeriphCLKConfig>
 80204ea:	1e03      	subs	r3, r0, #0
 80204ec:	d001      	beq.n	80204f2 <HAL_RTC_MspInit+0x42>
    {
      Error_Handler();
 80204ee:	f7ff ffa7 	bl	8020440 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 80204f2:	f7ff ffaa 	bl	802044a <LL_RCC_EnableRTC>
    __HAL_RCC_RTCAPB_CLK_ENABLE();
 80204f6:	2380      	movs	r3, #128	; 0x80
 80204f8:	00db      	lsls	r3, r3, #3
 80204fa:	0018      	movs	r0, r3
 80204fc:	f7ff ffb5 	bl	802046a <LL_C2_APB1_GRP1_EnableClock>
    /* RTC interrupt Init */
    HAL_NVIC_SetPriority(RTC_LSECSS_IRQn, 0, 0);
 8020500:	2200      	movs	r2, #0
 8020502:	2100      	movs	r1, #0
 8020504:	2002      	movs	r0, #2
 8020506:	f000 f985 	bl	8020814 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_LSECSS_IRQn);
 802050a:	2002      	movs	r0, #2
 802050c:	f000 f997 	bl	802083e <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }

}
 8020510:	46c0      	nop			; (mov r8, r8)
 8020512:	46bd      	mov	sp, r7
 8020514:	b011      	add	sp, #68	; 0x44
 8020516:	bd90      	pop	{r4, r7, pc}
 8020518:	40002800 	.word	0x40002800

0802051c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable Interrupt.
  */
void NMI_Handler(void)
{
 802051c:	b580      	push	{r7, lr}
 802051e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8020520:	e7fe      	b.n	8020520 <NMI_Handler+0x4>

08020522 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8020522:	b580      	push	{r7, lr}
 8020524:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8020526:	e7fe      	b.n	8020526 <HardFault_Handler+0x4>

08020528 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8020528:	b580      	push	{r7, lr}
 802052a:	af00      	add	r7, sp, #0

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 802052c:	46c0      	nop			; (mov r8, r8)
 802052e:	46bd      	mov	sp, r7
 8020530:	bd80      	pop	{r7, pc}

08020532 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8020532:	b580      	push	{r7, lr}
 8020534:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8020536:	46c0      	nop			; (mov r8, r8)
 8020538:	46bd      	mov	sp, r7
 802053a:	bd80      	pop	{r7, pc}

0802053c <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 802053c:	b580      	push	{r7, lr}
 802053e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8020540:	f000 f8a0 	bl	8020684 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8020544:	46c0      	nop			; (mov r8, r8)
 8020546:	46bd      	mov	sp, r7
 8020548:	bd80      	pop	{r7, pc}
	...

0802054c <RTC_LSECSS_IRQHandler>:

/**
  * @brief This function handles RTC Wakeup + RTC Tamper and RTC TimeStamp + RTC Alarms (A & B) and RTC SSRU Interrupts and LSECSS Interrupts.
  */
void RTC_LSECSS_IRQHandler(void)
{
 802054c:	b580      	push	{r7, lr}
 802054e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN RTC_LSECSS_IRQn 0 */

  /* USER CODE END RTC_LSECSS_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 8020550:	4b03      	ldr	r3, [pc, #12]	; (8020560 <RTC_LSECSS_IRQHandler+0x14>)
 8020552:	0018      	movs	r0, r3
 8020554:	f001 fb4e 	bl	8021bf4 <HAL_RTC_AlarmIRQHandler>
  /* USER CODE BEGIN RTC_LSECSS_IRQn 1 */

  /* USER CODE END RTC_LSECSS_IRQn 1 */
}
 8020558:	46c0      	nop			; (mov r8, r8)
 802055a:	46bd      	mov	sp, r7
 802055c:	bd80      	pop	{r7, pc}
 802055e:	46c0      	nop			; (mov r8, r8)
 8020560:	20008028 	.word	0x20008028

08020564 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8020564:	480d      	ldr	r0, [pc, #52]	; (802059c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8020566:	4685      	mov	sp, r0

/* Call the clock system initialization function.*/
  bl  SystemInit
 8020568:	f7ff fe5a 	bl	8020220 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 802056c:	480c      	ldr	r0, [pc, #48]	; (80205a0 <LoopForever+0x6>)
  ldr r1, =_edata
 802056e:	490d      	ldr	r1, [pc, #52]	; (80205a4 <LoopForever+0xa>)
  ldr r2, =_sidata
 8020570:	4a0d      	ldr	r2, [pc, #52]	; (80205a8 <LoopForever+0xe>)
  movs r3, #0
 8020572:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8020574:	e002      	b.n	802057c <LoopCopyDataInit>

08020576 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8020576:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8020578:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 802057a:	3304      	adds	r3, #4

0802057c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 802057c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 802057e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8020580:	d3f9      	bcc.n	8020576 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8020582:	4a0a      	ldr	r2, [pc, #40]	; (80205ac <LoopForever+0x12>)
  ldr r4, =_ebss
 8020584:	4c0a      	ldr	r4, [pc, #40]	; (80205b0 <LoopForever+0x16>)
  movs r3, #0
 8020586:	2300      	movs	r3, #0
  b LoopFillZerobss
 8020588:	e001      	b.n	802058e <LoopFillZerobss>

0802058a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 802058a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 802058c:	3204      	adds	r2, #4

0802058e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 802058e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8020590:	d3fb      	bcc.n	802058a <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8020592:	f002 fb85 	bl	8022ca0 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8020596:	f7ff fe49 	bl	802022c <main>

0802059a <LoopForever>:

LoopForever:
    b LoopForever
 802059a:	e7fe      	b.n	802059a <LoopForever>
  ldr   r0, =_estack
 802059c:	20010000 	.word	0x20010000
  ldr r0, =_sdata
 80205a0:	20008000 	.word	0x20008000
  ldr r1, =_edata
 80205a4:	2000800c 	.word	0x2000800c
  ldr r2, =_sidata
 80205a8:	08022df0 	.word	0x08022df0
  ldr r2, =_sbss
 80205ac:	2000800c 	.word	0x2000800c
  ldr r4, =_ebss
 80205b0:	20008400 	.word	0x20008400

080205b4 <ADC_COMP_DAC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80205b4:	e7fe      	b.n	80205b4 <ADC_COMP_DAC_IRQHandler>
	...

080205b8 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80205b8:	b580      	push	{r7, lr}
 80205ba:	b082      	sub	sp, #8
 80205bc:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 80205be:	1dfb      	adds	r3, r7, #7
 80205c0:	2200      	movs	r2, #0
 80205c2:	701a      	strb	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
#endif

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
 80205c4:	f000 fccc 	bl	8020f60 <HAL_RCC_GetHCLK2Freq>
 80205c8:	0002      	movs	r2, r0
 80205ca:	4b09      	ldr	r3, [pc, #36]	; (80205f0 <HAL_Init+0x38>)
 80205cc:	601a      	str	r2, [r3, #0]
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80205ce:	2000      	movs	r0, #0
 80205d0:	f000 f810 	bl	80205f4 <HAL_InitTick>
 80205d4:	1e03      	subs	r3, r0, #0
 80205d6:	d003      	beq.n	80205e0 <HAL_Init+0x28>
  {
    status = HAL_ERROR;
 80205d8:	1dfb      	adds	r3, r7, #7
 80205da:	2201      	movs	r2, #1
 80205dc:	701a      	strb	r2, [r3, #0]
 80205de:	e001      	b.n	80205e4 <HAL_Init+0x2c>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 80205e0:	f7ff ff60 	bl	80204a4 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 80205e4:	1dfb      	adds	r3, r7, #7
 80205e6:	781b      	ldrb	r3, [r3, #0]
}
 80205e8:	0018      	movs	r0, r3
 80205ea:	46bd      	mov	sp, r7
 80205ec:	b002      	add	sp, #8
 80205ee:	bd80      	pop	{r7, pc}
 80205f0:	20008000 	.word	0x20008000

080205f4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80205f4:	b590      	push	{r4, r7, lr}
 80205f6:	b085      	sub	sp, #20
 80205f8:	af00      	add	r7, sp, #0
 80205fa:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 80205fc:	230f      	movs	r3, #15
 80205fe:	18fb      	adds	r3, r7, r3
 8020600:	2200      	movs	r2, #0
 8020602:	701a      	strb	r2, [r3, #0]

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 8020604:	4b1d      	ldr	r3, [pc, #116]	; (802067c <HAL_InitTick+0x88>)
 8020606:	781b      	ldrb	r3, [r3, #0]
 8020608:	2b00      	cmp	r3, #0
 802060a:	d02c      	beq.n	8020666 <HAL_InitTick+0x72>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
#ifdef CORE_CM0PLUS
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLK2Freq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
 802060c:	f000 fca8 	bl	8020f60 <HAL_RCC_GetHCLK2Freq>
 8020610:	0004      	movs	r4, r0
 8020612:	4b1a      	ldr	r3, [pc, #104]	; (802067c <HAL_InitTick+0x88>)
 8020614:	781b      	ldrb	r3, [r3, #0]
 8020616:	0019      	movs	r1, r3
 8020618:	23fa      	movs	r3, #250	; 0xfa
 802061a:	0098      	lsls	r0, r3, #2
 802061c:	f7ff fd74 	bl	8020108 <__udivsi3>
 8020620:	0003      	movs	r3, r0
 8020622:	0019      	movs	r1, r3
 8020624:	0020      	movs	r0, r4
 8020626:	f7ff fd6f 	bl	8020108 <__udivsi3>
 802062a:	0003      	movs	r3, r0
 802062c:	0018      	movs	r0, r3
 802062e:	f000 f916 	bl	802085e <HAL_SYSTICK_Config>
 8020632:	1e03      	subs	r3, r0, #0
 8020634:	d112      	bne.n	802065c <HAL_InitTick+0x68>
#else
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
#endif
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8020636:	687b      	ldr	r3, [r7, #4]
 8020638:	2b03      	cmp	r3, #3
 802063a:	d80a      	bhi.n	8020652 <HAL_InitTick+0x5e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 802063c:	6879      	ldr	r1, [r7, #4]
 802063e:	2301      	movs	r3, #1
 8020640:	425b      	negs	r3, r3
 8020642:	2200      	movs	r2, #0
 8020644:	0018      	movs	r0, r3
 8020646:	f000 f8e5 	bl	8020814 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 802064a:	4b0d      	ldr	r3, [pc, #52]	; (8020680 <HAL_InitTick+0x8c>)
 802064c:	687a      	ldr	r2, [r7, #4]
 802064e:	601a      	str	r2, [r3, #0]
 8020650:	e00d      	b.n	802066e <HAL_InitTick+0x7a>
      }
      else
      {
        status = HAL_ERROR;
 8020652:	230f      	movs	r3, #15
 8020654:	18fb      	adds	r3, r7, r3
 8020656:	2201      	movs	r2, #1
 8020658:	701a      	strb	r2, [r3, #0]
 802065a:	e008      	b.n	802066e <HAL_InitTick+0x7a>
      }
    }
    else
    {
      status = HAL_ERROR;
 802065c:	230f      	movs	r3, #15
 802065e:	18fb      	adds	r3, r7, r3
 8020660:	2201      	movs	r2, #1
 8020662:	701a      	strb	r2, [r3, #0]
 8020664:	e003      	b.n	802066e <HAL_InitTick+0x7a>
    }
  }
  else
  {
    status = HAL_ERROR;
 8020666:	230f      	movs	r3, #15
 8020668:	18fb      	adds	r3, r7, r3
 802066a:	2201      	movs	r2, #1
 802066c:	701a      	strb	r2, [r3, #0]
  }

  /* Return function status */
  return status;
 802066e:	230f      	movs	r3, #15
 8020670:	18fb      	adds	r3, r7, r3
 8020672:	781b      	ldrb	r3, [r3, #0]
}
 8020674:	0018      	movs	r0, r3
 8020676:	46bd      	mov	sp, r7
 8020678:	b005      	add	sp, #20
 802067a:	bd90      	pop	{r4, r7, pc}
 802067c:	20008008 	.word	0x20008008
 8020680:	20008004 	.word	0x20008004

08020684 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8020684:	b580      	push	{r7, lr}
 8020686:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8020688:	4b05      	ldr	r3, [pc, #20]	; (80206a0 <HAL_IncTick+0x1c>)
 802068a:	781b      	ldrb	r3, [r3, #0]
 802068c:	001a      	movs	r2, r3
 802068e:	4b05      	ldr	r3, [pc, #20]	; (80206a4 <HAL_IncTick+0x20>)
 8020690:	681b      	ldr	r3, [r3, #0]
 8020692:	18d2      	adds	r2, r2, r3
 8020694:	4b03      	ldr	r3, [pc, #12]	; (80206a4 <HAL_IncTick+0x20>)
 8020696:	601a      	str	r2, [r3, #0]
}
 8020698:	46c0      	nop			; (mov r8, r8)
 802069a:	46bd      	mov	sp, r7
 802069c:	bd80      	pop	{r7, pc}
 802069e:	46c0      	nop			; (mov r8, r8)
 80206a0:	20008008 	.word	0x20008008
 80206a4:	20008060 	.word	0x20008060

080206a8 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80206a8:	b580      	push	{r7, lr}
 80206aa:	af00      	add	r7, sp, #0
  return uwTick;
 80206ac:	4b02      	ldr	r3, [pc, #8]	; (80206b8 <HAL_GetTick+0x10>)
 80206ae:	681b      	ldr	r3, [r3, #0]
}
 80206b0:	0018      	movs	r0, r3
 80206b2:	46bd      	mov	sp, r7
 80206b4:	bd80      	pop	{r7, pc}
 80206b6:	46c0      	nop			; (mov r8, r8)
 80206b8:	20008060 	.word	0x20008060

080206bc <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80206bc:	b580      	push	{r7, lr}
 80206be:	b082      	sub	sp, #8
 80206c0:	af00      	add	r7, sp, #0
 80206c2:	0002      	movs	r2, r0
 80206c4:	1dfb      	adds	r3, r7, #7
 80206c6:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 80206c8:	1dfb      	adds	r3, r7, #7
 80206ca:	781b      	ldrb	r3, [r3, #0]
 80206cc:	2b7f      	cmp	r3, #127	; 0x7f
 80206ce:	d809      	bhi.n	80206e4 <__NVIC_EnableIRQ+0x28>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80206d0:	1dfb      	adds	r3, r7, #7
 80206d2:	781b      	ldrb	r3, [r3, #0]
 80206d4:	001a      	movs	r2, r3
 80206d6:	231f      	movs	r3, #31
 80206d8:	401a      	ands	r2, r3
 80206da:	4b04      	ldr	r3, [pc, #16]	; (80206ec <__NVIC_EnableIRQ+0x30>)
 80206dc:	2101      	movs	r1, #1
 80206de:	4091      	lsls	r1, r2
 80206e0:	000a      	movs	r2, r1
 80206e2:	601a      	str	r2, [r3, #0]
    __COMPILER_BARRIER();
  }
}
 80206e4:	46c0      	nop			; (mov r8, r8)
 80206e6:	46bd      	mov	sp, r7
 80206e8:	b002      	add	sp, #8
 80206ea:	bd80      	pop	{r7, pc}
 80206ec:	e000e100 	.word	0xe000e100

080206f0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80206f0:	b590      	push	{r4, r7, lr}
 80206f2:	b083      	sub	sp, #12
 80206f4:	af00      	add	r7, sp, #0
 80206f6:	0002      	movs	r2, r0
 80206f8:	6039      	str	r1, [r7, #0]
 80206fa:	1dfb      	adds	r3, r7, #7
 80206fc:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 80206fe:	1dfb      	adds	r3, r7, #7
 8020700:	781b      	ldrb	r3, [r3, #0]
 8020702:	2b7f      	cmp	r3, #127	; 0x7f
 8020704:	d828      	bhi.n	8020758 <__NVIC_SetPriority+0x68>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8020706:	4a2f      	ldr	r2, [pc, #188]	; (80207c4 <__NVIC_SetPriority+0xd4>)
 8020708:	1dfb      	adds	r3, r7, #7
 802070a:	781b      	ldrb	r3, [r3, #0]
 802070c:	b25b      	sxtb	r3, r3
 802070e:	089b      	lsrs	r3, r3, #2
 8020710:	33c0      	adds	r3, #192	; 0xc0
 8020712:	009b      	lsls	r3, r3, #2
 8020714:	589b      	ldr	r3, [r3, r2]
 8020716:	1dfa      	adds	r2, r7, #7
 8020718:	7812      	ldrb	r2, [r2, #0]
 802071a:	0011      	movs	r1, r2
 802071c:	2203      	movs	r2, #3
 802071e:	400a      	ands	r2, r1
 8020720:	00d2      	lsls	r2, r2, #3
 8020722:	21ff      	movs	r1, #255	; 0xff
 8020724:	4091      	lsls	r1, r2
 8020726:	000a      	movs	r2, r1
 8020728:	43d2      	mvns	r2, r2
 802072a:	401a      	ands	r2, r3
 802072c:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 802072e:	683b      	ldr	r3, [r7, #0]
 8020730:	019b      	lsls	r3, r3, #6
 8020732:	22ff      	movs	r2, #255	; 0xff
 8020734:	401a      	ands	r2, r3
 8020736:	1dfb      	adds	r3, r7, #7
 8020738:	781b      	ldrb	r3, [r3, #0]
 802073a:	0018      	movs	r0, r3
 802073c:	2303      	movs	r3, #3
 802073e:	4003      	ands	r3, r0
 8020740:	00db      	lsls	r3, r3, #3
 8020742:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8020744:	481f      	ldr	r0, [pc, #124]	; (80207c4 <__NVIC_SetPriority+0xd4>)
 8020746:	1dfb      	adds	r3, r7, #7
 8020748:	781b      	ldrb	r3, [r3, #0]
 802074a:	b25b      	sxtb	r3, r3
 802074c:	089b      	lsrs	r3, r3, #2
 802074e:	430a      	orrs	r2, r1
 8020750:	33c0      	adds	r3, #192	; 0xc0
 8020752:	009b      	lsls	r3, r3, #2
 8020754:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 8020756:	e031      	b.n	80207bc <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8020758:	4a1b      	ldr	r2, [pc, #108]	; (80207c8 <__NVIC_SetPriority+0xd8>)
 802075a:	1dfb      	adds	r3, r7, #7
 802075c:	781b      	ldrb	r3, [r3, #0]
 802075e:	0019      	movs	r1, r3
 8020760:	230f      	movs	r3, #15
 8020762:	400b      	ands	r3, r1
 8020764:	3b08      	subs	r3, #8
 8020766:	089b      	lsrs	r3, r3, #2
 8020768:	3306      	adds	r3, #6
 802076a:	009b      	lsls	r3, r3, #2
 802076c:	18d3      	adds	r3, r2, r3
 802076e:	3304      	adds	r3, #4
 8020770:	681b      	ldr	r3, [r3, #0]
 8020772:	1dfa      	adds	r2, r7, #7
 8020774:	7812      	ldrb	r2, [r2, #0]
 8020776:	0011      	movs	r1, r2
 8020778:	2203      	movs	r2, #3
 802077a:	400a      	ands	r2, r1
 802077c:	00d2      	lsls	r2, r2, #3
 802077e:	21ff      	movs	r1, #255	; 0xff
 8020780:	4091      	lsls	r1, r2
 8020782:	000a      	movs	r2, r1
 8020784:	43d2      	mvns	r2, r2
 8020786:	401a      	ands	r2, r3
 8020788:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 802078a:	683b      	ldr	r3, [r7, #0]
 802078c:	019b      	lsls	r3, r3, #6
 802078e:	22ff      	movs	r2, #255	; 0xff
 8020790:	401a      	ands	r2, r3
 8020792:	1dfb      	adds	r3, r7, #7
 8020794:	781b      	ldrb	r3, [r3, #0]
 8020796:	0018      	movs	r0, r3
 8020798:	2303      	movs	r3, #3
 802079a:	4003      	ands	r3, r0
 802079c:	00db      	lsls	r3, r3, #3
 802079e:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80207a0:	4809      	ldr	r0, [pc, #36]	; (80207c8 <__NVIC_SetPriority+0xd8>)
 80207a2:	1dfb      	adds	r3, r7, #7
 80207a4:	781b      	ldrb	r3, [r3, #0]
 80207a6:	001c      	movs	r4, r3
 80207a8:	230f      	movs	r3, #15
 80207aa:	4023      	ands	r3, r4
 80207ac:	3b08      	subs	r3, #8
 80207ae:	089b      	lsrs	r3, r3, #2
 80207b0:	430a      	orrs	r2, r1
 80207b2:	3306      	adds	r3, #6
 80207b4:	009b      	lsls	r3, r3, #2
 80207b6:	18c3      	adds	r3, r0, r3
 80207b8:	3304      	adds	r3, #4
 80207ba:	601a      	str	r2, [r3, #0]
}
 80207bc:	46c0      	nop			; (mov r8, r8)
 80207be:	46bd      	mov	sp, r7
 80207c0:	b003      	add	sp, #12
 80207c2:	bd90      	pop	{r4, r7, pc}
 80207c4:	e000e100 	.word	0xe000e100
 80207c8:	e000ed00 	.word	0xe000ed00

080207cc <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 80207cc:	b580      	push	{r7, lr}
 80207ce:	b082      	sub	sp, #8
 80207d0:	af00      	add	r7, sp, #0
 80207d2:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80207d4:	687b      	ldr	r3, [r7, #4]
 80207d6:	1e5a      	subs	r2, r3, #1
 80207d8:	2380      	movs	r3, #128	; 0x80
 80207da:	045b      	lsls	r3, r3, #17
 80207dc:	429a      	cmp	r2, r3
 80207de:	d301      	bcc.n	80207e4 <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
 80207e0:	2301      	movs	r3, #1
 80207e2:	e010      	b.n	8020806 <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80207e4:	4b0a      	ldr	r3, [pc, #40]	; (8020810 <SysTick_Config+0x44>)
 80207e6:	687a      	ldr	r2, [r7, #4]
 80207e8:	3a01      	subs	r2, #1
 80207ea:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 80207ec:	2301      	movs	r3, #1
 80207ee:	425b      	negs	r3, r3
 80207f0:	2103      	movs	r1, #3
 80207f2:	0018      	movs	r0, r3
 80207f4:	f7ff ff7c 	bl	80206f0 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80207f8:	4b05      	ldr	r3, [pc, #20]	; (8020810 <SysTick_Config+0x44>)
 80207fa:	2200      	movs	r2, #0
 80207fc:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80207fe:	4b04      	ldr	r3, [pc, #16]	; (8020810 <SysTick_Config+0x44>)
 8020800:	2207      	movs	r2, #7
 8020802:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8020804:	2300      	movs	r3, #0
}
 8020806:	0018      	movs	r0, r3
 8020808:	46bd      	mov	sp, r7
 802080a:	b002      	add	sp, #8
 802080c:	bd80      	pop	{r7, pc}
 802080e:	46c0      	nop			; (mov r8, r8)
 8020810:	e000e010 	.word	0xe000e010

08020814 <HAL_NVIC_SetPriority>:
  *         with stm32wlxx devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8020814:	b580      	push	{r7, lr}
 8020816:	b084      	sub	sp, #16
 8020818:	af00      	add	r7, sp, #0
 802081a:	60b9      	str	r1, [r7, #8]
 802081c:	607a      	str	r2, [r7, #4]
 802081e:	210f      	movs	r1, #15
 8020820:	187b      	adds	r3, r7, r1
 8020822:	1c02      	adds	r2, r0, #0
 8020824:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
 8020826:	68ba      	ldr	r2, [r7, #8]
 8020828:	187b      	adds	r3, r7, r1
 802082a:	781b      	ldrb	r3, [r3, #0]
 802082c:	b25b      	sxtb	r3, r3
 802082e:	0011      	movs	r1, r2
 8020830:	0018      	movs	r0, r3
 8020832:	f7ff ff5d 	bl	80206f0 <__NVIC_SetPriority>
}
 8020836:	46c0      	nop			; (mov r8, r8)
 8020838:	46bd      	mov	sp, r7
 802083a:	b004      	add	sp, #16
 802083c:	bd80      	pop	{r7, pc}

0802083e <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *          to the appropriate CMSIS device file (stm32wlxxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 802083e:	b580      	push	{r7, lr}
 8020840:	b082      	sub	sp, #8
 8020842:	af00      	add	r7, sp, #0
 8020844:	0002      	movs	r2, r0
 8020846:	1dfb      	adds	r3, r7, #7
 8020848:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 802084a:	1dfb      	adds	r3, r7, #7
 802084c:	781b      	ldrb	r3, [r3, #0]
 802084e:	b25b      	sxtb	r3, r3
 8020850:	0018      	movs	r0, r3
 8020852:	f7ff ff33 	bl	80206bc <__NVIC_EnableIRQ>
}
 8020856:	46c0      	nop			; (mov r8, r8)
 8020858:	46bd      	mov	sp, r7
 802085a:	b002      	add	sp, #8
 802085c:	bd80      	pop	{r7, pc}

0802085e <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 802085e:	b580      	push	{r7, lr}
 8020860:	b082      	sub	sp, #8
 8020862:	af00      	add	r7, sp, #0
 8020864:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
 8020866:	687b      	ldr	r3, [r7, #4]
 8020868:	0018      	movs	r0, r3
 802086a:	f7ff ffaf 	bl	80207cc <SysTick_Config>
 802086e:	0003      	movs	r3, r0
}
 8020870:	0018      	movs	r0, r3
 8020872:	46bd      	mov	sp, r7
 8020874:	b002      	add	sp, #8
 8020876:	bd80      	pop	{r7, pc}

08020878 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8020878:	b580      	push	{r7, lr}
 802087a:	b086      	sub	sp, #24
 802087c:	af00      	add	r7, sp, #0
 802087e:	6078      	str	r0, [r7, #4]
 8020880:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 8020882:	2300      	movs	r3, #0
 8020884:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8020886:	e141      	b.n	8020b0c <HAL_GPIO_Init+0x294>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8020888:	683b      	ldr	r3, [r7, #0]
 802088a:	681b      	ldr	r3, [r3, #0]
 802088c:	2101      	movs	r1, #1
 802088e:	697a      	ldr	r2, [r7, #20]
 8020890:	4091      	lsls	r1, r2
 8020892:	000a      	movs	r2, r1
 8020894:	4013      	ands	r3, r2
 8020896:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 8020898:	68fb      	ldr	r3, [r7, #12]
 802089a:	2b00      	cmp	r3, #0
 802089c:	d100      	bne.n	80208a0 <HAL_GPIO_Init+0x28>
 802089e:	e132      	b.n	8020b06 <HAL_GPIO_Init+0x28e>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 80208a0:	683b      	ldr	r3, [r7, #0]
 80208a2:	685b      	ldr	r3, [r3, #4]
 80208a4:	2203      	movs	r2, #3
 80208a6:	4013      	ands	r3, r2
 80208a8:	2b01      	cmp	r3, #1
 80208aa:	d005      	beq.n	80208b8 <HAL_GPIO_Init+0x40>
 80208ac:	683b      	ldr	r3, [r7, #0]
 80208ae:	685b      	ldr	r3, [r3, #4]
 80208b0:	2203      	movs	r2, #3
 80208b2:	4013      	ands	r3, r2
 80208b4:	2b02      	cmp	r3, #2
 80208b6:	d130      	bne.n	802091a <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 80208b8:	687b      	ldr	r3, [r7, #4]
 80208ba:	689b      	ldr	r3, [r3, #8]
 80208bc:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80208be:	697b      	ldr	r3, [r7, #20]
 80208c0:	005b      	lsls	r3, r3, #1
 80208c2:	2203      	movs	r2, #3
 80208c4:	409a      	lsls	r2, r3
 80208c6:	0013      	movs	r3, r2
 80208c8:	43da      	mvns	r2, r3
 80208ca:	693b      	ldr	r3, [r7, #16]
 80208cc:	4013      	ands	r3, r2
 80208ce:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 80208d0:	683b      	ldr	r3, [r7, #0]
 80208d2:	68da      	ldr	r2, [r3, #12]
 80208d4:	697b      	ldr	r3, [r7, #20]
 80208d6:	005b      	lsls	r3, r3, #1
 80208d8:	409a      	lsls	r2, r3
 80208da:	0013      	movs	r3, r2
 80208dc:	693a      	ldr	r2, [r7, #16]
 80208de:	4313      	orrs	r3, r2
 80208e0:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 80208e2:	687b      	ldr	r3, [r7, #4]
 80208e4:	693a      	ldr	r2, [r7, #16]
 80208e6:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80208e8:	687b      	ldr	r3, [r7, #4]
 80208ea:	685b      	ldr	r3, [r3, #4]
 80208ec:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 80208ee:	2201      	movs	r2, #1
 80208f0:	697b      	ldr	r3, [r7, #20]
 80208f2:	409a      	lsls	r2, r3
 80208f4:	0013      	movs	r3, r2
 80208f6:	43da      	mvns	r2, r3
 80208f8:	693b      	ldr	r3, [r7, #16]
 80208fa:	4013      	ands	r3, r2
 80208fc:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80208fe:	683b      	ldr	r3, [r7, #0]
 8020900:	685b      	ldr	r3, [r3, #4]
 8020902:	091b      	lsrs	r3, r3, #4
 8020904:	2201      	movs	r2, #1
 8020906:	401a      	ands	r2, r3
 8020908:	697b      	ldr	r3, [r7, #20]
 802090a:	409a      	lsls	r2, r3
 802090c:	0013      	movs	r3, r2
 802090e:	693a      	ldr	r2, [r7, #16]
 8020910:	4313      	orrs	r3, r2
 8020912:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 8020914:	687b      	ldr	r3, [r7, #4]
 8020916:	693a      	ldr	r2, [r7, #16]
 8020918:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 802091a:	683b      	ldr	r3, [r7, #0]
 802091c:	685b      	ldr	r3, [r3, #4]
 802091e:	2203      	movs	r2, #3
 8020920:	4013      	ands	r3, r2
 8020922:	2b03      	cmp	r3, #3
 8020924:	d017      	beq.n	8020956 <HAL_GPIO_Init+0xde>
      {
        temp = GPIOx->PUPDR;
 8020926:	687b      	ldr	r3, [r7, #4]
 8020928:	68db      	ldr	r3, [r3, #12]
 802092a:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 802092c:	697b      	ldr	r3, [r7, #20]
 802092e:	005b      	lsls	r3, r3, #1
 8020930:	2203      	movs	r2, #3
 8020932:	409a      	lsls	r2, r3
 8020934:	0013      	movs	r3, r2
 8020936:	43da      	mvns	r2, r3
 8020938:	693b      	ldr	r3, [r7, #16]
 802093a:	4013      	ands	r3, r2
 802093c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 802093e:	683b      	ldr	r3, [r7, #0]
 8020940:	689a      	ldr	r2, [r3, #8]
 8020942:	697b      	ldr	r3, [r7, #20]
 8020944:	005b      	lsls	r3, r3, #1
 8020946:	409a      	lsls	r2, r3
 8020948:	0013      	movs	r3, r2
 802094a:	693a      	ldr	r2, [r7, #16]
 802094c:	4313      	orrs	r3, r2
 802094e:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 8020950:	687b      	ldr	r3, [r7, #4]
 8020952:	693a      	ldr	r2, [r7, #16]
 8020954:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8020956:	683b      	ldr	r3, [r7, #0]
 8020958:	685b      	ldr	r3, [r3, #4]
 802095a:	2203      	movs	r2, #3
 802095c:	4013      	ands	r3, r2
 802095e:	2b02      	cmp	r3, #2
 8020960:	d123      	bne.n	80209aa <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8020962:	697b      	ldr	r3, [r7, #20]
 8020964:	08da      	lsrs	r2, r3, #3
 8020966:	687b      	ldr	r3, [r7, #4]
 8020968:	3208      	adds	r2, #8
 802096a:	0092      	lsls	r2, r2, #2
 802096c:	58d3      	ldr	r3, [r2, r3]
 802096e:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8020970:	697b      	ldr	r3, [r7, #20]
 8020972:	2207      	movs	r2, #7
 8020974:	4013      	ands	r3, r2
 8020976:	009b      	lsls	r3, r3, #2
 8020978:	220f      	movs	r2, #15
 802097a:	409a      	lsls	r2, r3
 802097c:	0013      	movs	r3, r2
 802097e:	43da      	mvns	r2, r3
 8020980:	693b      	ldr	r3, [r7, #16]
 8020982:	4013      	ands	r3, r2
 8020984:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8020986:	683b      	ldr	r3, [r7, #0]
 8020988:	691a      	ldr	r2, [r3, #16]
 802098a:	697b      	ldr	r3, [r7, #20]
 802098c:	2107      	movs	r1, #7
 802098e:	400b      	ands	r3, r1
 8020990:	009b      	lsls	r3, r3, #2
 8020992:	409a      	lsls	r2, r3
 8020994:	0013      	movs	r3, r2
 8020996:	693a      	ldr	r2, [r7, #16]
 8020998:	4313      	orrs	r3, r2
 802099a:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
 802099c:	697b      	ldr	r3, [r7, #20]
 802099e:	08da      	lsrs	r2, r3, #3
 80209a0:	687b      	ldr	r3, [r7, #4]
 80209a2:	3208      	adds	r2, #8
 80209a4:	0092      	lsls	r2, r2, #2
 80209a6:	6939      	ldr	r1, [r7, #16]
 80209a8:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80209aa:	687b      	ldr	r3, [r7, #4]
 80209ac:	681b      	ldr	r3, [r3, #0]
 80209ae:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 80209b0:	697b      	ldr	r3, [r7, #20]
 80209b2:	005b      	lsls	r3, r3, #1
 80209b4:	2203      	movs	r2, #3
 80209b6:	409a      	lsls	r2, r3
 80209b8:	0013      	movs	r3, r2
 80209ba:	43da      	mvns	r2, r3
 80209bc:	693b      	ldr	r3, [r7, #16]
 80209be:	4013      	ands	r3, r2
 80209c0:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80209c2:	683b      	ldr	r3, [r7, #0]
 80209c4:	685b      	ldr	r3, [r3, #4]
 80209c6:	2203      	movs	r2, #3
 80209c8:	401a      	ands	r2, r3
 80209ca:	697b      	ldr	r3, [r7, #20]
 80209cc:	005b      	lsls	r3, r3, #1
 80209ce:	409a      	lsls	r2, r3
 80209d0:	0013      	movs	r3, r2
 80209d2:	693a      	ldr	r2, [r7, #16]
 80209d4:	4313      	orrs	r3, r2
 80209d6:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 80209d8:	687b      	ldr	r3, [r7, #4]
 80209da:	693a      	ldr	r2, [r7, #16]
 80209dc:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80209de:	683b      	ldr	r3, [r7, #0]
 80209e0:	685a      	ldr	r2, [r3, #4]
 80209e2:	23c0      	movs	r3, #192	; 0xc0
 80209e4:	029b      	lsls	r3, r3, #10
 80209e6:	4013      	ands	r3, r2
 80209e8:	d100      	bne.n	80209ec <HAL_GPIO_Init+0x174>
 80209ea:	e08c      	b.n	8020b06 <HAL_GPIO_Init+0x28e>
      {
        temp = SYSCFG->EXTICR[position >> 2u];
 80209ec:	4a4d      	ldr	r2, [pc, #308]	; (8020b24 <HAL_GPIO_Init+0x2ac>)
 80209ee:	697b      	ldr	r3, [r7, #20]
 80209f0:	089b      	lsrs	r3, r3, #2
 80209f2:	3302      	adds	r3, #2
 80209f4:	009b      	lsls	r3, r3, #2
 80209f6:	589b      	ldr	r3, [r3, r2]
 80209f8:	613b      	str	r3, [r7, #16]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 80209fa:	697b      	ldr	r3, [r7, #20]
 80209fc:	2203      	movs	r2, #3
 80209fe:	4013      	ands	r3, r2
 8020a00:	009b      	lsls	r3, r3, #2
 8020a02:	2207      	movs	r2, #7
 8020a04:	409a      	lsls	r2, r3
 8020a06:	0013      	movs	r3, r2
 8020a08:	43da      	mvns	r2, r3
 8020a0a:	693b      	ldr	r3, [r7, #16]
 8020a0c:	4013      	ands	r3, r2
 8020a0e:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8020a10:	687a      	ldr	r2, [r7, #4]
 8020a12:	2390      	movs	r3, #144	; 0x90
 8020a14:	05db      	lsls	r3, r3, #23
 8020a16:	429a      	cmp	r2, r3
 8020a18:	d00d      	beq.n	8020a36 <HAL_GPIO_Init+0x1be>
 8020a1a:	687b      	ldr	r3, [r7, #4]
 8020a1c:	4a42      	ldr	r2, [pc, #264]	; (8020b28 <HAL_GPIO_Init+0x2b0>)
 8020a1e:	4293      	cmp	r3, r2
 8020a20:	d007      	beq.n	8020a32 <HAL_GPIO_Init+0x1ba>
 8020a22:	687b      	ldr	r3, [r7, #4]
 8020a24:	4a41      	ldr	r2, [pc, #260]	; (8020b2c <HAL_GPIO_Init+0x2b4>)
 8020a26:	4293      	cmp	r3, r2
 8020a28:	d101      	bne.n	8020a2e <HAL_GPIO_Init+0x1b6>
 8020a2a:	2302      	movs	r3, #2
 8020a2c:	e004      	b.n	8020a38 <HAL_GPIO_Init+0x1c0>
 8020a2e:	2307      	movs	r3, #7
 8020a30:	e002      	b.n	8020a38 <HAL_GPIO_Init+0x1c0>
 8020a32:	2301      	movs	r3, #1
 8020a34:	e000      	b.n	8020a38 <HAL_GPIO_Init+0x1c0>
 8020a36:	2300      	movs	r3, #0
 8020a38:	697a      	ldr	r2, [r7, #20]
 8020a3a:	2103      	movs	r1, #3
 8020a3c:	400a      	ands	r2, r1
 8020a3e:	0092      	lsls	r2, r2, #2
 8020a40:	4093      	lsls	r3, r2
 8020a42:	693a      	ldr	r2, [r7, #16]
 8020a44:	4313      	orrs	r3, r2
 8020a46:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2u] = temp;
 8020a48:	4936      	ldr	r1, [pc, #216]	; (8020b24 <HAL_GPIO_Init+0x2ac>)
 8020a4a:	697b      	ldr	r3, [r7, #20]
 8020a4c:	089b      	lsrs	r3, r3, #2
 8020a4e:	3302      	adds	r3, #2
 8020a50:	009b      	lsls	r3, r3, #2
 8020a52:	693a      	ldr	r2, [r7, #16]
 8020a54:	505a      	str	r2, [r3, r1]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8020a56:	4b36      	ldr	r3, [pc, #216]	; (8020b30 <HAL_GPIO_Init+0x2b8>)
 8020a58:	681b      	ldr	r3, [r3, #0]
 8020a5a:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8020a5c:	68fb      	ldr	r3, [r7, #12]
 8020a5e:	43da      	mvns	r2, r3
 8020a60:	693b      	ldr	r3, [r7, #16]
 8020a62:	4013      	ands	r3, r2
 8020a64:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8020a66:	683b      	ldr	r3, [r7, #0]
 8020a68:	685a      	ldr	r2, [r3, #4]
 8020a6a:	2380      	movs	r3, #128	; 0x80
 8020a6c:	035b      	lsls	r3, r3, #13
 8020a6e:	4013      	ands	r3, r2
 8020a70:	d003      	beq.n	8020a7a <HAL_GPIO_Init+0x202>
        {
          temp |= iocurrent;
 8020a72:	693a      	ldr	r2, [r7, #16]
 8020a74:	68fb      	ldr	r3, [r7, #12]
 8020a76:	4313      	orrs	r3, r2
 8020a78:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 8020a7a:	4b2d      	ldr	r3, [pc, #180]	; (8020b30 <HAL_GPIO_Init+0x2b8>)
 8020a7c:	693a      	ldr	r2, [r7, #16]
 8020a7e:	601a      	str	r2, [r3, #0]

        temp = EXTI->FTSR1;
 8020a80:	4b2b      	ldr	r3, [pc, #172]	; (8020b30 <HAL_GPIO_Init+0x2b8>)
 8020a82:	685b      	ldr	r3, [r3, #4]
 8020a84:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8020a86:	68fb      	ldr	r3, [r7, #12]
 8020a88:	43da      	mvns	r2, r3
 8020a8a:	693b      	ldr	r3, [r7, #16]
 8020a8c:	4013      	ands	r3, r2
 8020a8e:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8020a90:	683b      	ldr	r3, [r7, #0]
 8020a92:	685a      	ldr	r2, [r3, #4]
 8020a94:	2380      	movs	r3, #128	; 0x80
 8020a96:	039b      	lsls	r3, r3, #14
 8020a98:	4013      	ands	r3, r2
 8020a9a:	d003      	beq.n	8020aa4 <HAL_GPIO_Init+0x22c>
        {
          temp |= iocurrent;
 8020a9c:	693a      	ldr	r2, [r7, #16]
 8020a9e:	68fb      	ldr	r3, [r7, #12]
 8020aa0:	4313      	orrs	r3, r2
 8020aa2:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 8020aa4:	4b22      	ldr	r3, [pc, #136]	; (8020b30 <HAL_GPIO_Init+0x2b8>)
 8020aa6:	693a      	ldr	r2, [r7, #16]
 8020aa8:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
 8020aaa:	4a21      	ldr	r2, [pc, #132]	; (8020b30 <HAL_GPIO_Init+0x2b8>)
 8020aac:	23c0      	movs	r3, #192	; 0xc0
 8020aae:	58d3      	ldr	r3, [r2, r3]
 8020ab0:	613b      	str	r3, [r7, #16]
#else
        temp = EXTI->IMR1;
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 8020ab2:	68fb      	ldr	r3, [r7, #12]
 8020ab4:	43da      	mvns	r2, r3
 8020ab6:	693b      	ldr	r3, [r7, #16]
 8020ab8:	4013      	ands	r3, r2
 8020aba:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 8020abc:	683b      	ldr	r3, [r7, #0]
 8020abe:	685a      	ldr	r2, [r3, #4]
 8020ac0:	2380      	movs	r3, #128	; 0x80
 8020ac2:	025b      	lsls	r3, r3, #9
 8020ac4:	4013      	ands	r3, r2
 8020ac6:	d003      	beq.n	8020ad0 <HAL_GPIO_Init+0x258>
        {
          temp |= iocurrent;
 8020ac8:	693a      	ldr	r2, [r7, #16]
 8020aca:	68fb      	ldr	r3, [r7, #12]
 8020acc:	4313      	orrs	r3, r2
 8020ace:	613b      	str	r3, [r7, #16]
        }
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 = temp;
 8020ad0:	4917      	ldr	r1, [pc, #92]	; (8020b30 <HAL_GPIO_Init+0x2b8>)
 8020ad2:	22c0      	movs	r2, #192	; 0xc0
 8020ad4:	693b      	ldr	r3, [r7, #16]
 8020ad6:	508b      	str	r3, [r1, r2]
#else
        EXTI->IMR1 = temp;
#endif /* CORE_CM0PLUS */

#ifdef CORE_CM0PLUS
        temp = EXTI->C2EMR1;
 8020ad8:	4a15      	ldr	r2, [pc, #84]	; (8020b30 <HAL_GPIO_Init+0x2b8>)
 8020ada:	23c4      	movs	r3, #196	; 0xc4
 8020adc:	58d3      	ldr	r3, [r2, r3]
 8020ade:	613b      	str	r3, [r7, #16]
#else
        temp = EXTI->EMR1;
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 8020ae0:	68fb      	ldr	r3, [r7, #12]
 8020ae2:	43da      	mvns	r2, r3
 8020ae4:	693b      	ldr	r3, [r7, #16]
 8020ae6:	4013      	ands	r3, r2
 8020ae8:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8020aea:	683b      	ldr	r3, [r7, #0]
 8020aec:	685a      	ldr	r2, [r3, #4]
 8020aee:	2380      	movs	r3, #128	; 0x80
 8020af0:	029b      	lsls	r3, r3, #10
 8020af2:	4013      	ands	r3, r2
 8020af4:	d003      	beq.n	8020afe <HAL_GPIO_Init+0x286>
        {
          temp |= iocurrent;
 8020af6:	693a      	ldr	r2, [r7, #16]
 8020af8:	68fb      	ldr	r3, [r7, #12]
 8020afa:	4313      	orrs	r3, r2
 8020afc:	613b      	str	r3, [r7, #16]
        }
#ifdef CORE_CM0PLUS
        EXTI->C2EMR1 = temp;
 8020afe:	490c      	ldr	r1, [pc, #48]	; (8020b30 <HAL_GPIO_Init+0x2b8>)
 8020b00:	22c4      	movs	r2, #196	; 0xc4
 8020b02:	693b      	ldr	r3, [r7, #16]
 8020b04:	508b      	str	r3, [r1, r2]
        EXTI->EMR1 = temp;
#endif /* CORE_CM0PLUS */
      }
    }

    position++;
 8020b06:	697b      	ldr	r3, [r7, #20]
 8020b08:	3301      	adds	r3, #1
 8020b0a:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8020b0c:	683b      	ldr	r3, [r7, #0]
 8020b0e:	681a      	ldr	r2, [r3, #0]
 8020b10:	697b      	ldr	r3, [r7, #20]
 8020b12:	40da      	lsrs	r2, r3
 8020b14:	1e13      	subs	r3, r2, #0
 8020b16:	d000      	beq.n	8020b1a <HAL_GPIO_Init+0x2a2>
 8020b18:	e6b6      	b.n	8020888 <HAL_GPIO_Init+0x10>
  }
}
 8020b1a:	46c0      	nop			; (mov r8, r8)
 8020b1c:	46c0      	nop			; (mov r8, r8)
 8020b1e:	46bd      	mov	sp, r7
 8020b20:	b006      	add	sp, #24
 8020b22:	bd80      	pop	{r7, pc}
 8020b24:	40010000 	.word	0x40010000
 8020b28:	48000400 	.word	0x48000400
 8020b2c:	48000800 	.word	0x48000800
 8020b30:	58000800 	.word	0x58000800

08020b34 <HAL_GPIO_DeInit>:
  * @param GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 8020b34:	b580      	push	{r7, lr}
 8020b36:	b086      	sub	sp, #24
 8020b38:	af00      	add	r7, sp, #0
 8020b3a:	6078      	str	r0, [r7, #4]
 8020b3c:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 8020b3e:	2300      	movs	r3, #0
 8020b40:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00u)
 8020b42:	e0ae      	b.n	8020ca2 <HAL_GPIO_DeInit+0x16e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1uL << position);
 8020b44:	2201      	movs	r2, #1
 8020b46:	697b      	ldr	r3, [r7, #20]
 8020b48:	409a      	lsls	r2, r3
 8020b4a:	683b      	ldr	r3, [r7, #0]
 8020b4c:	4013      	ands	r3, r2
 8020b4e:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00u)
 8020b50:	693b      	ldr	r3, [r7, #16]
 8020b52:	2b00      	cmp	r3, #0
 8020b54:	d100      	bne.n	8020b58 <HAL_GPIO_DeInit+0x24>
 8020b56:	e0a1      	b.n	8020c9c <HAL_GPIO_DeInit+0x168>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2u];
 8020b58:	4a57      	ldr	r2, [pc, #348]	; (8020cb8 <HAL_GPIO_DeInit+0x184>)
 8020b5a:	697b      	ldr	r3, [r7, #20]
 8020b5c:	089b      	lsrs	r3, r3, #2
 8020b5e:	3302      	adds	r3, #2
 8020b60:	009b      	lsls	r3, r3, #2
 8020b62:	589b      	ldr	r3, [r3, r2]
 8020b64:	60fb      	str	r3, [r7, #12]
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 8020b66:	697b      	ldr	r3, [r7, #20]
 8020b68:	2203      	movs	r2, #3
 8020b6a:	4013      	ands	r3, r2
 8020b6c:	009b      	lsls	r3, r3, #2
 8020b6e:	2207      	movs	r2, #7
 8020b70:	409a      	lsls	r2, r3
 8020b72:	68fb      	ldr	r3, [r7, #12]
 8020b74:	4013      	ands	r3, r2
 8020b76:	60fb      	str	r3, [r7, #12]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 8020b78:	687a      	ldr	r2, [r7, #4]
 8020b7a:	2390      	movs	r3, #144	; 0x90
 8020b7c:	05db      	lsls	r3, r3, #23
 8020b7e:	429a      	cmp	r2, r3
 8020b80:	d00d      	beq.n	8020b9e <HAL_GPIO_DeInit+0x6a>
 8020b82:	687b      	ldr	r3, [r7, #4]
 8020b84:	4a4d      	ldr	r2, [pc, #308]	; (8020cbc <HAL_GPIO_DeInit+0x188>)
 8020b86:	4293      	cmp	r3, r2
 8020b88:	d007      	beq.n	8020b9a <HAL_GPIO_DeInit+0x66>
 8020b8a:	687b      	ldr	r3, [r7, #4]
 8020b8c:	4a4c      	ldr	r2, [pc, #304]	; (8020cc0 <HAL_GPIO_DeInit+0x18c>)
 8020b8e:	4293      	cmp	r3, r2
 8020b90:	d101      	bne.n	8020b96 <HAL_GPIO_DeInit+0x62>
 8020b92:	2302      	movs	r3, #2
 8020b94:	e004      	b.n	8020ba0 <HAL_GPIO_DeInit+0x6c>
 8020b96:	2307      	movs	r3, #7
 8020b98:	e002      	b.n	8020ba0 <HAL_GPIO_DeInit+0x6c>
 8020b9a:	2301      	movs	r3, #1
 8020b9c:	e000      	b.n	8020ba0 <HAL_GPIO_DeInit+0x6c>
 8020b9e:	2300      	movs	r3, #0
 8020ba0:	697a      	ldr	r2, [r7, #20]
 8020ba2:	2103      	movs	r1, #3
 8020ba4:	400a      	ands	r2, r1
 8020ba6:	0092      	lsls	r2, r2, #2
 8020ba8:	4093      	lsls	r3, r2
 8020baa:	68fa      	ldr	r2, [r7, #12]
 8020bac:	429a      	cmp	r2, r3
 8020bae:	d136      	bne.n	8020c1e <HAL_GPIO_DeInit+0xea>
      {
        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 &= ~(iocurrent);
 8020bb0:	4a44      	ldr	r2, [pc, #272]	; (8020cc4 <HAL_GPIO_DeInit+0x190>)
 8020bb2:	23c0      	movs	r3, #192	; 0xc0
 8020bb4:	58d3      	ldr	r3, [r2, r3]
 8020bb6:	693a      	ldr	r2, [r7, #16]
 8020bb8:	43d2      	mvns	r2, r2
 8020bba:	4942      	ldr	r1, [pc, #264]	; (8020cc4 <HAL_GPIO_DeInit+0x190>)
 8020bbc:	4013      	ands	r3, r2
 8020bbe:	22c0      	movs	r2, #192	; 0xc0
 8020bc0:	508b      	str	r3, [r1, r2]
        EXTI->C2EMR1 &= ~(iocurrent);
 8020bc2:	4a40      	ldr	r2, [pc, #256]	; (8020cc4 <HAL_GPIO_DeInit+0x190>)
 8020bc4:	23c4      	movs	r3, #196	; 0xc4
 8020bc6:	58d3      	ldr	r3, [r2, r3]
 8020bc8:	693a      	ldr	r2, [r7, #16]
 8020bca:	43d2      	mvns	r2, r2
 8020bcc:	493d      	ldr	r1, [pc, #244]	; (8020cc4 <HAL_GPIO_DeInit+0x190>)
 8020bce:	4013      	ands	r3, r2
 8020bd0:	22c4      	movs	r2, #196	; 0xc4
 8020bd2:	508b      	str	r3, [r1, r2]
        EXTI->IMR1 &= ~(iocurrent);
        EXTI->EMR1 &= ~(iocurrent);
#endif /* CORE_CM0PLUS */

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~(iocurrent);
 8020bd4:	4b3b      	ldr	r3, [pc, #236]	; (8020cc4 <HAL_GPIO_DeInit+0x190>)
 8020bd6:	681a      	ldr	r2, [r3, #0]
 8020bd8:	693b      	ldr	r3, [r7, #16]
 8020bda:	43d9      	mvns	r1, r3
 8020bdc:	4b39      	ldr	r3, [pc, #228]	; (8020cc4 <HAL_GPIO_DeInit+0x190>)
 8020bde:	400a      	ands	r2, r1
 8020be0:	601a      	str	r2, [r3, #0]
        EXTI->FTSR1 &= ~(iocurrent);
 8020be2:	4b38      	ldr	r3, [pc, #224]	; (8020cc4 <HAL_GPIO_DeInit+0x190>)
 8020be4:	685a      	ldr	r2, [r3, #4]
 8020be6:	693b      	ldr	r3, [r7, #16]
 8020be8:	43d9      	mvns	r1, r3
 8020bea:	4b36      	ldr	r3, [pc, #216]	; (8020cc4 <HAL_GPIO_DeInit+0x190>)
 8020bec:	400a      	ands	r2, r1
 8020bee:	605a      	str	r2, [r3, #4]

        /* Clear EXTICR configuration */
        tmp = 0x07uL << (4u * (position & 0x03U));
 8020bf0:	697b      	ldr	r3, [r7, #20]
 8020bf2:	2203      	movs	r2, #3
 8020bf4:	4013      	ands	r3, r2
 8020bf6:	009b      	lsls	r3, r3, #2
 8020bf8:	2207      	movs	r2, #7
 8020bfa:	409a      	lsls	r2, r3
 8020bfc:	0013      	movs	r3, r2
 8020bfe:	60fb      	str	r3, [r7, #12]
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 8020c00:	4a2d      	ldr	r2, [pc, #180]	; (8020cb8 <HAL_GPIO_DeInit+0x184>)
 8020c02:	697b      	ldr	r3, [r7, #20]
 8020c04:	089b      	lsrs	r3, r3, #2
 8020c06:	3302      	adds	r3, #2
 8020c08:	009b      	lsls	r3, r3, #2
 8020c0a:	589a      	ldr	r2, [r3, r2]
 8020c0c:	68fb      	ldr	r3, [r7, #12]
 8020c0e:	43d9      	mvns	r1, r3
 8020c10:	4829      	ldr	r0, [pc, #164]	; (8020cb8 <HAL_GPIO_DeInit+0x184>)
 8020c12:	697b      	ldr	r3, [r7, #20]
 8020c14:	089b      	lsrs	r3, r3, #2
 8020c16:	400a      	ands	r2, r1
 8020c18:	3302      	adds	r3, #2
 8020c1a:	009b      	lsls	r3, r3, #2
 8020c1c:	501a      	str	r2, [r3, r0]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 8020c1e:	687b      	ldr	r3, [r7, #4]
 8020c20:	681a      	ldr	r2, [r3, #0]
 8020c22:	697b      	ldr	r3, [r7, #20]
 8020c24:	005b      	lsls	r3, r3, #1
 8020c26:	2103      	movs	r1, #3
 8020c28:	4099      	lsls	r1, r3
 8020c2a:	000b      	movs	r3, r1
 8020c2c:	431a      	orrs	r2, r3
 8020c2e:	687b      	ldr	r3, [r7, #4]
 8020c30:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8020c32:	697b      	ldr	r3, [r7, #20]
 8020c34:	08da      	lsrs	r2, r3, #3
 8020c36:	687b      	ldr	r3, [r7, #4]
 8020c38:	3208      	adds	r2, #8
 8020c3a:	0092      	lsls	r2, r2, #2
 8020c3c:	58d3      	ldr	r3, [r2, r3]
 8020c3e:	697a      	ldr	r2, [r7, #20]
 8020c40:	2107      	movs	r1, #7
 8020c42:	400a      	ands	r2, r1
 8020c44:	0092      	lsls	r2, r2, #2
 8020c46:	210f      	movs	r1, #15
 8020c48:	4091      	lsls	r1, r2
 8020c4a:	000a      	movs	r2, r1
 8020c4c:	43d1      	mvns	r1, r2
 8020c4e:	697a      	ldr	r2, [r7, #20]
 8020c50:	08d2      	lsrs	r2, r2, #3
 8020c52:	4019      	ands	r1, r3
 8020c54:	687b      	ldr	r3, [r7, #4]
 8020c56:	3208      	adds	r2, #8
 8020c58:	0092      	lsls	r2, r2, #2
 8020c5a:	50d1      	str	r1, [r2, r3]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8020c5c:	687b      	ldr	r3, [r7, #4]
 8020c5e:	689b      	ldr	r3, [r3, #8]
 8020c60:	697a      	ldr	r2, [r7, #20]
 8020c62:	0052      	lsls	r2, r2, #1
 8020c64:	2103      	movs	r1, #3
 8020c66:	4091      	lsls	r1, r2
 8020c68:	000a      	movs	r2, r1
 8020c6a:	43d2      	mvns	r2, r2
 8020c6c:	401a      	ands	r2, r3
 8020c6e:	687b      	ldr	r3, [r7, #4]
 8020c70:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 8020c72:	687b      	ldr	r3, [r7, #4]
 8020c74:	685b      	ldr	r3, [r3, #4]
 8020c76:	2101      	movs	r1, #1
 8020c78:	697a      	ldr	r2, [r7, #20]
 8020c7a:	4091      	lsls	r1, r2
 8020c7c:	000a      	movs	r2, r1
 8020c7e:	43d2      	mvns	r2, r2
 8020c80:	401a      	ands	r2, r3
 8020c82:	687b      	ldr	r3, [r7, #4]
 8020c84:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8020c86:	687b      	ldr	r3, [r7, #4]
 8020c88:	68db      	ldr	r3, [r3, #12]
 8020c8a:	697a      	ldr	r2, [r7, #20]
 8020c8c:	0052      	lsls	r2, r2, #1
 8020c8e:	2103      	movs	r1, #3
 8020c90:	4091      	lsls	r1, r2
 8020c92:	000a      	movs	r2, r1
 8020c94:	43d2      	mvns	r2, r2
 8020c96:	401a      	ands	r2, r3
 8020c98:	687b      	ldr	r3, [r7, #4]
 8020c9a:	60da      	str	r2, [r3, #12]
    }

    position++;
 8020c9c:	697b      	ldr	r3, [r7, #20]
 8020c9e:	3301      	adds	r3, #1
 8020ca0:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0x00u)
 8020ca2:	683a      	ldr	r2, [r7, #0]
 8020ca4:	697b      	ldr	r3, [r7, #20]
 8020ca6:	40da      	lsrs	r2, r3
 8020ca8:	1e13      	subs	r3, r2, #0
 8020caa:	d000      	beq.n	8020cae <HAL_GPIO_DeInit+0x17a>
 8020cac:	e74a      	b.n	8020b44 <HAL_GPIO_DeInit+0x10>
  }
}
 8020cae:	46c0      	nop			; (mov r8, r8)
 8020cb0:	46c0      	nop			; (mov r8, r8)
 8020cb2:	46bd      	mov	sp, r7
 8020cb4:	b006      	add	sp, #24
 8020cb6:	bd80      	pop	{r7, pc}
 8020cb8:	40010000 	.word	0x40010000
 8020cbc:	48000400 	.word	0x48000400
 8020cc0:	48000800 	.word	0x48000800
 8020cc4:	58000800 	.word	0x58000800

08020cc8 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8020cc8:	b580      	push	{r7, lr}
 8020cca:	b082      	sub	sp, #8
 8020ccc:	af00      	add	r7, sp, #0
 8020cce:	6078      	str	r0, [r7, #4]
 8020cd0:	0008      	movs	r0, r1
 8020cd2:	0011      	movs	r1, r2
 8020cd4:	1cbb      	adds	r3, r7, #2
 8020cd6:	1c02      	adds	r2, r0, #0
 8020cd8:	801a      	strh	r2, [r3, #0]
 8020cda:	1c7b      	adds	r3, r7, #1
 8020cdc:	1c0a      	adds	r2, r1, #0
 8020cde:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8020ce0:	1c7b      	adds	r3, r7, #1
 8020ce2:	781b      	ldrb	r3, [r3, #0]
 8020ce4:	2b00      	cmp	r3, #0
 8020ce6:	d004      	beq.n	8020cf2 <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8020ce8:	1cbb      	adds	r3, r7, #2
 8020cea:	881a      	ldrh	r2, [r3, #0]
 8020cec:	687b      	ldr	r3, [r7, #4]
 8020cee:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 8020cf0:	e003      	b.n	8020cfa <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8020cf2:	1cbb      	adds	r3, r7, #2
 8020cf4:	881a      	ldrh	r2, [r3, #0]
 8020cf6:	687b      	ldr	r3, [r7, #4]
 8020cf8:	629a      	str	r2, [r3, #40]	; 0x28
}
 8020cfa:	46c0      	nop			; (mov r8, r8)
 8020cfc:	46bd      	mov	sp, r7
 8020cfe:	b002      	add	sp, #8
 8020d00:	bd80      	pop	{r7, pc}
	...

08020d04 <HAL_PWR_EnableBkUpAccess>:
  * @note   LSEON bit that switches on and off the LSE crystal belongs as well to the
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
 8020d04:	b580      	push	{r7, lr}
 8020d06:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8020d08:	4b04      	ldr	r3, [pc, #16]	; (8020d1c <HAL_PWR_EnableBkUpAccess+0x18>)
 8020d0a:	681a      	ldr	r2, [r3, #0]
 8020d0c:	4b03      	ldr	r3, [pc, #12]	; (8020d1c <HAL_PWR_EnableBkUpAccess+0x18>)
 8020d0e:	2180      	movs	r1, #128	; 0x80
 8020d10:	0049      	lsls	r1, r1, #1
 8020d12:	430a      	orrs	r2, r1
 8020d14:	601a      	str	r2, [r3, #0]
}
 8020d16:	46c0      	nop			; (mov r8, r8)
 8020d18:	46bd      	mov	sp, r7
 8020d1a:	bd80      	pop	{r7, pc}
 8020d1c:	58000400 	.word	0x58000400

08020d20 <LL_RCC_HSE_IsEnabledDiv2>:
{
 8020d20:	b580      	push	{r7, lr}
 8020d22:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8020d24:	23b0      	movs	r3, #176	; 0xb0
 8020d26:	05db      	lsls	r3, r3, #23
 8020d28:	681a      	ldr	r2, [r3, #0]
 8020d2a:	2380      	movs	r3, #128	; 0x80
 8020d2c:	035b      	lsls	r3, r3, #13
 8020d2e:	401a      	ands	r2, r3
 8020d30:	2380      	movs	r3, #128	; 0x80
 8020d32:	035b      	lsls	r3, r3, #13
 8020d34:	429a      	cmp	r2, r3
 8020d36:	d101      	bne.n	8020d3c <LL_RCC_HSE_IsEnabledDiv2+0x1c>
 8020d38:	2301      	movs	r3, #1
 8020d3a:	e000      	b.n	8020d3e <LL_RCC_HSE_IsEnabledDiv2+0x1e>
 8020d3c:	2300      	movs	r3, #0
}
 8020d3e:	0018      	movs	r0, r3
 8020d40:	46bd      	mov	sp, r7
 8020d42:	bd80      	pop	{r7, pc}

08020d44 <LL_RCC_MSI_IsEnabledRangeSelect>:
{
 8020d44:	b580      	push	{r7, lr}
 8020d46:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8020d48:	23b0      	movs	r3, #176	; 0xb0
 8020d4a:	05db      	lsls	r3, r3, #23
 8020d4c:	681b      	ldr	r3, [r3, #0]
 8020d4e:	2208      	movs	r2, #8
 8020d50:	4013      	ands	r3, r2
 8020d52:	2b08      	cmp	r3, #8
 8020d54:	d101      	bne.n	8020d5a <LL_RCC_MSI_IsEnabledRangeSelect+0x16>
 8020d56:	2301      	movs	r3, #1
 8020d58:	e000      	b.n	8020d5c <LL_RCC_MSI_IsEnabledRangeSelect+0x18>
 8020d5a:	2300      	movs	r3, #0
}
 8020d5c:	0018      	movs	r0, r3
 8020d5e:	46bd      	mov	sp, r7
 8020d60:	bd80      	pop	{r7, pc}

08020d62 <LL_RCC_MSI_GetRange>:
{
 8020d62:	b580      	push	{r7, lr}
 8020d64:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8020d66:	23b0      	movs	r3, #176	; 0xb0
 8020d68:	05db      	lsls	r3, r3, #23
 8020d6a:	681b      	ldr	r3, [r3, #0]
 8020d6c:	22f0      	movs	r2, #240	; 0xf0
 8020d6e:	4013      	ands	r3, r2
}
 8020d70:	0018      	movs	r0, r3
 8020d72:	46bd      	mov	sp, r7
 8020d74:	bd80      	pop	{r7, pc}

08020d76 <LL_RCC_MSI_GetRangeAfterStandby>:
{
 8020d76:	b580      	push	{r7, lr}
 8020d78:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8020d7a:	23b0      	movs	r3, #176	; 0xb0
 8020d7c:	05db      	lsls	r3, r3, #23
 8020d7e:	2294      	movs	r2, #148	; 0x94
 8020d80:	589a      	ldr	r2, [r3, r2]
 8020d82:	23f0      	movs	r3, #240	; 0xf0
 8020d84:	011b      	lsls	r3, r3, #4
 8020d86:	4013      	ands	r3, r2
}
 8020d88:	0018      	movs	r0, r3
 8020d8a:	46bd      	mov	sp, r7
 8020d8c:	bd80      	pop	{r7, pc}

08020d8e <LL_RCC_GetSysClkSource>:
{
 8020d8e:	b580      	push	{r7, lr}
 8020d90:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8020d92:	23b0      	movs	r3, #176	; 0xb0
 8020d94:	05db      	lsls	r3, r3, #23
 8020d96:	689b      	ldr	r3, [r3, #8]
 8020d98:	220c      	movs	r2, #12
 8020d9a:	4013      	ands	r3, r2
}
 8020d9c:	0018      	movs	r0, r3
 8020d9e:	46bd      	mov	sp, r7
 8020da0:	bd80      	pop	{r7, pc}

08020da2 <LL_C2_RCC_GetAHBPrescaler>:
{
 8020da2:	b580      	push	{r7, lr}
 8020da4:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE));
 8020da6:	23b0      	movs	r3, #176	; 0xb0
 8020da8:	05da      	lsls	r2, r3, #23
 8020daa:	2384      	movs	r3, #132	; 0x84
 8020dac:	005b      	lsls	r3, r3, #1
 8020dae:	58d3      	ldr	r3, [r2, r3]
 8020db0:	22f0      	movs	r2, #240	; 0xf0
 8020db2:	4013      	ands	r3, r2
}
 8020db4:	0018      	movs	r0, r3
 8020db6:	46bd      	mov	sp, r7
 8020db8:	bd80      	pop	{r7, pc}

08020dba <LL_RCC_PLL_GetN>:
  * @brief  Get Main PLL multiplication factor for VCO
  * @rmtoll PLLCFGR      PLLN          LL_RCC_PLL_GetN
  * @retval Between 6 and 127
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetN(void)
{
 8020dba:	b580      	push	{r7, lr}
 8020dbc:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8020dbe:	23b0      	movs	r3, #176	; 0xb0
 8020dc0:	05db      	lsls	r3, r3, #23
 8020dc2:	68db      	ldr	r3, [r3, #12]
 8020dc4:	0a1b      	lsrs	r3, r3, #8
 8020dc6:	227f      	movs	r2, #127	; 0x7f
 8020dc8:	4013      	ands	r3, r2
}
 8020dca:	0018      	movs	r0, r3
 8020dcc:	46bd      	mov	sp, r7
 8020dce:	bd80      	pop	{r7, pc}

08020dd0 <LL_RCC_PLL_GetR>:
  *         @arg @ref LL_RCC_PLLR_DIV_6
  *         @arg @ref LL_RCC_PLLR_DIV_7
  *         @arg @ref LL_RCC_PLLR_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetR(void)
{
 8020dd0:	b580      	push	{r7, lr}
 8020dd2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 8020dd4:	23b0      	movs	r3, #176	; 0xb0
 8020dd6:	05db      	lsls	r3, r3, #23
 8020dd8:	68db      	ldr	r3, [r3, #12]
 8020dda:	0f5b      	lsrs	r3, r3, #29
 8020ddc:	075b      	lsls	r3, r3, #29
}
 8020dde:	0018      	movs	r0, r3
 8020de0:	46bd      	mov	sp, r7
 8020de2:	bd80      	pop	{r7, pc}

08020de4 <LL_RCC_PLL_GetDivider>:
  *         @arg @ref LL_RCC_PLLM_DIV_6
  *         @arg @ref LL_RCC_PLLM_DIV_7
  *         @arg @ref LL_RCC_PLLM_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetDivider(void)
{
 8020de4:	b580      	push	{r7, lr}
 8020de6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8020de8:	23b0      	movs	r3, #176	; 0xb0
 8020dea:	05db      	lsls	r3, r3, #23
 8020dec:	68db      	ldr	r3, [r3, #12]
 8020dee:	2270      	movs	r2, #112	; 0x70
 8020df0:	4013      	ands	r3, r2
}
 8020df2:	0018      	movs	r0, r3
 8020df4:	46bd      	mov	sp, r7
 8020df6:	bd80      	pop	{r7, pc}

08020df8 <LL_RCC_PLL_GetMainSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
 8020df8:	b580      	push	{r7, lr}
 8020dfa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8020dfc:	23b0      	movs	r3, #176	; 0xb0
 8020dfe:	05db      	lsls	r3, r3, #23
 8020e00:	68db      	ldr	r3, [r3, #12]
 8020e02:	2203      	movs	r2, #3
 8020e04:	4013      	ands	r3, r2
}
 8020e06:	0018      	movs	r0, r3
 8020e08:	46bd      	mov	sp, r7
 8020e0a:	bd80      	pop	{r7, pc}

08020e0c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8020e0c:	b590      	push	{r4, r7, lr}
 8020e0e:	b087      	sub	sp, #28
 8020e10:	af00      	add	r7, sp, #0
  uint32_t sysclk_source;
  uint32_t pllsource;
  uint32_t sysclockfreq = 0U;
 8020e12:	2300      	movs	r3, #0
 8020e14:	617b      	str	r3, [r7, #20]
  uint32_t msifreq = 0U;
 8020e16:	2300      	movs	r3, #0
 8020e18:	613b      	str	r3, [r7, #16]
  uint32_t pllinputfreq;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8020e1a:	f7ff ffb8 	bl	8020d8e <LL_RCC_GetSysClkSource>
 8020e1e:	0003      	movs	r3, r0
 8020e20:	60bb      	str	r3, [r7, #8]
  pllsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8020e22:	f7ff ffe9 	bl	8020df8 <LL_RCC_PLL_GetMainSource>
 8020e26:	0003      	movs	r3, r0
 8020e28:	607b      	str	r3, [r7, #4]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 8020e2a:	68bb      	ldr	r3, [r7, #8]
 8020e2c:	2b00      	cmp	r3, #0
 8020e2e:	d005      	beq.n	8020e3c <HAL_RCC_GetSysClockFreq+0x30>
 8020e30:	68bb      	ldr	r3, [r7, #8]
 8020e32:	2b0c      	cmp	r3, #12
 8020e34:	d138      	bne.n	8020ea8 <HAL_RCC_GetSysClockFreq+0x9c>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 8020e36:	687b      	ldr	r3, [r7, #4]
 8020e38:	2b01      	cmp	r3, #1
 8020e3a:	d135      	bne.n	8020ea8 <HAL_RCC_GetSysClockFreq+0x9c>
  {
    /* MSI or PLL with MSI source used as system clock source */
    /* Retrieve MSI frequency range in Hz */
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8020e3c:	f7ff ff82 	bl	8020d44 <LL_RCC_MSI_IsEnabledRangeSelect>
 8020e40:	1e03      	subs	r3, r0, #0
 8020e42:	d115      	bne.n	8020e70 <HAL_RCC_GetSysClockFreq+0x64>
 8020e44:	f7ff ff7e 	bl	8020d44 <LL_RCC_MSI_IsEnabledRangeSelect>
 8020e48:	0003      	movs	r3, r0
 8020e4a:	2b01      	cmp	r3, #1
 8020e4c:	d106      	bne.n	8020e5c <HAL_RCC_GetSysClockFreq+0x50>
 8020e4e:	f7ff ff88 	bl	8020d62 <LL_RCC_MSI_GetRange>
 8020e52:	0003      	movs	r3, r0
 8020e54:	0a1b      	lsrs	r3, r3, #8
 8020e56:	220f      	movs	r2, #15
 8020e58:	4013      	ands	r3, r2
 8020e5a:	e005      	b.n	8020e68 <HAL_RCC_GetSysClockFreq+0x5c>
 8020e5c:	f7ff ff8b 	bl	8020d76 <LL_RCC_MSI_GetRangeAfterStandby>
 8020e60:	0003      	movs	r3, r0
 8020e62:	0a1b      	lsrs	r3, r3, #8
 8020e64:	220f      	movs	r2, #15
 8020e66:	4013      	ands	r3, r2
 8020e68:	4a3a      	ldr	r2, [pc, #232]	; (8020f54 <HAL_RCC_GetSysClockFreq+0x148>)
 8020e6a:	009b      	lsls	r3, r3, #2
 8020e6c:	589b      	ldr	r3, [r3, r2]
 8020e6e:	e014      	b.n	8020e9a <HAL_RCC_GetSysClockFreq+0x8e>
 8020e70:	f7ff ff68 	bl	8020d44 <LL_RCC_MSI_IsEnabledRangeSelect>
 8020e74:	0003      	movs	r3, r0
 8020e76:	2b01      	cmp	r3, #1
 8020e78:	d106      	bne.n	8020e88 <HAL_RCC_GetSysClockFreq+0x7c>
 8020e7a:	f7ff ff72 	bl	8020d62 <LL_RCC_MSI_GetRange>
 8020e7e:	0003      	movs	r3, r0
 8020e80:	091b      	lsrs	r3, r3, #4
 8020e82:	220f      	movs	r2, #15
 8020e84:	4013      	ands	r3, r2
 8020e86:	e005      	b.n	8020e94 <HAL_RCC_GetSysClockFreq+0x88>
 8020e88:	f7ff ff75 	bl	8020d76 <LL_RCC_MSI_GetRangeAfterStandby>
 8020e8c:	0003      	movs	r3, r0
 8020e8e:	091b      	lsrs	r3, r3, #4
 8020e90:	220f      	movs	r2, #15
 8020e92:	4013      	ands	r3, r2
 8020e94:	4a2f      	ldr	r2, [pc, #188]	; (8020f54 <HAL_RCC_GetSysClockFreq+0x148>)
 8020e96:	009b      	lsls	r3, r3, #2
 8020e98:	589b      	ldr	r3, [r3, r2]
 8020e9a:	613b      	str	r3, [r7, #16]
                                     ((LL_RCC_MSI_IsEnabledRangeSelect() == 1U) ?
                                      LL_RCC_MSI_GetRange() :
                                      LL_RCC_MSI_GetRangeAfterStandby()));

    /* Get SYSCLK source */
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8020e9c:	68bb      	ldr	r3, [r7, #8]
 8020e9e:	2b00      	cmp	r3, #0
 8020ea0:	d115      	bne.n	8020ece <HAL_RCC_GetSysClockFreq+0xc2>
    {
      /* MSI used as system clock source */
      sysclockfreq = msifreq;
 8020ea2:	693b      	ldr	r3, [r7, #16]
 8020ea4:	617b      	str	r3, [r7, #20]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8020ea6:	e012      	b.n	8020ece <HAL_RCC_GetSysClockFreq+0xc2>
    }
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 8020ea8:	68bb      	ldr	r3, [r7, #8]
 8020eaa:	2b04      	cmp	r3, #4
 8020eac:	d102      	bne.n	8020eb4 <HAL_RCC_GetSysClockFreq+0xa8>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8020eae:	4b2a      	ldr	r3, [pc, #168]	; (8020f58 <HAL_RCC_GetSysClockFreq+0x14c>)
 8020eb0:	617b      	str	r3, [r7, #20]
 8020eb2:	e00c      	b.n	8020ece <HAL_RCC_GetSysClockFreq+0xc2>
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 8020eb4:	68bb      	ldr	r3, [r7, #8]
 8020eb6:	2b08      	cmp	r3, #8
 8020eb8:	d109      	bne.n	8020ece <HAL_RCC_GetSysClockFreq+0xc2>
  {
    /* HSE used as system clock source */
    if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 8020eba:	f7ff ff31 	bl	8020d20 <LL_RCC_HSE_IsEnabledDiv2>
 8020ebe:	0003      	movs	r3, r0
 8020ec0:	2b01      	cmp	r3, #1
 8020ec2:	d102      	bne.n	8020eca <HAL_RCC_GetSysClockFreq+0xbe>
    {
      sysclockfreq = HSE_VALUE / 2U;
 8020ec4:	4b24      	ldr	r3, [pc, #144]	; (8020f58 <HAL_RCC_GetSysClockFreq+0x14c>)
 8020ec6:	617b      	str	r3, [r7, #20]
 8020ec8:	e001      	b.n	8020ece <HAL_RCC_GetSysClockFreq+0xc2>
    }
    else
    {
      sysclockfreq = HSE_VALUE;
 8020eca:	4b24      	ldr	r3, [pc, #144]	; (8020f5c <HAL_RCC_GetSysClockFreq+0x150>)
 8020ecc:	617b      	str	r3, [r7, #20]
  else
  {
    /* Nothing to do */
  }

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8020ece:	f7ff ff5e 	bl	8020d8e <LL_RCC_GetSysClkSource>
 8020ed2:	0003      	movs	r3, r0
 8020ed4:	2b0c      	cmp	r3, #12
 8020ed6:	d137      	bne.n	8020f48 <HAL_RCC_GetSysClockFreq+0x13c>
  {
    /* PLL used as system clock  source */
    pllsource = LL_RCC_PLL_GetMainSource();
 8020ed8:	f7ff ff8e 	bl	8020df8 <LL_RCC_PLL_GetMainSource>
 8020edc:	0003      	movs	r3, r0
 8020ede:	607b      	str	r3, [r7, #4]

    switch (pllsource)
 8020ee0:	687b      	ldr	r3, [r7, #4]
 8020ee2:	2b02      	cmp	r3, #2
 8020ee4:	d003      	beq.n	8020eee <HAL_RCC_GetSysClockFreq+0xe2>
 8020ee6:	687b      	ldr	r3, [r7, #4]
 8020ee8:	2b03      	cmp	r3, #3
 8020eea:	d003      	beq.n	8020ef4 <HAL_RCC_GetSysClockFreq+0xe8>
 8020eec:	e00d      	b.n	8020f0a <HAL_RCC_GetSysClockFreq+0xfe>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllinputfreq = HSI_VALUE;
 8020eee:	4b1a      	ldr	r3, [pc, #104]	; (8020f58 <HAL_RCC_GetSysClockFreq+0x14c>)
 8020ef0:	60fb      	str	r3, [r7, #12]
        break;
 8020ef2:	e00d      	b.n	8020f10 <HAL_RCC_GetSysClockFreq+0x104>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 8020ef4:	f7ff ff14 	bl	8020d20 <LL_RCC_HSE_IsEnabledDiv2>
 8020ef8:	0003      	movs	r3, r0
 8020efa:	2b01      	cmp	r3, #1
 8020efc:	d102      	bne.n	8020f04 <HAL_RCC_GetSysClockFreq+0xf8>
        {
          pllinputfreq = HSE_VALUE / 2U;
 8020efe:	4b16      	ldr	r3, [pc, #88]	; (8020f58 <HAL_RCC_GetSysClockFreq+0x14c>)
 8020f00:	60fb      	str	r3, [r7, #12]
        }
        else
        {
          pllinputfreq = HSE_VALUE;
        }
        break;
 8020f02:	e005      	b.n	8020f10 <HAL_RCC_GetSysClockFreq+0x104>
          pllinputfreq = HSE_VALUE;
 8020f04:	4b15      	ldr	r3, [pc, #84]	; (8020f5c <HAL_RCC_GetSysClockFreq+0x150>)
 8020f06:	60fb      	str	r3, [r7, #12]
        break;
 8020f08:	e002      	b.n	8020f10 <HAL_RCC_GetSysClockFreq+0x104>
      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllinputfreq = msifreq;
 8020f0a:	693b      	ldr	r3, [r7, #16]
 8020f0c:	60fb      	str	r3, [r7, #12]
        break;
 8020f0e:	46c0      	nop			; (mov r8, r8)
    }
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8020f10:	f7ff ff53 	bl	8020dba <LL_RCC_PLL_GetN>
 8020f14:	0002      	movs	r2, r0
 8020f16:	68fb      	ldr	r3, [r7, #12]
 8020f18:	4353      	muls	r3, r2
 8020f1a:	001c      	movs	r4, r3
 8020f1c:	f7ff ff62 	bl	8020de4 <LL_RCC_PLL_GetDivider>
 8020f20:	0003      	movs	r3, r0
 8020f22:	091b      	lsrs	r3, r3, #4
 8020f24:	3301      	adds	r3, #1
 8020f26:	0019      	movs	r1, r3
 8020f28:	0020      	movs	r0, r4
 8020f2a:	f7ff f8ed 	bl	8020108 <__udivsi3>
 8020f2e:	0003      	movs	r3, r0
 8020f30:	001c      	movs	r4, r3
 8020f32:	f7ff ff4d 	bl	8020dd0 <LL_RCC_PLL_GetR>
 8020f36:	0003      	movs	r3, r0
 8020f38:	0f5b      	lsrs	r3, r3, #29
 8020f3a:	3301      	adds	r3, #1
 8020f3c:	0019      	movs	r1, r3
 8020f3e:	0020      	movs	r0, r4
 8020f40:	f7ff f8e2 	bl	8020108 <__udivsi3>
 8020f44:	0003      	movs	r3, r0
 8020f46:	617b      	str	r3, [r7, #20]
                                             LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
  }

  return sysclockfreq;
 8020f48:	697b      	ldr	r3, [r7, #20]
}
 8020f4a:	0018      	movs	r0, r3
 8020f4c:	46bd      	mov	sp, r7
 8020f4e:	b007      	add	sp, #28
 8020f50:	bd90      	pop	{r4, r7, pc}
 8020f52:	46c0      	nop			; (mov r8, r8)
 8020f54:	08022da8 	.word	0x08022da8
 8020f58:	00f42400 	.word	0x00f42400
 8020f5c:	01e84800 	.word	0x01e84800

08020f60 <HAL_RCC_GetHCLK2Freq>:
/**
  * @brief  Return the HCLK2 frequency.
  * @retval HCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetHCLK2Freq(void)
{
 8020f60:	b5b0      	push	{r4, r5, r7, lr}
 8020f62:	af00      	add	r7, sp, #0
  /* Get SysClock and Compute HCLK2 frequency --------------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_HCLK2_FREQ(HAL_RCC_GetSysClockFreq(), LL_C2_RCC_GetAHBPrescaler())));
 8020f64:	f7ff ff52 	bl	8020e0c <HAL_RCC_GetSysClockFreq>
 8020f68:	0004      	movs	r4, r0
 8020f6a:	f7ff ff1a 	bl	8020da2 <LL_C2_RCC_GetAHBPrescaler>
 8020f6e:	0003      	movs	r3, r0
 8020f70:	091b      	lsrs	r3, r3, #4
 8020f72:	220f      	movs	r2, #15
 8020f74:	401a      	ands	r2, r3
 8020f76:	4b05      	ldr	r3, [pc, #20]	; (8020f8c <HAL_RCC_GetHCLK2Freq+0x2c>)
 8020f78:	0092      	lsls	r2, r2, #2
 8020f7a:	58d3      	ldr	r3, [r2, r3]
 8020f7c:	0019      	movs	r1, r3
 8020f7e:	0020      	movs	r0, r4
 8020f80:	f7ff f8c2 	bl	8020108 <__udivsi3>
 8020f84:	0003      	movs	r3, r0
}
 8020f86:	0018      	movs	r0, r3
 8020f88:	46bd      	mov	sp, r7
 8020f8a:	bdb0      	pop	{r4, r5, r7, pc}
 8020f8c:	08022d68 	.word	0x08022d68

08020f90 <LL_RCC_LSE_IsReady>:
{
 8020f90:	b580      	push	{r7, lr}
 8020f92:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8020f94:	23b0      	movs	r3, #176	; 0xb0
 8020f96:	05db      	lsls	r3, r3, #23
 8020f98:	2290      	movs	r2, #144	; 0x90
 8020f9a:	589b      	ldr	r3, [r3, r2]
 8020f9c:	2202      	movs	r2, #2
 8020f9e:	4013      	ands	r3, r2
 8020fa0:	2b02      	cmp	r3, #2
 8020fa2:	d101      	bne.n	8020fa8 <LL_RCC_LSE_IsReady+0x18>
 8020fa4:	2301      	movs	r3, #1
 8020fa6:	e000      	b.n	8020faa <LL_RCC_LSE_IsReady+0x1a>
 8020fa8:	2300      	movs	r3, #0
}
 8020faa:	0018      	movs	r0, r3
 8020fac:	46bd      	mov	sp, r7
 8020fae:	bd80      	pop	{r7, pc}

08020fb0 <LL_RCC_SetUSARTClockSource>:
{
 8020fb0:	b580      	push	{r7, lr}
 8020fb2:	b082      	sub	sp, #8
 8020fb4:	af00      	add	r7, sp, #0
 8020fb6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 8020fb8:	23b0      	movs	r3, #176	; 0xb0
 8020fba:	05db      	lsls	r3, r3, #23
 8020fbc:	2288      	movs	r2, #136	; 0x88
 8020fbe:	589b      	ldr	r3, [r3, r2]
 8020fc0:	687a      	ldr	r2, [r7, #4]
 8020fc2:	0c12      	lsrs	r2, r2, #16
 8020fc4:	43d2      	mvns	r2, r2
 8020fc6:	401a      	ands	r2, r3
 8020fc8:	0011      	movs	r1, r2
 8020fca:	687b      	ldr	r3, [r7, #4]
 8020fcc:	041b      	lsls	r3, r3, #16
 8020fce:	0c1a      	lsrs	r2, r3, #16
 8020fd0:	23b0      	movs	r3, #176	; 0xb0
 8020fd2:	05db      	lsls	r3, r3, #23
 8020fd4:	430a      	orrs	r2, r1
 8020fd6:	2188      	movs	r1, #136	; 0x88
 8020fd8:	505a      	str	r2, [r3, r1]
}
 8020fda:	46c0      	nop			; (mov r8, r8)
 8020fdc:	46bd      	mov	sp, r7
 8020fde:	b002      	add	sp, #8
 8020fe0:	bd80      	pop	{r7, pc}
	...

08020fe4 <LL_RCC_SetI2SClockSource>:
{
 8020fe4:	b580      	push	{r7, lr}
 8020fe6:	b082      	sub	sp, #8
 8020fe8:	af00      	add	r7, sp, #0
 8020fea:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 8020fec:	23b0      	movs	r3, #176	; 0xb0
 8020fee:	05db      	lsls	r3, r3, #23
 8020ff0:	2288      	movs	r2, #136	; 0x88
 8020ff2:	589b      	ldr	r3, [r3, r2]
 8020ff4:	4a06      	ldr	r2, [pc, #24]	; (8021010 <LL_RCC_SetI2SClockSource+0x2c>)
 8020ff6:	4013      	ands	r3, r2
 8020ff8:	0019      	movs	r1, r3
 8020ffa:	23b0      	movs	r3, #176	; 0xb0
 8020ffc:	05db      	lsls	r3, r3, #23
 8020ffe:	687a      	ldr	r2, [r7, #4]
 8021000:	430a      	orrs	r2, r1
 8021002:	2188      	movs	r1, #136	; 0x88
 8021004:	505a      	str	r2, [r3, r1]
}
 8021006:	46c0      	nop			; (mov r8, r8)
 8021008:	46bd      	mov	sp, r7
 802100a:	b002      	add	sp, #8
 802100c:	bd80      	pop	{r7, pc}
 802100e:	46c0      	nop			; (mov r8, r8)
 8021010:	fffffcff 	.word	0xfffffcff

08021014 <LL_RCC_SetLPUARTClockSource>:
{
 8021014:	b580      	push	{r7, lr}
 8021016:	b082      	sub	sp, #8
 8021018:	af00      	add	r7, sp, #0
 802101a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 802101c:	23b0      	movs	r3, #176	; 0xb0
 802101e:	05db      	lsls	r3, r3, #23
 8021020:	2288      	movs	r2, #136	; 0x88
 8021022:	589b      	ldr	r3, [r3, r2]
 8021024:	4a06      	ldr	r2, [pc, #24]	; (8021040 <LL_RCC_SetLPUARTClockSource+0x2c>)
 8021026:	4013      	ands	r3, r2
 8021028:	0019      	movs	r1, r3
 802102a:	23b0      	movs	r3, #176	; 0xb0
 802102c:	05db      	lsls	r3, r3, #23
 802102e:	687a      	ldr	r2, [r7, #4]
 8021030:	430a      	orrs	r2, r1
 8021032:	2188      	movs	r1, #136	; 0x88
 8021034:	505a      	str	r2, [r3, r1]
}
 8021036:	46c0      	nop			; (mov r8, r8)
 8021038:	46bd      	mov	sp, r7
 802103a:	b002      	add	sp, #8
 802103c:	bd80      	pop	{r7, pc}
 802103e:	46c0      	nop			; (mov r8, r8)
 8021040:	fffff3ff 	.word	0xfffff3ff

08021044 <LL_RCC_SetI2CClockSource>:
{
 8021044:	b580      	push	{r7, lr}
 8021046:	b082      	sub	sp, #8
 8021048:	af00      	add	r7, sp, #0
 802104a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 802104c:	23b0      	movs	r3, #176	; 0xb0
 802104e:	05db      	lsls	r3, r3, #23
 8021050:	2288      	movs	r2, #136	; 0x88
 8021052:	589b      	ldr	r3, [r3, r2]
 8021054:	687a      	ldr	r2, [r7, #4]
 8021056:	0911      	lsrs	r1, r2, #4
 8021058:	22ff      	movs	r2, #255	; 0xff
 802105a:	0312      	lsls	r2, r2, #12
 802105c:	400a      	ands	r2, r1
 802105e:	43d2      	mvns	r2, r2
 8021060:	401a      	ands	r2, r3
 8021062:	0011      	movs	r1, r2
 8021064:	687b      	ldr	r3, [r7, #4]
 8021066:	011a      	lsls	r2, r3, #4
 8021068:	23ff      	movs	r3, #255	; 0xff
 802106a:	031b      	lsls	r3, r3, #12
 802106c:	401a      	ands	r2, r3
 802106e:	23b0      	movs	r3, #176	; 0xb0
 8021070:	05db      	lsls	r3, r3, #23
 8021072:	430a      	orrs	r2, r1
 8021074:	2188      	movs	r1, #136	; 0x88
 8021076:	505a      	str	r2, [r3, r1]
}
 8021078:	46c0      	nop			; (mov r8, r8)
 802107a:	46bd      	mov	sp, r7
 802107c:	b002      	add	sp, #8
 802107e:	bd80      	pop	{r7, pc}

08021080 <LL_RCC_SetLPTIMClockSource>:
{
 8021080:	b580      	push	{r7, lr}
 8021082:	b082      	sub	sp, #8
 8021084:	af00      	add	r7, sp, #0
 8021086:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 8021088:	23b0      	movs	r3, #176	; 0xb0
 802108a:	05db      	lsls	r3, r3, #23
 802108c:	2288      	movs	r2, #136	; 0x88
 802108e:	589b      	ldr	r3, [r3, r2]
 8021090:	687a      	ldr	r2, [r7, #4]
 8021092:	0c12      	lsrs	r2, r2, #16
 8021094:	0412      	lsls	r2, r2, #16
 8021096:	43d2      	mvns	r2, r2
 8021098:	401a      	ands	r2, r3
 802109a:	0011      	movs	r1, r2
 802109c:	687b      	ldr	r3, [r7, #4]
 802109e:	041a      	lsls	r2, r3, #16
 80210a0:	23b0      	movs	r3, #176	; 0xb0
 80210a2:	05db      	lsls	r3, r3, #23
 80210a4:	430a      	orrs	r2, r1
 80210a6:	2188      	movs	r1, #136	; 0x88
 80210a8:	505a      	str	r2, [r3, r1]
}
 80210aa:	46c0      	nop			; (mov r8, r8)
 80210ac:	46bd      	mov	sp, r7
 80210ae:	b002      	add	sp, #8
 80210b0:	bd80      	pop	{r7, pc}

080210b2 <LL_RCC_SetRNGClockSource>:
{
 80210b2:	b580      	push	{r7, lr}
 80210b4:	b082      	sub	sp, #8
 80210b6:	af00      	add	r7, sp, #0
 80210b8:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 80210ba:	23b0      	movs	r3, #176	; 0xb0
 80210bc:	05db      	lsls	r3, r3, #23
 80210be:	2288      	movs	r2, #136	; 0x88
 80210c0:	589b      	ldr	r3, [r3, r2]
 80210c2:	009b      	lsls	r3, r3, #2
 80210c4:	0899      	lsrs	r1, r3, #2
 80210c6:	23b0      	movs	r3, #176	; 0xb0
 80210c8:	05db      	lsls	r3, r3, #23
 80210ca:	687a      	ldr	r2, [r7, #4]
 80210cc:	430a      	orrs	r2, r1
 80210ce:	2188      	movs	r1, #136	; 0x88
 80210d0:	505a      	str	r2, [r3, r1]
}
 80210d2:	46c0      	nop			; (mov r8, r8)
 80210d4:	46bd      	mov	sp, r7
 80210d6:	b002      	add	sp, #8
 80210d8:	bd80      	pop	{r7, pc}
	...

080210dc <LL_RCC_SetADCClockSource>:
{
 80210dc:	b580      	push	{r7, lr}
 80210de:	b082      	sub	sp, #8
 80210e0:	af00      	add	r7, sp, #0
 80210e2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 80210e4:	23b0      	movs	r3, #176	; 0xb0
 80210e6:	05db      	lsls	r3, r3, #23
 80210e8:	2288      	movs	r2, #136	; 0x88
 80210ea:	589b      	ldr	r3, [r3, r2]
 80210ec:	4a06      	ldr	r2, [pc, #24]	; (8021108 <LL_RCC_SetADCClockSource+0x2c>)
 80210ee:	4013      	ands	r3, r2
 80210f0:	0019      	movs	r1, r3
 80210f2:	23b0      	movs	r3, #176	; 0xb0
 80210f4:	05db      	lsls	r3, r3, #23
 80210f6:	687a      	ldr	r2, [r7, #4]
 80210f8:	430a      	orrs	r2, r1
 80210fa:	2188      	movs	r1, #136	; 0x88
 80210fc:	505a      	str	r2, [r3, r1]
}
 80210fe:	46c0      	nop			; (mov r8, r8)
 8021100:	46bd      	mov	sp, r7
 8021102:	b002      	add	sp, #8
 8021104:	bd80      	pop	{r7, pc}
 8021106:	46c0      	nop			; (mov r8, r8)
 8021108:	cfffffff 	.word	0xcfffffff

0802110c <LL_RCC_SetRTCClockSource>:
{
 802110c:	b580      	push	{r7, lr}
 802110e:	b082      	sub	sp, #8
 8021110:	af00      	add	r7, sp, #0
 8021112:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 8021114:	23b0      	movs	r3, #176	; 0xb0
 8021116:	05db      	lsls	r3, r3, #23
 8021118:	2290      	movs	r2, #144	; 0x90
 802111a:	589b      	ldr	r3, [r3, r2]
 802111c:	4a06      	ldr	r2, [pc, #24]	; (8021138 <LL_RCC_SetRTCClockSource+0x2c>)
 802111e:	4013      	ands	r3, r2
 8021120:	0019      	movs	r1, r3
 8021122:	23b0      	movs	r3, #176	; 0xb0
 8021124:	05db      	lsls	r3, r3, #23
 8021126:	687a      	ldr	r2, [r7, #4]
 8021128:	430a      	orrs	r2, r1
 802112a:	2190      	movs	r1, #144	; 0x90
 802112c:	505a      	str	r2, [r3, r1]
}
 802112e:	46c0      	nop			; (mov r8, r8)
 8021130:	46bd      	mov	sp, r7
 8021132:	b002      	add	sp, #8
 8021134:	bd80      	pop	{r7, pc}
 8021136:	46c0      	nop			; (mov r8, r8)
 8021138:	fffffcff 	.word	0xfffffcff

0802113c <LL_RCC_GetRTCClockSource>:
{
 802113c:	b580      	push	{r7, lr}
 802113e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 8021140:	23b0      	movs	r3, #176	; 0xb0
 8021142:	05db      	lsls	r3, r3, #23
 8021144:	2290      	movs	r2, #144	; 0x90
 8021146:	589a      	ldr	r2, [r3, r2]
 8021148:	23c0      	movs	r3, #192	; 0xc0
 802114a:	009b      	lsls	r3, r3, #2
 802114c:	4013      	ands	r3, r2
}
 802114e:	0018      	movs	r0, r3
 8021150:	46bd      	mov	sp, r7
 8021152:	bd80      	pop	{r7, pc}

08021154 <LL_RCC_ForceBackupDomainReset>:
{
 8021154:	b580      	push	{r7, lr}
 8021156:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8021158:	23b0      	movs	r3, #176	; 0xb0
 802115a:	05db      	lsls	r3, r3, #23
 802115c:	2290      	movs	r2, #144	; 0x90
 802115e:	589a      	ldr	r2, [r3, r2]
 8021160:	23b0      	movs	r3, #176	; 0xb0
 8021162:	05db      	lsls	r3, r3, #23
 8021164:	2180      	movs	r1, #128	; 0x80
 8021166:	0249      	lsls	r1, r1, #9
 8021168:	430a      	orrs	r2, r1
 802116a:	2190      	movs	r1, #144	; 0x90
 802116c:	505a      	str	r2, [r3, r1]
}
 802116e:	46c0      	nop			; (mov r8, r8)
 8021170:	46bd      	mov	sp, r7
 8021172:	bd80      	pop	{r7, pc}

08021174 <LL_RCC_ReleaseBackupDomainReset>:
{
 8021174:	b580      	push	{r7, lr}
 8021176:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8021178:	23b0      	movs	r3, #176	; 0xb0
 802117a:	05db      	lsls	r3, r3, #23
 802117c:	2290      	movs	r2, #144	; 0x90
 802117e:	589a      	ldr	r2, [r3, r2]
 8021180:	23b0      	movs	r3, #176	; 0xb0
 8021182:	05db      	lsls	r3, r3, #23
 8021184:	4903      	ldr	r1, [pc, #12]	; (8021194 <LL_RCC_ReleaseBackupDomainReset+0x20>)
 8021186:	400a      	ands	r2, r1
 8021188:	2190      	movs	r1, #144	; 0x90
 802118a:	505a      	str	r2, [r3, r1]
}
 802118c:	46c0      	nop			; (mov r8, r8)
 802118e:	46bd      	mov	sp, r7
 8021190:	bd80      	pop	{r7, pc}
 8021192:	46c0      	nop			; (mov r8, r8)
 8021194:	fffeffff 	.word	0xfffeffff

08021198 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8021198:	b580      	push	{r7, lr}
 802119a:	b086      	sub	sp, #24
 802119c:	af00      	add	r7, sp, #0
 802119e:	6078      	str	r0, [r7, #4]
  uint32_t tmpregister = 0;
 80211a0:	2300      	movs	r3, #0
 80211a2:	617b      	str	r3, [r7, #20]
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;   /* Intermediate status */
 80211a4:	2313      	movs	r3, #19
 80211a6:	18fb      	adds	r3, r7, r3
 80211a8:	2200      	movs	r2, #0
 80211aa:	701a      	strb	r2, [r3, #0]
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 80211ac:	2312      	movs	r3, #18
 80211ae:	18fb      	adds	r3, r7, r3
 80211b0:	2200      	movs	r2, #0
 80211b2:	701a      	strb	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80211b4:	687b      	ldr	r3, [r7, #4]
 80211b6:	681a      	ldr	r2, [r3, #0]
 80211b8:	2380      	movs	r3, #128	; 0x80
 80211ba:	025b      	lsls	r3, r3, #9
 80211bc:	4013      	ands	r3, r2
 80211be:	d100      	bne.n	80211c2 <HAL_RCCEx_PeriphCLKConfig+0x2a>
 80211c0:	e06a      	b.n	8021298 <HAL_RCCEx_PeriphCLKConfig+0x100>
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));


    /* Enable write access to Backup domain */
    HAL_PWR_EnableBkUpAccess();
 80211c2:	f7ff fd9f 	bl	8020d04 <HAL_PWR_EnableBkUpAccess>

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 80211c6:	f7ff fa6f 	bl	80206a8 <HAL_GetTick>
 80211ca:	0003      	movs	r3, r0
 80211cc:	60fb      	str	r3, [r7, #12]

    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 80211ce:	e00b      	b.n	80211e8 <HAL_RCCEx_PeriphCLKConfig+0x50>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80211d0:	f7ff fa6a 	bl	80206a8 <HAL_GetTick>
 80211d4:	0002      	movs	r2, r0
 80211d6:	68fb      	ldr	r3, [r7, #12]
 80211d8:	1ad3      	subs	r3, r2, r3
 80211da:	2b02      	cmp	r3, #2
 80211dc:	d904      	bls.n	80211e8 <HAL_RCCEx_PeriphCLKConfig+0x50>
      {
        ret = HAL_TIMEOUT;
 80211de:	2313      	movs	r3, #19
 80211e0:	18fb      	adds	r3, r7, r3
 80211e2:	2203      	movs	r2, #3
 80211e4:	701a      	strb	r2, [r3, #0]
        break;
 80211e6:	e008      	b.n	80211fa <HAL_RCCEx_PeriphCLKConfig+0x62>
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 80211e8:	4b83      	ldr	r3, [pc, #524]	; (80213f8 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 80211ea:	681a      	ldr	r2, [r3, #0]
 80211ec:	2380      	movs	r3, #128	; 0x80
 80211ee:	005b      	lsls	r3, r3, #1
 80211f0:	401a      	ands	r2, r3
 80211f2:	2380      	movs	r3, #128	; 0x80
 80211f4:	005b      	lsls	r3, r3, #1
 80211f6:	429a      	cmp	r2, r3
 80211f8:	d1ea      	bne.n	80211d0 <HAL_RCCEx_PeriphCLKConfig+0x38>
      }
    }

    if (ret == HAL_OK)
 80211fa:	2313      	movs	r3, #19
 80211fc:	18fb      	adds	r3, r7, r3
 80211fe:	781b      	ldrb	r3, [r3, #0]
 8021200:	2b00      	cmp	r3, #0
 8021202:	d143      	bne.n	802128c <HAL_RCCEx_PeriphCLKConfig+0xf4>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 8021204:	f7ff ff9a 	bl	802113c <LL_RCC_GetRTCClockSource>
 8021208:	0002      	movs	r2, r0
 802120a:	687b      	ldr	r3, [r7, #4]
 802120c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802120e:	429a      	cmp	r2, r3
 8021210:	d00f      	beq.n	8021232 <HAL_RCCEx_PeriphCLKConfig+0x9a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8021212:	23b0      	movs	r3, #176	; 0xb0
 8021214:	05db      	lsls	r3, r3, #23
 8021216:	2290      	movs	r2, #144	; 0x90
 8021218:	589b      	ldr	r3, [r3, r2]
 802121a:	4a78      	ldr	r2, [pc, #480]	; (80213fc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 802121c:	4013      	ands	r3, r2
 802121e:	617b      	str	r3, [r7, #20]

        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8021220:	f7ff ff98 	bl	8021154 <LL_RCC_ForceBackupDomainReset>
        __HAL_RCC_BACKUPRESET_RELEASE();
 8021224:	f7ff ffa6 	bl	8021174 <LL_RCC_ReleaseBackupDomainReset>

        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8021228:	23b0      	movs	r3, #176	; 0xb0
 802122a:	05db      	lsls	r3, r3, #23
 802122c:	2190      	movs	r1, #144	; 0x90
 802122e:	697a      	ldr	r2, [r7, #20]
 8021230:	505a      	str	r2, [r3, r1]
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 8021232:	697b      	ldr	r3, [r7, #20]
 8021234:	2202      	movs	r2, #2
 8021236:	4013      	ands	r3, r2
 8021238:	d016      	beq.n	8021268 <HAL_RCCEx_PeriphCLKConfig+0xd0>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 802123a:	f7ff fa35 	bl	80206a8 <HAL_GetTick>
 802123e:	0003      	movs	r3, r0
 8021240:	60fb      	str	r3, [r7, #12]

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() != 1U)
 8021242:	e00c      	b.n	802125e <HAL_RCCEx_PeriphCLKConfig+0xc6>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8021244:	f7ff fa30 	bl	80206a8 <HAL_GetTick>
 8021248:	0002      	movs	r2, r0
 802124a:	68fb      	ldr	r3, [r7, #12]
 802124c:	1ad3      	subs	r3, r2, r3
 802124e:	4a6c      	ldr	r2, [pc, #432]	; (8021400 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 8021250:	4293      	cmp	r3, r2
 8021252:	d904      	bls.n	802125e <HAL_RCCEx_PeriphCLKConfig+0xc6>
          {
            ret = HAL_TIMEOUT;
 8021254:	2313      	movs	r3, #19
 8021256:	18fb      	adds	r3, r7, r3
 8021258:	2203      	movs	r2, #3
 802125a:	701a      	strb	r2, [r3, #0]
            break;
 802125c:	e004      	b.n	8021268 <HAL_RCCEx_PeriphCLKConfig+0xd0>
        while (LL_RCC_LSE_IsReady() != 1U)
 802125e:	f7ff fe97 	bl	8020f90 <LL_RCC_LSE_IsReady>
 8021262:	0003      	movs	r3, r0
 8021264:	2b01      	cmp	r3, #1
 8021266:	d1ed      	bne.n	8021244 <HAL_RCCEx_PeriphCLKConfig+0xac>
          }
        }
      }

      if (ret == HAL_OK)
 8021268:	2313      	movs	r3, #19
 802126a:	18fb      	adds	r3, r7, r3
 802126c:	781b      	ldrb	r3, [r3, #0]
 802126e:	2b00      	cmp	r3, #0
 8021270:	d105      	bne.n	802127e <HAL_RCCEx_PeriphCLKConfig+0xe6>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8021272:	687b      	ldr	r3, [r7, #4]
 8021274:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8021276:	0018      	movs	r0, r3
 8021278:	f7ff ff48 	bl	802110c <LL_RCC_SetRTCClockSource>
 802127c:	e00c      	b.n	8021298 <HAL_RCCEx_PeriphCLKConfig+0x100>
      }
      else
      {
        /* set overall return value */
        status = ret;
 802127e:	2312      	movs	r3, #18
 8021280:	18fb      	adds	r3, r7, r3
 8021282:	2213      	movs	r2, #19
 8021284:	18ba      	adds	r2, r7, r2
 8021286:	7812      	ldrb	r2, [r2, #0]
 8021288:	701a      	strb	r2, [r3, #0]
 802128a:	e005      	b.n	8021298 <HAL_RCCEx_PeriphCLKConfig+0x100>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 802128c:	2312      	movs	r3, #18
 802128e:	18fb      	adds	r3, r7, r3
 8021290:	2213      	movs	r2, #19
 8021292:	18ba      	adds	r2, r7, r2
 8021294:	7812      	ldrb	r2, [r2, #0]
 8021296:	701a      	strb	r2, [r3, #0]
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8021298:	687b      	ldr	r3, [r7, #4]
 802129a:	681b      	ldr	r3, [r3, #0]
 802129c:	2201      	movs	r2, #1
 802129e:	4013      	ands	r3, r2
 80212a0:	d004      	beq.n	80212ac <HAL_RCCEx_PeriphCLKConfig+0x114>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 80212a2:	687b      	ldr	r3, [r7, #4]
 80212a4:	685b      	ldr	r3, [r3, #4]
 80212a6:	0018      	movs	r0, r3
 80212a8:	f7ff fe82 	bl	8020fb0 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 80212ac:	687b      	ldr	r3, [r7, #4]
 80212ae:	681b      	ldr	r3, [r3, #0]
 80212b0:	2202      	movs	r2, #2
 80212b2:	4013      	ands	r3, r2
 80212b4:	d004      	beq.n	80212c0 <HAL_RCCEx_PeriphCLKConfig+0x128>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 80212b6:	687b      	ldr	r3, [r7, #4]
 80212b8:	689b      	ldr	r3, [r3, #8]
 80212ba:	0018      	movs	r0, r3
 80212bc:	f7ff fe78 	bl	8020fb0 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 80212c0:	687b      	ldr	r3, [r7, #4]
 80212c2:	681b      	ldr	r3, [r3, #0]
 80212c4:	2220      	movs	r2, #32
 80212c6:	4013      	ands	r3, r2
 80212c8:	d004      	beq.n	80212d4 <HAL_RCCEx_PeriphCLKConfig+0x13c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 80212ca:	687b      	ldr	r3, [r7, #4]
 80212cc:	691b      	ldr	r3, [r3, #16]
 80212ce:	0018      	movs	r0, r3
 80212d0:	f7ff fea0 	bl	8021014 <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 80212d4:	687b      	ldr	r3, [r7, #4]
 80212d6:	681a      	ldr	r2, [r3, #0]
 80212d8:	2380      	movs	r3, #128	; 0x80
 80212da:	009b      	lsls	r3, r3, #2
 80212dc:	4013      	ands	r3, r2
 80212de:	d004      	beq.n	80212ea <HAL_RCCEx_PeriphCLKConfig+0x152>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80212e0:	687b      	ldr	r3, [r7, #4]
 80212e2:	6a1b      	ldr	r3, [r3, #32]
 80212e4:	0018      	movs	r0, r3
 80212e6:	f7ff fecb 	bl	8021080 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 80212ea:	687b      	ldr	r3, [r7, #4]
 80212ec:	681a      	ldr	r2, [r3, #0]
 80212ee:	2380      	movs	r3, #128	; 0x80
 80212f0:	00db      	lsls	r3, r3, #3
 80212f2:	4013      	ands	r3, r2
 80212f4:	d004      	beq.n	8021300 <HAL_RCCEx_PeriphCLKConfig+0x168>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 80212f6:	687b      	ldr	r3, [r7, #4]
 80212f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80212fa:	0018      	movs	r0, r3
 80212fc:	f7ff fec0 	bl	8021080 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 8021300:	687b      	ldr	r3, [r7, #4]
 8021302:	681a      	ldr	r2, [r3, #0]
 8021304:	2380      	movs	r3, #128	; 0x80
 8021306:	011b      	lsls	r3, r3, #4
 8021308:	4013      	ands	r3, r2
 802130a:	d004      	beq.n	8021316 <HAL_RCCEx_PeriphCLKConfig+0x17e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 802130c:	687b      	ldr	r3, [r7, #4]
 802130e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021310:	0018      	movs	r0, r3
 8021312:	f7ff feb5 	bl	8021080 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8021316:	687b      	ldr	r3, [r7, #4]
 8021318:	681b      	ldr	r3, [r3, #0]
 802131a:	2240      	movs	r2, #64	; 0x40
 802131c:	4013      	ands	r3, r2
 802131e:	d004      	beq.n	802132a <HAL_RCCEx_PeriphCLKConfig+0x192>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8021320:	687b      	ldr	r3, [r7, #4]
 8021322:	695b      	ldr	r3, [r3, #20]
 8021324:	0018      	movs	r0, r3
 8021326:	f7ff fe8d 	bl	8021044 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 802132a:	687b      	ldr	r3, [r7, #4]
 802132c:	681b      	ldr	r3, [r3, #0]
 802132e:	2280      	movs	r2, #128	; 0x80
 8021330:	4013      	ands	r3, r2
 8021332:	d004      	beq.n	802133e <HAL_RCCEx_PeriphCLKConfig+0x1a6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8021334:	687b      	ldr	r3, [r7, #4]
 8021336:	699b      	ldr	r3, [r3, #24]
 8021338:	0018      	movs	r0, r3
 802133a:	f7ff fe83 	bl	8021044 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 802133e:	687b      	ldr	r3, [r7, #4]
 8021340:	681a      	ldr	r2, [r3, #0]
 8021342:	2380      	movs	r3, #128	; 0x80
 8021344:	005b      	lsls	r3, r3, #1
 8021346:	4013      	ands	r3, r2
 8021348:	d004      	beq.n	8021354 <HAL_RCCEx_PeriphCLKConfig+0x1bc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 802134a:	687b      	ldr	r3, [r7, #4]
 802134c:	69db      	ldr	r3, [r3, #28]
 802134e:	0018      	movs	r0, r3
 8021350:	f7ff fe78 	bl	8021044 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 8021354:	687b      	ldr	r3, [r7, #4]
 8021356:	681b      	ldr	r3, [r3, #0]
 8021358:	2210      	movs	r2, #16
 802135a:	4013      	ands	r3, r2
 802135c:	d013      	beq.n	8021386 <HAL_RCCEx_PeriphCLKConfig+0x1ee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
 802135e:	687b      	ldr	r3, [r7, #4]
 8021360:	68db      	ldr	r3, [r3, #12]
 8021362:	0018      	movs	r0, r3
 8021364:	f7ff fe3e 	bl	8020fe4 <LL_RCC_SetI2SClockSource>

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 8021368:	687b      	ldr	r3, [r7, #4]
 802136a:	68da      	ldr	r2, [r3, #12]
 802136c:	2380      	movs	r3, #128	; 0x80
 802136e:	005b      	lsls	r3, r3, #1
 8021370:	429a      	cmp	r2, r3
 8021372:	d108      	bne.n	8021386 <HAL_RCCEx_PeriphCLKConfig+0x1ee>
    {
      /* Enable RCC_PLL_I2S2CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 8021374:	23b0      	movs	r3, #176	; 0xb0
 8021376:	05db      	lsls	r3, r3, #23
 8021378:	68da      	ldr	r2, [r3, #12]
 802137a:	23b0      	movs	r3, #176	; 0xb0
 802137c:	05db      	lsls	r3, r3, #23
 802137e:	2180      	movs	r1, #128	; 0x80
 8021380:	0449      	lsls	r1, r1, #17
 8021382:	430a      	orrs	r2, r1
 8021384:	60da      	str	r2, [r3, #12]
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8021386:	687b      	ldr	r3, [r7, #4]
 8021388:	681a      	ldr	r2, [r3, #0]
 802138a:	2380      	movs	r3, #128	; 0x80
 802138c:	021b      	lsls	r3, r3, #8
 802138e:	4013      	ands	r3, r2
 8021390:	d011      	beq.n	80213b6 <HAL_RCCEx_PeriphCLKConfig+0x21e>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8021392:	687b      	ldr	r3, [r7, #4]
 8021394:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021396:	0018      	movs	r0, r3
 8021398:	f7ff fe8b 	bl	80210b2 <LL_RCC_SetRNGClockSource>

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 802139c:	687b      	ldr	r3, [r7, #4]
 802139e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80213a0:	2b00      	cmp	r3, #0
 80213a2:	d108      	bne.n	80213b6 <HAL_RCCEx_PeriphCLKConfig+0x21e>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 80213a4:	23b0      	movs	r3, #176	; 0xb0
 80213a6:	05db      	lsls	r3, r3, #23
 80213a8:	68da      	ldr	r2, [r3, #12]
 80213aa:	23b0      	movs	r3, #176	; 0xb0
 80213ac:	05db      	lsls	r3, r3, #23
 80213ae:	2180      	movs	r1, #128	; 0x80
 80213b0:	0449      	lsls	r1, r1, #17
 80213b2:	430a      	orrs	r2, r1
 80213b4:	60da      	str	r2, [r3, #12]
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 80213b6:	687b      	ldr	r3, [r7, #4]
 80213b8:	681a      	ldr	r2, [r3, #0]
 80213ba:	2380      	movs	r3, #128	; 0x80
 80213bc:	01db      	lsls	r3, r3, #7
 80213be:	4013      	ands	r3, r2
 80213c0:	d013      	beq.n	80213ea <HAL_RCCEx_PeriphCLKConfig+0x252>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 80213c2:	687b      	ldr	r3, [r7, #4]
 80213c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80213c6:	0018      	movs	r0, r3
 80213c8:	f7ff fe88 	bl	80210dc <LL_RCC_SetADCClockSource>

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 80213cc:	687b      	ldr	r3, [r7, #4]
 80213ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80213d0:	2380      	movs	r3, #128	; 0x80
 80213d2:	059b      	lsls	r3, r3, #22
 80213d4:	429a      	cmp	r2, r3
 80213d6:	d108      	bne.n	80213ea <HAL_RCCEx_PeriphCLKConfig+0x252>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 80213d8:	23b0      	movs	r3, #176	; 0xb0
 80213da:	05db      	lsls	r3, r3, #23
 80213dc:	68da      	ldr	r2, [r3, #12]
 80213de:	23b0      	movs	r3, #176	; 0xb0
 80213e0:	05db      	lsls	r3, r3, #23
 80213e2:	2180      	movs	r1, #128	; 0x80
 80213e4:	0249      	lsls	r1, r1, #9
 80213e6:	430a      	orrs	r2, r1
 80213e8:	60da      	str	r2, [r3, #12]
    }
  }

  return status;
 80213ea:	2312      	movs	r3, #18
 80213ec:	18fb      	adds	r3, r7, r3
 80213ee:	781b      	ldrb	r3, [r3, #0]
}
 80213f0:	0018      	movs	r0, r3
 80213f2:	46bd      	mov	sp, r7
 80213f4:	b006      	add	sp, #24
 80213f6:	bd80      	pop	{r7, pc}
 80213f8:	58000400 	.word	0x58000400
 80213fc:	fffffcff 	.word	0xfffffcff
 8021400:	00001388 	.word	0x00001388

08021404 <HAL_RTC_Init>:
  * @brief  Initialize the RTC peripheral
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 8021404:	b5b0      	push	{r4, r5, r7, lr}
 8021406:	b084      	sub	sp, #16
 8021408:	af00      	add	r7, sp, #0
 802140a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
 802140c:	230f      	movs	r3, #15
 802140e:	18fb      	adds	r3, r7, r3
 8021410:	2201      	movs	r2, #1
 8021412:	701a      	strb	r2, [r3, #0]

  /* Check the RTC peripheral state */
  if (hrtc != NULL)
 8021414:	687b      	ldr	r3, [r7, #4]
 8021416:	2b00      	cmp	r3, #0
 8021418:	d100      	bne.n	802141c <HAL_RTC_Init+0x18>
 802141a:	e07e      	b.n	802151a <HAL_RTC_Init+0x116>
      {
        hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
      }
    }
#else
    if (hrtc->State == HAL_RTC_STATE_RESET)
 802141c:	687b      	ldr	r3, [r7, #4]
 802141e:	222d      	movs	r2, #45	; 0x2d
 8021420:	5c9b      	ldrb	r3, [r3, r2]
 8021422:	b2db      	uxtb	r3, r3
 8021424:	2b00      	cmp	r3, #0
 8021426:	d107      	bne.n	8021438 <HAL_RTC_Init+0x34>
    {
      /* Allocate lock resource and initialize it */
      hrtc->Lock = HAL_UNLOCKED;
 8021428:	687b      	ldr	r3, [r7, #4]
 802142a:	222c      	movs	r2, #44	; 0x2c
 802142c:	2100      	movs	r1, #0
 802142e:	5499      	strb	r1, [r3, r2]

      /* Initialize RTC MSP */
      HAL_RTC_MspInit(hrtc);
 8021430:	687b      	ldr	r3, [r7, #4]
 8021432:	0018      	movs	r0, r3
 8021434:	f7ff f83c 	bl	80204b0 <HAL_RTC_MspInit>
    }
#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_BUSY;
 8021438:	687b      	ldr	r3, [r7, #4]
 802143a:	222d      	movs	r2, #45	; 0x2d
 802143c:	2102      	movs	r1, #2
 802143e:	5499      	strb	r1, [r3, r2]

    /* Check if the calendar has been not initialized */
    if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
 8021440:	4b39      	ldr	r3, [pc, #228]	; (8021528 <HAL_RTC_Init+0x124>)
 8021442:	68db      	ldr	r3, [r3, #12]
 8021444:	2210      	movs	r2, #16
 8021446:	4013      	ands	r3, r2
 8021448:	2b10      	cmp	r3, #16
 802144a:	d059      	beq.n	8021500 <HAL_RTC_Init+0xfc>
    {
      /* Disable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802144c:	4b36      	ldr	r3, [pc, #216]	; (8021528 <HAL_RTC_Init+0x124>)
 802144e:	22ca      	movs	r2, #202	; 0xca
 8021450:	625a      	str	r2, [r3, #36]	; 0x24
 8021452:	4b35      	ldr	r3, [pc, #212]	; (8021528 <HAL_RTC_Init+0x124>)
 8021454:	2253      	movs	r2, #83	; 0x53
 8021456:	625a      	str	r2, [r3, #36]	; 0x24

      /* Enter Initialization mode */
      status = RTC_EnterInitMode(hrtc);
 8021458:	250f      	movs	r5, #15
 802145a:	197c      	adds	r4, r7, r5
 802145c:	687b      	ldr	r3, [r7, #4]
 802145e:	0018      	movs	r0, r3
 8021460:	f000 fc18 	bl	8021c94 <RTC_EnterInitMode>
 8021464:	0003      	movs	r3, r0
 8021466:	7023      	strb	r3, [r4, #0]
      if (status == HAL_OK)
 8021468:	0028      	movs	r0, r5
 802146a:	183b      	adds	r3, r7, r0
 802146c:	781b      	ldrb	r3, [r3, #0]
 802146e:	2b00      	cmp	r3, #0
 8021470:	d142      	bne.n	80214f8 <HAL_RTC_Init+0xf4>
      {
        /* Clear RTC_CR FMT, OSEL and POL Bits */
        CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 8021472:	4b2d      	ldr	r3, [pc, #180]	; (8021528 <HAL_RTC_Init+0x124>)
 8021474:	699a      	ldr	r2, [r3, #24]
 8021476:	4b2c      	ldr	r3, [pc, #176]	; (8021528 <HAL_RTC_Init+0x124>)
 8021478:	492c      	ldr	r1, [pc, #176]	; (802152c <HAL_RTC_Init+0x128>)
 802147a:	400a      	ands	r2, r1
 802147c:	619a      	str	r2, [r3, #24]
        /* Set RTC_CR register */
        SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 802147e:	4b2a      	ldr	r3, [pc, #168]	; (8021528 <HAL_RTC_Init+0x124>)
 8021480:	6999      	ldr	r1, [r3, #24]
 8021482:	687b      	ldr	r3, [r7, #4]
 8021484:	685a      	ldr	r2, [r3, #4]
 8021486:	687b      	ldr	r3, [r7, #4]
 8021488:	691b      	ldr	r3, [r3, #16]
 802148a:	431a      	orrs	r2, r3
 802148c:	687b      	ldr	r3, [r7, #4]
 802148e:	699b      	ldr	r3, [r3, #24]
 8021490:	431a      	orrs	r2, r3
 8021492:	4b25      	ldr	r3, [pc, #148]	; (8021528 <HAL_RTC_Init+0x124>)
 8021494:	430a      	orrs	r2, r1
 8021496:	619a      	str	r2, [r3, #24]

        /* Configure the RTC PRER */
        WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 8021498:	687b      	ldr	r3, [r7, #4]
 802149a:	68d9      	ldr	r1, [r3, #12]
 802149c:	687b      	ldr	r3, [r7, #4]
 802149e:	689b      	ldr	r3, [r3, #8]
 80214a0:	041a      	lsls	r2, r3, #16
 80214a2:	4b21      	ldr	r3, [pc, #132]	; (8021528 <HAL_RTC_Init+0x124>)
 80214a4:	430a      	orrs	r2, r1
 80214a6:	611a      	str	r2, [r3, #16]

        /* Configure the Binary mode */
        MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
 80214a8:	4b1f      	ldr	r3, [pc, #124]	; (8021528 <HAL_RTC_Init+0x124>)
 80214aa:	68db      	ldr	r3, [r3, #12]
 80214ac:	4a20      	ldr	r2, [pc, #128]	; (8021530 <HAL_RTC_Init+0x12c>)
 80214ae:	4013      	ands	r3, r2
 80214b0:	0019      	movs	r1, r3
 80214b2:	687b      	ldr	r3, [r7, #4]
 80214b4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80214b6:	687b      	ldr	r3, [r7, #4]
 80214b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80214ba:	431a      	orrs	r2, r3
 80214bc:	4b1a      	ldr	r3, [pc, #104]	; (8021528 <HAL_RTC_Init+0x124>)
 80214be:	430a      	orrs	r2, r1
 80214c0:	60da      	str	r2, [r3, #12]

        /* Exit Initialization mode */
        status = RTC_ExitInitMode(hrtc);
 80214c2:	0005      	movs	r5, r0
 80214c4:	183c      	adds	r4, r7, r0
 80214c6:	687b      	ldr	r3, [r7, #4]
 80214c8:	0018      	movs	r0, r3
 80214ca:	f000 fc23 	bl	8021d14 <RTC_ExitInitMode>
 80214ce:	0003      	movs	r3, r0
 80214d0:	7023      	strb	r3, [r4, #0]
        if (status == HAL_OK)
 80214d2:	197b      	adds	r3, r7, r5
 80214d4:	781b      	ldrb	r3, [r3, #0]
 80214d6:	2b00      	cmp	r3, #0
 80214d8:	d10e      	bne.n	80214f8 <HAL_RTC_Init+0xf4>
        {
          MODIFY_REG(RTC->CR, \
 80214da:	4b13      	ldr	r3, [pc, #76]	; (8021528 <HAL_RTC_Init+0x124>)
 80214dc:	699b      	ldr	r3, [r3, #24]
 80214de:	00db      	lsls	r3, r3, #3
 80214e0:	08d9      	lsrs	r1, r3, #3
 80214e2:	687b      	ldr	r3, [r7, #4]
 80214e4:	6a1a      	ldr	r2, [r3, #32]
 80214e6:	687b      	ldr	r3, [r7, #4]
 80214e8:	69db      	ldr	r3, [r3, #28]
 80214ea:	431a      	orrs	r2, r3
 80214ec:	687b      	ldr	r3, [r7, #4]
 80214ee:	695b      	ldr	r3, [r3, #20]
 80214f0:	431a      	orrs	r2, r3
 80214f2:	4b0d      	ldr	r3, [pc, #52]	; (8021528 <HAL_RTC_Init+0x124>)
 80214f4:	430a      	orrs	r2, r1
 80214f6:	619a      	str	r2, [r3, #24]
                    hrtc->Init.OutPutPullUp | hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
        }
      }

      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80214f8:	4b0b      	ldr	r3, [pc, #44]	; (8021528 <HAL_RTC_Init+0x124>)
 80214fa:	22ff      	movs	r2, #255	; 0xff
 80214fc:	625a      	str	r2, [r3, #36]	; 0x24
 80214fe:	e003      	b.n	8021508 <HAL_RTC_Init+0x104>
    }
    else
    {
      /* Calendar is already initialized */
      /* Set flag to OK */
      status = HAL_OK;
 8021500:	230f      	movs	r3, #15
 8021502:	18fb      	adds	r3, r7, r3
 8021504:	2200      	movs	r2, #0
 8021506:	701a      	strb	r2, [r3, #0]
    }

    if (status == HAL_OK)
 8021508:	230f      	movs	r3, #15
 802150a:	18fb      	adds	r3, r7, r3
 802150c:	781b      	ldrb	r3, [r3, #0]
 802150e:	2b00      	cmp	r3, #0
 8021510:	d103      	bne.n	802151a <HAL_RTC_Init+0x116>
    {
      hrtc->State = HAL_RTC_STATE_READY;
 8021512:	687b      	ldr	r3, [r7, #4]
 8021514:	222d      	movs	r2, #45	; 0x2d
 8021516:	2101      	movs	r1, #1
 8021518:	5499      	strb	r1, [r3, r2]
    }
  }

  return status;
 802151a:	230f      	movs	r3, #15
 802151c:	18fb      	adds	r3, r7, r3
 802151e:	781b      	ldrb	r3, [r3, #0]
}
 8021520:	0018      	movs	r0, r3
 8021522:	46bd      	mov	sp, r7
 8021524:	b004      	add	sp, #16
 8021526:	bdb0      	pop	{r4, r5, r7, pc}
 8021528:	40002800 	.word	0x40002800
 802152c:	fb8fffbf 	.word	0xfb8fffbf
 8021530:	ffffe0ff 	.word	0xffffe0ff

08021534 <HAL_RTC_SetTime>:
  *             @arg RTC_FORMAT_BIN: Binary format
  *             @arg RTC_FORMAT_BCD: BCD format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
 8021534:	b5b0      	push	{r4, r5, r7, lr}
 8021536:	b086      	sub	sp, #24
 8021538:	af00      	add	r7, sp, #0
 802153a:	60f8      	str	r0, [r7, #12]
 802153c:	60b9      	str	r1, [r7, #8]
 802153e:	607a      	str	r2, [r7, #4]
    assert_param(IS_RTC_FORMAT(Format));
  }
#endif

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8021540:	68fb      	ldr	r3, [r7, #12]
 8021542:	222c      	movs	r2, #44	; 0x2c
 8021544:	5c9b      	ldrb	r3, [r3, r2]
 8021546:	2b01      	cmp	r3, #1
 8021548:	d101      	bne.n	802154e <HAL_RTC_SetTime+0x1a>
 802154a:	2302      	movs	r3, #2
 802154c:	e090      	b.n	8021670 <HAL_RTC_SetTime+0x13c>
 802154e:	68fb      	ldr	r3, [r7, #12]
 8021550:	222c      	movs	r2, #44	; 0x2c
 8021552:	2101      	movs	r1, #1
 8021554:	5499      	strb	r1, [r3, r2]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8021556:	68fb      	ldr	r3, [r7, #12]
 8021558:	222d      	movs	r2, #45	; 0x2d
 802155a:	2102      	movs	r1, #2
 802155c:	5499      	strb	r1, [r3, r2]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 802155e:	4b46      	ldr	r3, [pc, #280]	; (8021678 <HAL_RTC_SetTime+0x144>)
 8021560:	22ca      	movs	r2, #202	; 0xca
 8021562:	625a      	str	r2, [r3, #36]	; 0x24
 8021564:	4b44      	ldr	r3, [pc, #272]	; (8021678 <HAL_RTC_SetTime+0x144>)
 8021566:	2253      	movs	r2, #83	; 0x53
 8021568:	625a      	str	r2, [r3, #36]	; 0x24

  /* Enter Initialization mode */
  status = RTC_EnterInitMode(hrtc);
 802156a:	2513      	movs	r5, #19
 802156c:	197c      	adds	r4, r7, r5
 802156e:	68fb      	ldr	r3, [r7, #12]
 8021570:	0018      	movs	r0, r3
 8021572:	f000 fb8f 	bl	8021c94 <RTC_EnterInitMode>
 8021576:	0003      	movs	r3, r0
 8021578:	7023      	strb	r3, [r4, #0]
  if (status == HAL_OK)
 802157a:	197b      	adds	r3, r7, r5
 802157c:	781b      	ldrb	r3, [r3, #0]
 802157e:	2b00      	cmp	r3, #0
 8021580:	d15c      	bne.n	802163c <HAL_RTC_SetTime+0x108>
  {
    /* Check Binary mode ((32-bit free-running counter) */
    if (READ_BIT(RTC->ICSR, RTC_ICSR_BIN) != RTC_BINARY_ONLY)
 8021582:	4b3d      	ldr	r3, [pc, #244]	; (8021678 <HAL_RTC_SetTime+0x144>)
 8021584:	68da      	ldr	r2, [r3, #12]
 8021586:	23c0      	movs	r3, #192	; 0xc0
 8021588:	009b      	lsls	r3, r3, #2
 802158a:	401a      	ands	r2, r3
 802158c:	2380      	movs	r3, #128	; 0x80
 802158e:	005b      	lsls	r3, r3, #1
 8021590:	429a      	cmp	r2, r3
 8021592:	d053      	beq.n	802163c <HAL_RTC_SetTime+0x108>
    {
      if (Format == RTC_FORMAT_BIN)
 8021594:	687b      	ldr	r3, [r7, #4]
 8021596:	2b00      	cmp	r3, #0
 8021598:	d124      	bne.n	80215e4 <HAL_RTC_SetTime+0xb0>
      {
        if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 802159a:	4b37      	ldr	r3, [pc, #220]	; (8021678 <HAL_RTC_SetTime+0x144>)
 802159c:	699b      	ldr	r3, [r3, #24]
 802159e:	2240      	movs	r2, #64	; 0x40
 80215a0:	4013      	ands	r3, r2
 80215a2:	d102      	bne.n	80215aa <HAL_RTC_SetTime+0x76>
          assert_param(IS_RTC_HOUR12(sTime->Hours));
          assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
        }
        else
        {
          sTime->TimeFormat = 0x00U;
 80215a4:	68bb      	ldr	r3, [r7, #8]
 80215a6:	2200      	movs	r2, #0
 80215a8:	70da      	strb	r2, [r3, #3]
          assert_param(IS_RTC_HOUR24(sTime->Hours));
        }
        assert_param(IS_RTC_MINUTES(sTime->Minutes));
        assert_param(IS_RTC_SECONDS(sTime->Seconds));

        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
 80215aa:	68bb      	ldr	r3, [r7, #8]
 80215ac:	781b      	ldrb	r3, [r3, #0]
 80215ae:	0018      	movs	r0, r3
 80215b0:	f000 fbf4 	bl	8021d9c <RTC_ByteToBcd2>
 80215b4:	0003      	movs	r3, r0
 80215b6:	041c      	lsls	r4, r3, #16
                            ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 80215b8:	68bb      	ldr	r3, [r7, #8]
 80215ba:	785b      	ldrb	r3, [r3, #1]
 80215bc:	0018      	movs	r0, r3
 80215be:	f000 fbed 	bl	8021d9c <RTC_ByteToBcd2>
 80215c2:	0003      	movs	r3, r0
 80215c4:	021b      	lsls	r3, r3, #8
        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
 80215c6:	431c      	orrs	r4, r3
                            ((uint32_t)RTC_ByteToBcd2(sTime->Seconds) << RTC_TR_SU_Pos) | \
 80215c8:	68bb      	ldr	r3, [r7, #8]
 80215ca:	789b      	ldrb	r3, [r3, #2]
 80215cc:	0018      	movs	r0, r3
 80215ce:	f000 fbe5 	bl	8021d9c <RTC_ByteToBcd2>
 80215d2:	0003      	movs	r3, r0
                            ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 80215d4:	0022      	movs	r2, r4
 80215d6:	431a      	orrs	r2, r3
                            (((uint32_t)sTime->TimeFormat) << RTC_TR_PM_Pos));
 80215d8:	68bb      	ldr	r3, [r7, #8]
 80215da:	78db      	ldrb	r3, [r3, #3]
 80215dc:	059b      	lsls	r3, r3, #22
        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
 80215de:	4313      	orrs	r3, r2
 80215e0:	617b      	str	r3, [r7, #20]
 80215e2:	e016      	b.n	8021612 <HAL_RTC_SetTime+0xde>

      }
      else
      {
        if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 80215e4:	4b24      	ldr	r3, [pc, #144]	; (8021678 <HAL_RTC_SetTime+0x144>)
 80215e6:	699b      	ldr	r3, [r3, #24]
 80215e8:	2240      	movs	r2, #64	; 0x40
 80215ea:	4013      	ands	r3, r2
 80215ec:	d102      	bne.n	80215f4 <HAL_RTC_SetTime+0xc0>
          assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sTime->Hours)));
          assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
        }
        else
        {
          sTime->TimeFormat = 0x00U;
 80215ee:	68bb      	ldr	r3, [r7, #8]
 80215f0:	2200      	movs	r2, #0
 80215f2:	70da      	strb	r2, [r3, #3]
          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
        }
        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
        tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
 80215f4:	68bb      	ldr	r3, [r7, #8]
 80215f6:	781b      	ldrb	r3, [r3, #0]
 80215f8:	041a      	lsls	r2, r3, #16
                  ((uint32_t)(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 80215fa:	68bb      	ldr	r3, [r7, #8]
 80215fc:	785b      	ldrb	r3, [r3, #1]
 80215fe:	021b      	lsls	r3, r3, #8
        tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
 8021600:	4313      	orrs	r3, r2
                  ((uint32_t)(sTime->Seconds) << RTC_TR_SU_Pos) | \
 8021602:	68ba      	ldr	r2, [r7, #8]
 8021604:	7892      	ldrb	r2, [r2, #2]
                  ((uint32_t)(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 8021606:	431a      	orrs	r2, r3
                  ((uint32_t)(sTime->TimeFormat) << RTC_TR_PM_Pos));
 8021608:	68bb      	ldr	r3, [r7, #8]
 802160a:	78db      	ldrb	r3, [r3, #3]
 802160c:	059b      	lsls	r3, r3, #22
        tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
 802160e:	4313      	orrs	r3, r2
 8021610:	617b      	str	r3, [r7, #20]
      }

      /* Set the RTC_TR register */
      WRITE_REG(RTC->TR, (tmpreg & RTC_TR_RESERVED_MASK));
 8021612:	4b19      	ldr	r3, [pc, #100]	; (8021678 <HAL_RTC_SetTime+0x144>)
 8021614:	697a      	ldr	r2, [r7, #20]
 8021616:	4919      	ldr	r1, [pc, #100]	; (802167c <HAL_RTC_SetTime+0x148>)
 8021618:	400a      	ands	r2, r1
 802161a:	601a      	str	r2, [r3, #0]
      
      /* This interface is deprecated. To manage Daylight Saving Time, please use HAL_RTC_DST_xxx functions */
      CLEAR_BIT(RTC->CR, RTC_CR_BKP);
 802161c:	4b16      	ldr	r3, [pc, #88]	; (8021678 <HAL_RTC_SetTime+0x144>)
 802161e:	699a      	ldr	r2, [r3, #24]
 8021620:	4b15      	ldr	r3, [pc, #84]	; (8021678 <HAL_RTC_SetTime+0x144>)
 8021622:	4917      	ldr	r1, [pc, #92]	; (8021680 <HAL_RTC_SetTime+0x14c>)
 8021624:	400a      	ands	r2, r1
 8021626:	619a      	str	r2, [r3, #24]

      /* This interface is deprecated. To manage Daylight Saving Time, please use HAL_RTC_DST_xxx functions */
      SET_BIT(RTC->CR, (sTime->DayLightSaving | sTime->StoreOperation));
 8021628:	4b13      	ldr	r3, [pc, #76]	; (8021678 <HAL_RTC_SetTime+0x144>)
 802162a:	6999      	ldr	r1, [r3, #24]
 802162c:	68bb      	ldr	r3, [r7, #8]
 802162e:	68da      	ldr	r2, [r3, #12]
 8021630:	68bb      	ldr	r3, [r7, #8]
 8021632:	691b      	ldr	r3, [r3, #16]
 8021634:	431a      	orrs	r2, r3
 8021636:	4b10      	ldr	r3, [pc, #64]	; (8021678 <HAL_RTC_SetTime+0x144>)
 8021638:	430a      	orrs	r2, r1
 802163a:	619a      	str	r2, [r3, #24]
    }
  }

  /* Exit Initialization mode */
  status = RTC_ExitInitMode(hrtc);
 802163c:	2513      	movs	r5, #19
 802163e:	197c      	adds	r4, r7, r5
 8021640:	68fb      	ldr	r3, [r7, #12]
 8021642:	0018      	movs	r0, r3
 8021644:	f000 fb66 	bl	8021d14 <RTC_ExitInitMode>
 8021648:	0003      	movs	r3, r0
 802164a:	7023      	strb	r3, [r4, #0]


  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 802164c:	4b0a      	ldr	r3, [pc, #40]	; (8021678 <HAL_RTC_SetTime+0x144>)
 802164e:	22ff      	movs	r2, #255	; 0xff
 8021650:	625a      	str	r2, [r3, #36]	; 0x24

  if (status == HAL_OK)
 8021652:	197b      	adds	r3, r7, r5
 8021654:	781b      	ldrb	r3, [r3, #0]
 8021656:	2b00      	cmp	r3, #0
 8021658:	d103      	bne.n	8021662 <HAL_RTC_SetTime+0x12e>
  {
    hrtc->State = HAL_RTC_STATE_READY;
 802165a:	68fb      	ldr	r3, [r7, #12]
 802165c:	222d      	movs	r2, #45	; 0x2d
 802165e:	2101      	movs	r1, #1
 8021660:	5499      	strb	r1, [r3, r2]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8021662:	68fb      	ldr	r3, [r7, #12]
 8021664:	222c      	movs	r2, #44	; 0x2c
 8021666:	2100      	movs	r1, #0
 8021668:	5499      	strb	r1, [r3, r2]

  return status;
 802166a:	2313      	movs	r3, #19
 802166c:	18fb      	adds	r3, r7, r3
 802166e:	781b      	ldrb	r3, [r3, #0]
}
 8021670:	0018      	movs	r0, r3
 8021672:	46bd      	mov	sp, r7
 8021674:	b006      	add	sp, #24
 8021676:	bdb0      	pop	{r4, r5, r7, pc}
 8021678:	40002800 	.word	0x40002800
 802167c:	007f7f7f 	.word	0x007f7f7f
 8021680:	fffbffff 	.word	0xfffbffff

08021684 <HAL_RTC_GetTime>:
  *            @arg RTC_FORMAT_BIN: Binary format
  *            @arg RTC_FORMAT_BCD: BCD format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
 8021684:	b580      	push	{r7, lr}
 8021686:	b086      	sub	sp, #24
 8021688:	af00      	add	r7, sp, #0
 802168a:	60f8      	str	r0, [r7, #12]
 802168c:	60b9      	str	r1, [r7, #8]
 802168e:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg;

  UNUSED(hrtc);
  /* Get subseconds structure field from the corresponding register*/
  sTime->SubSeconds = READ_REG(RTC->SSR);
 8021690:	4b2c      	ldr	r3, [pc, #176]	; (8021744 <HAL_RTC_GetTime+0xc0>)
 8021692:	689a      	ldr	r2, [r3, #8]
 8021694:	68bb      	ldr	r3, [r7, #8]
 8021696:	605a      	str	r2, [r3, #4]

  if (READ_BIT(RTC->ICSR, RTC_ICSR_BIN) != RTC_BINARY_ONLY)
 8021698:	4b2a      	ldr	r3, [pc, #168]	; (8021744 <HAL_RTC_GetTime+0xc0>)
 802169a:	68da      	ldr	r2, [r3, #12]
 802169c:	23c0      	movs	r3, #192	; 0xc0
 802169e:	009b      	lsls	r3, r3, #2
 80216a0:	401a      	ands	r2, r3
 80216a2:	2380      	movs	r3, #128	; 0x80
 80216a4:	005b      	lsls	r3, r3, #1
 80216a6:	429a      	cmp	r2, r3
 80216a8:	d047      	beq.n	802173a <HAL_RTC_GetTime+0xb6>
  {
    /* Check the parameters */
    assert_param(IS_RTC_FORMAT(Format));

    /* Get SecondFraction structure field from the corresponding register field*/
    sTime->SecondFraction = (uint32_t)(READ_REG(RTC->PRER) & RTC_PRER_PREDIV_S);
 80216aa:	4b26      	ldr	r3, [pc, #152]	; (8021744 <HAL_RTC_GetTime+0xc0>)
 80216ac:	691b      	ldr	r3, [r3, #16]
 80216ae:	045b      	lsls	r3, r3, #17
 80216b0:	0c5a      	lsrs	r2, r3, #17
 80216b2:	68bb      	ldr	r3, [r7, #8]
 80216b4:	609a      	str	r2, [r3, #8]

    /* Get the TR register */
    tmpreg = (uint32_t)(READ_REG(RTC->TR) & RTC_TR_RESERVED_MASK);
 80216b6:	4b23      	ldr	r3, [pc, #140]	; (8021744 <HAL_RTC_GetTime+0xc0>)
 80216b8:	681b      	ldr	r3, [r3, #0]
 80216ba:	4a23      	ldr	r2, [pc, #140]	; (8021748 <HAL_RTC_GetTime+0xc4>)
 80216bc:	4013      	ands	r3, r2
 80216be:	617b      	str	r3, [r7, #20]

    /* Fill the structure fields with the read parameters */
    sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> RTC_TR_HU_Pos);
 80216c0:	697b      	ldr	r3, [r7, #20]
 80216c2:	0c1b      	lsrs	r3, r3, #16
 80216c4:	b2db      	uxtb	r3, r3
 80216c6:	223f      	movs	r2, #63	; 0x3f
 80216c8:	4013      	ands	r3, r2
 80216ca:	b2da      	uxtb	r2, r3
 80216cc:	68bb      	ldr	r3, [r7, #8]
 80216ce:	701a      	strb	r2, [r3, #0]
    sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> RTC_TR_MNU_Pos);
 80216d0:	697b      	ldr	r3, [r7, #20]
 80216d2:	0a1b      	lsrs	r3, r3, #8
 80216d4:	b2db      	uxtb	r3, r3
 80216d6:	227f      	movs	r2, #127	; 0x7f
 80216d8:	4013      	ands	r3, r2
 80216da:	b2da      	uxtb	r2, r3
 80216dc:	68bb      	ldr	r3, [r7, #8]
 80216de:	705a      	strb	r2, [r3, #1]
    sTime->Seconds = (uint8_t)((tmpreg & (RTC_TR_ST | RTC_TR_SU)) >> RTC_TR_SU_Pos);
 80216e0:	697b      	ldr	r3, [r7, #20]
 80216e2:	b2db      	uxtb	r3, r3
 80216e4:	227f      	movs	r2, #127	; 0x7f
 80216e6:	4013      	ands	r3, r2
 80216e8:	b2da      	uxtb	r2, r3
 80216ea:	68bb      	ldr	r3, [r7, #8]
 80216ec:	709a      	strb	r2, [r3, #2]
    sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> RTC_TR_PM_Pos);
 80216ee:	697b      	ldr	r3, [r7, #20]
 80216f0:	0d9b      	lsrs	r3, r3, #22
 80216f2:	b2db      	uxtb	r3, r3
 80216f4:	2201      	movs	r2, #1
 80216f6:	4013      	ands	r3, r2
 80216f8:	b2da      	uxtb	r2, r3
 80216fa:	68bb      	ldr	r3, [r7, #8]
 80216fc:	70da      	strb	r2, [r3, #3]

    /* Check the input parameters format */
    if (Format == RTC_FORMAT_BIN)
 80216fe:	687b      	ldr	r3, [r7, #4]
 8021700:	2b00      	cmp	r3, #0
 8021702:	d11a      	bne.n	802173a <HAL_RTC_GetTime+0xb6>
    {
      /* Convert the time structure parameters to Binary format */
      sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
 8021704:	68bb      	ldr	r3, [r7, #8]
 8021706:	781b      	ldrb	r3, [r3, #0]
 8021708:	0018      	movs	r0, r3
 802170a:	f000 fb6f 	bl	8021dec <RTC_Bcd2ToByte>
 802170e:	0003      	movs	r3, r0
 8021710:	001a      	movs	r2, r3
 8021712:	68bb      	ldr	r3, [r7, #8]
 8021714:	701a      	strb	r2, [r3, #0]
      sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
 8021716:	68bb      	ldr	r3, [r7, #8]
 8021718:	785b      	ldrb	r3, [r3, #1]
 802171a:	0018      	movs	r0, r3
 802171c:	f000 fb66 	bl	8021dec <RTC_Bcd2ToByte>
 8021720:	0003      	movs	r3, r0
 8021722:	001a      	movs	r2, r3
 8021724:	68bb      	ldr	r3, [r7, #8]
 8021726:	705a      	strb	r2, [r3, #1]
      sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
 8021728:	68bb      	ldr	r3, [r7, #8]
 802172a:	789b      	ldrb	r3, [r3, #2]
 802172c:	0018      	movs	r0, r3
 802172e:	f000 fb5d 	bl	8021dec <RTC_Bcd2ToByte>
 8021732:	0003      	movs	r3, r0
 8021734:	001a      	movs	r2, r3
 8021736:	68bb      	ldr	r3, [r7, #8]
 8021738:	709a      	strb	r2, [r3, #2]
    }
  }

  return HAL_OK;
 802173a:	2300      	movs	r3, #0
}
 802173c:	0018      	movs	r0, r3
 802173e:	46bd      	mov	sp, r7
 8021740:	b006      	add	sp, #24
 8021742:	bd80      	pop	{r7, pc}
 8021744:	40002800 	.word	0x40002800
 8021748:	007f7f7f 	.word	0x007f7f7f

0802174c <HAL_RTC_SetDate>:
  *            @arg RTC_FORMAT_BIN: Binary format
  *            @arg RTC_FORMAT_BCD: BCD format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
 802174c:	b5b0      	push	{r4, r5, r7, lr}
 802174e:	b086      	sub	sp, #24
 8021750:	af00      	add	r7, sp, #0
 8021752:	60f8      	str	r0, [r7, #12]
 8021754:	60b9      	str	r1, [r7, #8]
 8021756:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8021758:	68fb      	ldr	r3, [r7, #12]
 802175a:	222c      	movs	r2, #44	; 0x2c
 802175c:	5c9b      	ldrb	r3, [r3, r2]
 802175e:	2b01      	cmp	r3, #1
 8021760:	d101      	bne.n	8021766 <HAL_RTC_SetDate+0x1a>
 8021762:	2302      	movs	r3, #2
 8021764:	e07a      	b.n	802185c <HAL_RTC_SetDate+0x110>
 8021766:	68fb      	ldr	r3, [r7, #12]
 8021768:	222c      	movs	r2, #44	; 0x2c
 802176a:	2101      	movs	r1, #1
 802176c:	5499      	strb	r1, [r3, r2]

  hrtc->State = HAL_RTC_STATE_BUSY;
 802176e:	68fb      	ldr	r3, [r7, #12]
 8021770:	222d      	movs	r2, #45	; 0x2d
 8021772:	2102      	movs	r1, #2
 8021774:	5499      	strb	r1, [r3, r2]

  if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8021776:	687b      	ldr	r3, [r7, #4]
 8021778:	2b00      	cmp	r3, #0
 802177a:	d10e      	bne.n	802179a <HAL_RTC_SetDate+0x4e>
 802177c:	68bb      	ldr	r3, [r7, #8]
 802177e:	785b      	ldrb	r3, [r3, #1]
 8021780:	001a      	movs	r2, r3
 8021782:	2310      	movs	r3, #16
 8021784:	4013      	ands	r3, r2
 8021786:	d008      	beq.n	802179a <HAL_RTC_SetDate+0x4e>
  {
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8021788:	68bb      	ldr	r3, [r7, #8]
 802178a:	785b      	ldrb	r3, [r3, #1]
 802178c:	2210      	movs	r2, #16
 802178e:	4393      	bics	r3, r2
 8021790:	b2db      	uxtb	r3, r3
 8021792:	330a      	adds	r3, #10
 8021794:	b2da      	uxtb	r2, r3
 8021796:	68bb      	ldr	r3, [r7, #8]
 8021798:	705a      	strb	r2, [r3, #1]
  }

  assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));

  if (Format == RTC_FORMAT_BIN)
 802179a:	687b      	ldr	r3, [r7, #4]
 802179c:	2b00      	cmp	r3, #0
 802179e:	d11c      	bne.n	80217da <HAL_RTC_SetDate+0x8e>
  {
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 80217a0:	68bb      	ldr	r3, [r7, #8]
 80217a2:	78db      	ldrb	r3, [r3, #3]
 80217a4:	0018      	movs	r0, r3
 80217a6:	f000 faf9 	bl	8021d9c <RTC_ByteToBcd2>
 80217aa:	0003      	movs	r3, r0
 80217ac:	041c      	lsls	r4, r3, #16
                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
 80217ae:	68bb      	ldr	r3, [r7, #8]
 80217b0:	785b      	ldrb	r3, [r3, #1]
 80217b2:	0018      	movs	r0, r3
 80217b4:	f000 faf2 	bl	8021d9c <RTC_ByteToBcd2>
 80217b8:	0003      	movs	r3, r0
 80217ba:	021b      	lsls	r3, r3, #8
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 80217bc:	431c      	orrs	r4, r3
                  ((uint32_t)RTC_ByteToBcd2(sDate->Date) << RTC_DR_DU_Pos) | \
 80217be:	68bb      	ldr	r3, [r7, #8]
 80217c0:	789b      	ldrb	r3, [r3, #2]
 80217c2:	0018      	movs	r0, r3
 80217c4:	f000 faea 	bl	8021d9c <RTC_ByteToBcd2>
 80217c8:	0003      	movs	r3, r0
                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
 80217ca:	0022      	movs	r2, r4
 80217cc:	431a      	orrs	r2, r3
                  ((uint32_t)sDate->WeekDay << RTC_DR_WDU_Pos));
 80217ce:	68bb      	ldr	r3, [r7, #8]
 80217d0:	781b      	ldrb	r3, [r3, #0]
 80217d2:	035b      	lsls	r3, r3, #13
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 80217d4:	4313      	orrs	r3, r2
 80217d6:	617b      	str	r3, [r7, #20]
 80217d8:	e00e      	b.n	80217f8 <HAL_RTC_SetDate+0xac>
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
    assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));

    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
 80217da:	68bb      	ldr	r3, [r7, #8]
 80217dc:	78db      	ldrb	r3, [r3, #3]
 80217de:	041a      	lsls	r2, r3, #16
                  (((uint32_t)sDate->Month) << RTC_DR_MU_Pos) | \
 80217e0:	68bb      	ldr	r3, [r7, #8]
 80217e2:	785b      	ldrb	r3, [r3, #1]
 80217e4:	021b      	lsls	r3, r3, #8
    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
 80217e6:	4313      	orrs	r3, r2
                  (((uint32_t)sDate->Date) << RTC_DR_DU_Pos) | \
 80217e8:	68ba      	ldr	r2, [r7, #8]
 80217ea:	7892      	ldrb	r2, [r2, #2]
                  (((uint32_t)sDate->Month) << RTC_DR_MU_Pos) | \
 80217ec:	431a      	orrs	r2, r3
                  (((uint32_t)sDate->WeekDay) << RTC_DR_WDU_Pos));
 80217ee:	68bb      	ldr	r3, [r7, #8]
 80217f0:	781b      	ldrb	r3, [r3, #0]
 80217f2:	035b      	lsls	r3, r3, #13
    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
 80217f4:	4313      	orrs	r3, r2
 80217f6:	617b      	str	r3, [r7, #20]
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80217f8:	4b1a      	ldr	r3, [pc, #104]	; (8021864 <HAL_RTC_SetDate+0x118>)
 80217fa:	22ca      	movs	r2, #202	; 0xca
 80217fc:	625a      	str	r2, [r3, #36]	; 0x24
 80217fe:	4b19      	ldr	r3, [pc, #100]	; (8021864 <HAL_RTC_SetDate+0x118>)
 8021800:	2253      	movs	r2, #83	; 0x53
 8021802:	625a      	str	r2, [r3, #36]	; 0x24

  /* Enter Initialization mode */
  status = RTC_EnterInitMode(hrtc);
 8021804:	2513      	movs	r5, #19
 8021806:	197c      	adds	r4, r7, r5
 8021808:	68fb      	ldr	r3, [r7, #12]
 802180a:	0018      	movs	r0, r3
 802180c:	f000 fa42 	bl	8021c94 <RTC_EnterInitMode>
 8021810:	0003      	movs	r3, r0
 8021812:	7023      	strb	r3, [r4, #0]
  if (status == HAL_OK)
 8021814:	0028      	movs	r0, r5
 8021816:	183b      	adds	r3, r7, r0
 8021818:	781b      	ldrb	r3, [r3, #0]
 802181a:	2b00      	cmp	r3, #0
 802181c:	d10b      	bne.n	8021836 <HAL_RTC_SetDate+0xea>
  {
    /* Set the RTC_DR register */
    WRITE_REG(RTC->DR, (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK));
 802181e:	4b11      	ldr	r3, [pc, #68]	; (8021864 <HAL_RTC_SetDate+0x118>)
 8021820:	697a      	ldr	r2, [r7, #20]
 8021822:	4911      	ldr	r1, [pc, #68]	; (8021868 <HAL_RTC_SetDate+0x11c>)
 8021824:	400a      	ands	r2, r1
 8021826:	605a      	str	r2, [r3, #4]

    /* Exit Initialization mode */
    status = RTC_ExitInitMode(hrtc);
 8021828:	183c      	adds	r4, r7, r0
 802182a:	68fb      	ldr	r3, [r7, #12]
 802182c:	0018      	movs	r0, r3
 802182e:	f000 fa71 	bl	8021d14 <RTC_ExitInitMode>
 8021832:	0003      	movs	r3, r0
 8021834:	7023      	strb	r3, [r4, #0]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8021836:	4b0b      	ldr	r3, [pc, #44]	; (8021864 <HAL_RTC_SetDate+0x118>)
 8021838:	22ff      	movs	r2, #255	; 0xff
 802183a:	625a      	str	r2, [r3, #36]	; 0x24

  if (status == HAL_OK)
 802183c:	2313      	movs	r3, #19
 802183e:	18fb      	adds	r3, r7, r3
 8021840:	781b      	ldrb	r3, [r3, #0]
 8021842:	2b00      	cmp	r3, #0
 8021844:	d103      	bne.n	802184e <HAL_RTC_SetDate+0x102>
  {
    hrtc->State = HAL_RTC_STATE_READY ;
 8021846:	68fb      	ldr	r3, [r7, #12]
 8021848:	222d      	movs	r2, #45	; 0x2d
 802184a:	2101      	movs	r1, #1
 802184c:	5499      	strb	r1, [r3, r2]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802184e:	68fb      	ldr	r3, [r7, #12]
 8021850:	222c      	movs	r2, #44	; 0x2c
 8021852:	2100      	movs	r1, #0
 8021854:	5499      	strb	r1, [r3, r2]

  return status;
 8021856:	2313      	movs	r3, #19
 8021858:	18fb      	adds	r3, r7, r3
 802185a:	781b      	ldrb	r3, [r3, #0]
}
 802185c:	0018      	movs	r0, r3
 802185e:	46bd      	mov	sp, r7
 8021860:	b006      	add	sp, #24
 8021862:	bdb0      	pop	{r4, r5, r7, pc}
 8021864:	40002800 	.word	0x40002800
 8021868:	00ffff3f 	.word	0x00ffff3f

0802186c <HAL_RTC_GetDate>:
  *            @arg RTC_FORMAT_BIN: Binary format
  *            @arg RTC_FORMAT_BCD: BCD format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
 802186c:	b580      	push	{r7, lr}
 802186e:	b086      	sub	sp, #24
 8021870:	af00      	add	r7, sp, #0
 8021872:	60f8      	str	r0, [r7, #12]
 8021874:	60b9      	str	r1, [r7, #8]
 8021876:	607a      	str	r2, [r7, #4]
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Get the DR register */
  datetmpreg = (uint32_t)(READ_REG(RTC->DR) & RTC_DR_RESERVED_MASK);
 8021878:	4b21      	ldr	r3, [pc, #132]	; (8021900 <HAL_RTC_GetDate+0x94>)
 802187a:	685b      	ldr	r3, [r3, #4]
 802187c:	4a21      	ldr	r2, [pc, #132]	; (8021904 <HAL_RTC_GetDate+0x98>)
 802187e:	4013      	ands	r3, r2
 8021880:	617b      	str	r3, [r7, #20]

  /* Fill the structure fields with the read parameters */
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> RTC_DR_YU_Pos);
 8021882:	697b      	ldr	r3, [r7, #20]
 8021884:	0c1b      	lsrs	r3, r3, #16
 8021886:	b2da      	uxtb	r2, r3
 8021888:	68bb      	ldr	r3, [r7, #8]
 802188a:	70da      	strb	r2, [r3, #3]
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> RTC_DR_MU_Pos);
 802188c:	697b      	ldr	r3, [r7, #20]
 802188e:	0a1b      	lsrs	r3, r3, #8
 8021890:	b2db      	uxtb	r3, r3
 8021892:	221f      	movs	r2, #31
 8021894:	4013      	ands	r3, r2
 8021896:	b2da      	uxtb	r2, r3
 8021898:	68bb      	ldr	r3, [r7, #8]
 802189a:	705a      	strb	r2, [r3, #1]
  sDate->Date = (uint8_t)((datetmpreg & (RTC_DR_DT | RTC_DR_DU)) >> RTC_DR_DU_Pos);
 802189c:	697b      	ldr	r3, [r7, #20]
 802189e:	b2db      	uxtb	r3, r3
 80218a0:	223f      	movs	r2, #63	; 0x3f
 80218a2:	4013      	ands	r3, r2
 80218a4:	b2da      	uxtb	r2, r3
 80218a6:	68bb      	ldr	r3, [r7, #8]
 80218a8:	709a      	strb	r2, [r3, #2]
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> RTC_DR_WDU_Pos);
 80218aa:	697b      	ldr	r3, [r7, #20]
 80218ac:	0b5b      	lsrs	r3, r3, #13
 80218ae:	b2db      	uxtb	r3, r3
 80218b0:	2207      	movs	r2, #7
 80218b2:	4013      	ands	r3, r2
 80218b4:	b2da      	uxtb	r2, r3
 80218b6:	68bb      	ldr	r3, [r7, #8]
 80218b8:	701a      	strb	r2, [r3, #0]

  /* Check the input parameters format */
  if (Format == RTC_FORMAT_BIN)
 80218ba:	687b      	ldr	r3, [r7, #4]
 80218bc:	2b00      	cmp	r3, #0
 80218be:	d11a      	bne.n	80218f6 <HAL_RTC_GetDate+0x8a>
  {
    /* Convert the date structure parameters to Binary format */
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
 80218c0:	68bb      	ldr	r3, [r7, #8]
 80218c2:	78db      	ldrb	r3, [r3, #3]
 80218c4:	0018      	movs	r0, r3
 80218c6:	f000 fa91 	bl	8021dec <RTC_Bcd2ToByte>
 80218ca:	0003      	movs	r3, r0
 80218cc:	001a      	movs	r2, r3
 80218ce:	68bb      	ldr	r3, [r7, #8]
 80218d0:	70da      	strb	r2, [r3, #3]
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
 80218d2:	68bb      	ldr	r3, [r7, #8]
 80218d4:	785b      	ldrb	r3, [r3, #1]
 80218d6:	0018      	movs	r0, r3
 80218d8:	f000 fa88 	bl	8021dec <RTC_Bcd2ToByte>
 80218dc:	0003      	movs	r3, r0
 80218de:	001a      	movs	r2, r3
 80218e0:	68bb      	ldr	r3, [r7, #8]
 80218e2:	705a      	strb	r2, [r3, #1]
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
 80218e4:	68bb      	ldr	r3, [r7, #8]
 80218e6:	789b      	ldrb	r3, [r3, #2]
 80218e8:	0018      	movs	r0, r3
 80218ea:	f000 fa7f 	bl	8021dec <RTC_Bcd2ToByte>
 80218ee:	0003      	movs	r3, r0
 80218f0:	001a      	movs	r2, r3
 80218f2:	68bb      	ldr	r3, [r7, #8]
 80218f4:	709a      	strb	r2, [r3, #2]
  }
  return HAL_OK;
 80218f6:	2300      	movs	r3, #0
}
 80218f8:	0018      	movs	r0, r3
 80218fa:	46bd      	mov	sp, r7
 80218fc:	b006      	add	sp, #24
 80218fe:	bd80      	pop	{r7, pc}
 8021900:	40002800 	.word	0x40002800
 8021904:	00ffff3f 	.word	0x00ffff3f

08021908 <HAL_RTC_SetAlarm_IT>:
  *             @arg RTC_FORMAT_BIN: Binary format
  *             @arg RTC_FORMAT_BCD: BCD format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
{
 8021908:	b590      	push	{r4, r7, lr}
 802190a:	b087      	sub	sp, #28
 802190c:	af00      	add	r7, sp, #0
 802190e:	60f8      	str	r0, [r7, #12]
 8021910:	60b9      	str	r1, [r7, #8]
 8021912:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 8021914:	2300      	movs	r3, #0
 8021916:	617b      	str	r3, [r7, #20]
  uint32_t binaryMode;

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8021918:	68fb      	ldr	r3, [r7, #12]
 802191a:	222c      	movs	r2, #44	; 0x2c
 802191c:	5c9b      	ldrb	r3, [r3, r2]
 802191e:	2b01      	cmp	r3, #1
 8021920:	d101      	bne.n	8021926 <HAL_RTC_SetAlarm_IT+0x1e>
 8021922:	2302      	movs	r3, #2
 8021924:	e0f6      	b.n	8021b14 <HAL_RTC_SetAlarm_IT+0x20c>
 8021926:	68fb      	ldr	r3, [r7, #12]
 8021928:	222c      	movs	r2, #44	; 0x2c
 802192a:	2101      	movs	r1, #1
 802192c:	5499      	strb	r1, [r3, r2]
  hrtc->State = HAL_RTC_STATE_BUSY;
 802192e:	68fb      	ldr	r3, [r7, #12]
 8021930:	222d      	movs	r2, #45	; 0x2d
 8021932:	2102      	movs	r1, #2
 8021934:	5499      	strb	r1, [r3, r2]
    assert_param((sAlarm->AlarmSubSecondMask >> RTC_ALRMASSR_MASKSS_Pos) <= (8U + (READ_BIT(RTC->ICSR, RTC_ICSR_BCDU) >> RTC_ICSR_BCDU_Pos)));
  }
#endif

  /* Get Binary mode (32-bit free-running counter configuration) */
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 8021936:	4b79      	ldr	r3, [pc, #484]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021938:	68da      	ldr	r2, [r3, #12]
 802193a:	23c0      	movs	r3, #192	; 0xc0
 802193c:	009b      	lsls	r3, r3, #2
 802193e:	4013      	ands	r3, r2
 8021940:	613b      	str	r3, [r7, #16]

  if (binaryMode != RTC_BINARY_ONLY)
 8021942:	693a      	ldr	r2, [r7, #16]
 8021944:	2380      	movs	r3, #128	; 0x80
 8021946:	005b      	lsls	r3, r3, #1
 8021948:	429a      	cmp	r2, r3
 802194a:	d065      	beq.n	8021a18 <HAL_RTC_SetAlarm_IT+0x110>
  {
    if (Format == RTC_FORMAT_BIN)
 802194c:	687b      	ldr	r3, [r7, #4]
 802194e:	2b00      	cmp	r3, #0
 8021950:	d135      	bne.n	80219be <HAL_RTC_SetAlarm_IT+0xb6>
    {
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 8021952:	4b72      	ldr	r3, [pc, #456]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021954:	699b      	ldr	r3, [r3, #24]
 8021956:	2240      	movs	r2, #64	; 0x40
 8021958:	4013      	ands	r3, r2
 802195a:	d102      	bne.n	8021962 <HAL_RTC_SetAlarm_IT+0x5a>
        assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
        assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
      }
      else
      {
        sAlarm->AlarmTime.TimeFormat = 0x00U;
 802195c:	68bb      	ldr	r3, [r7, #8]
 802195e:	2200      	movs	r2, #0
 8021960:	70da      	strb	r2, [r3, #3]
        {
          assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
        }
      }

      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8021962:	68bb      	ldr	r3, [r7, #8]
 8021964:	781b      	ldrb	r3, [r3, #0]
 8021966:	0018      	movs	r0, r3
 8021968:	f000 fa18 	bl	8021d9c <RTC_ByteToBcd2>
 802196c:	0003      	movs	r3, r0
 802196e:	041c      	lsls	r4, r3, #16
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8021970:	68bb      	ldr	r3, [r7, #8]
 8021972:	785b      	ldrb	r3, [r3, #1]
 8021974:	0018      	movs	r0, r3
 8021976:	f000 fa11 	bl	8021d9c <RTC_ByteToBcd2>
 802197a:	0003      	movs	r3, r0
 802197c:	021b      	lsls	r3, r3, #8
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 802197e:	431c      	orrs	r4, r3
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8021980:	68bb      	ldr	r3, [r7, #8]
 8021982:	789b      	ldrb	r3, [r3, #2]
 8021984:	0018      	movs	r0, r3
 8021986:	f000 fa09 	bl	8021d9c <RTC_ByteToBcd2>
 802198a:	0003      	movs	r3, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 802198c:	0022      	movs	r2, r4
 802198e:	431a      	orrs	r2, r3
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8021990:	68bb      	ldr	r3, [r7, #8]
 8021992:	78db      	ldrb	r3, [r3, #3]
 8021994:	059b      	lsls	r3, r3, #22
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8021996:	431a      	orrs	r2, r3
 8021998:	0014      	movs	r4, r2
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 802199a:	68bb      	ldr	r3, [r7, #8]
 802199c:	2224      	movs	r2, #36	; 0x24
 802199e:	5c9b      	ldrb	r3, [r3, r2]
 80219a0:	0018      	movs	r0, r3
 80219a2:	f000 f9fb 	bl	8021d9c <RTC_ByteToBcd2>
 80219a6:	0003      	movs	r3, r0
 80219a8:	061b      	lsls	r3, r3, #24
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 80219aa:	0022      	movs	r2, r4
 80219ac:	431a      	orrs	r2, r3
                ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
 80219ae:	68bb      	ldr	r3, [r7, #8]
 80219b0:	6a1b      	ldr	r3, [r3, #32]
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 80219b2:	431a      	orrs	r2, r3
                ((uint32_t)sAlarm->AlarmMask));
 80219b4:	68bb      	ldr	r3, [r7, #8]
 80219b6:	695b      	ldr	r3, [r3, #20]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80219b8:	4313      	orrs	r3, r2
 80219ba:	617b      	str	r3, [r7, #20]
 80219bc:	e02c      	b.n	8021a18 <HAL_RTC_SetAlarm_IT+0x110>
    }
    else /* Format BCD */
    {
      if( sAlarm->AlarmMask != RTC_ALARMMASK_ALL )
 80219be:	68bb      	ldr	r3, [r7, #8]
 80219c0:	695b      	ldr	r3, [r3, #20]
 80219c2:	4a57      	ldr	r2, [pc, #348]	; (8021b20 <HAL_RTC_SetAlarm_IT+0x218>)
 80219c4:	4293      	cmp	r3, r2
 80219c6:	d00d      	beq.n	80219e4 <HAL_RTC_SetAlarm_IT+0xdc>
      {
        if( sAlarm->AlarmMask != RTC_ALARMMASK_HOURS )
 80219c8:	68bb      	ldr	r3, [r7, #8]
 80219ca:	695a      	ldr	r2, [r3, #20]
 80219cc:	2380      	movs	r3, #128	; 0x80
 80219ce:	041b      	lsls	r3, r3, #16
 80219d0:	429a      	cmp	r2, r3
 80219d2:	d007      	beq.n	80219e4 <HAL_RTC_SetAlarm_IT+0xdc>
        {
          if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 80219d4:	4b51      	ldr	r3, [pc, #324]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 80219d6:	699b      	ldr	r3, [r3, #24]
 80219d8:	2240      	movs	r2, #64	; 0x40
 80219da:	4013      	ands	r3, r2
 80219dc:	d102      	bne.n	80219e4 <HAL_RTC_SetAlarm_IT+0xdc>
            assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
            assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
          }
          else
          {
            sAlarm->AlarmTime.TimeFormat = 0x00U;
 80219de:	68bb      	ldr	r3, [r7, #8]
 80219e0:	2200      	movs	r2, #0
 80219e2:	70da      	strb	r2, [r3, #3]
        {
          assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
        }
      }
#endif /* USE_FULL_ASSERT */
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80219e4:	68bb      	ldr	r3, [r7, #8]
 80219e6:	781b      	ldrb	r3, [r3, #0]
 80219e8:	041a      	lsls	r2, r3, #16
                ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 80219ea:	68bb      	ldr	r3, [r7, #8]
 80219ec:	785b      	ldrb	r3, [r3, #1]
 80219ee:	021b      	lsls	r3, r3, #8
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80219f0:	4313      	orrs	r3, r2
                ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 80219f2:	68ba      	ldr	r2, [r7, #8]
 80219f4:	7892      	ldrb	r2, [r2, #2]
                ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 80219f6:	431a      	orrs	r2, r3
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 80219f8:	68bb      	ldr	r3, [r7, #8]
 80219fa:	78db      	ldrb	r3, [r3, #3]
 80219fc:	059b      	lsls	r3, r3, #22
                ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 80219fe:	431a      	orrs	r2, r3
                ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8021a00:	68bb      	ldr	r3, [r7, #8]
 8021a02:	2124      	movs	r1, #36	; 0x24
 8021a04:	5c5b      	ldrb	r3, [r3, r1]
 8021a06:	061b      	lsls	r3, r3, #24
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8021a08:	431a      	orrs	r2, r3
                ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
 8021a0a:	68bb      	ldr	r3, [r7, #8]
 8021a0c:	6a1b      	ldr	r3, [r3, #32]
                ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8021a0e:	431a      	orrs	r2, r3
                ((uint32_t)sAlarm->AlarmMask));
 8021a10:	68bb      	ldr	r3, [r7, #8]
 8021a12:	695b      	ldr	r3, [r3, #20]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8021a14:	4313      	orrs	r3, r2
 8021a16:	617b      	str	r3, [r7, #20]

    }
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8021a18:	4b40      	ldr	r3, [pc, #256]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a1a:	22ca      	movs	r2, #202	; 0xca
 8021a1c:	625a      	str	r2, [r3, #36]	; 0x24
 8021a1e:	4b3f      	ldr	r3, [pc, #252]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a20:	2253      	movs	r2, #83	; 0x53
 8021a22:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm register */
  if (sAlarm->Alarm == RTC_ALARM_A)
 8021a24:	68bb      	ldr	r3, [r7, #8]
 8021a26:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8021a28:	2380      	movs	r3, #128	; 0x80
 8021a2a:	005b      	lsls	r3, r3, #1
 8021a2c:	429a      	cmp	r2, r3
 8021a2e:	d12e      	bne.n	8021a8e <HAL_RTC_SetAlarm_IT+0x186>
  {
    /* Disable the Alarm A interrupt */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8021a30:	4b3a      	ldr	r3, [pc, #232]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a32:	699a      	ldr	r2, [r3, #24]
 8021a34:	4b39      	ldr	r3, [pc, #228]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a36:	493b      	ldr	r1, [pc, #236]	; (8021b24 <HAL_RTC_SetAlarm_IT+0x21c>)
 8021a38:	400a      	ands	r2, r1
 8021a3a:	619a      	str	r2, [r3, #24]
    /* Clear flag alarm A */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8021a3c:	4b37      	ldr	r3, [pc, #220]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a3e:	2201      	movs	r2, #1
 8021a40:	65da      	str	r2, [r3, #92]	; 0x5c

    if (binaryMode == RTC_BINARY_ONLY)
 8021a42:	693a      	ldr	r2, [r7, #16]
 8021a44:	2380      	movs	r3, #128	; 0x80
 8021a46:	005b      	lsls	r3, r3, #1
 8021a48:	429a      	cmp	r2, r3
 8021a4a:	d107      	bne.n	8021a5c <HAL_RTC_SetAlarm_IT+0x154>
    {
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 8021a4c:	68bb      	ldr	r3, [r7, #8]
 8021a4e:	6999      	ldr	r1, [r3, #24]
 8021a50:	68bb      	ldr	r3, [r7, #8]
 8021a52:	69da      	ldr	r2, [r3, #28]
 8021a54:	4b31      	ldr	r3, [pc, #196]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a56:	430a      	orrs	r2, r1
 8021a58:	645a      	str	r2, [r3, #68]	; 0x44
 8021a5a:	e006      	b.n	8021a6a <HAL_RTC_SetAlarm_IT+0x162>
    }
    else
    {
      WRITE_REG(RTC->ALRMAR, tmpreg);
 8021a5c:	4b2f      	ldr	r3, [pc, #188]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a5e:	697a      	ldr	r2, [r7, #20]
 8021a60:	641a      	str	r2, [r3, #64]	; 0x40
      WRITE_REG(RTC->ALRMASSR, sAlarm->AlarmSubSecondMask);
 8021a62:	4a2e      	ldr	r2, [pc, #184]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a64:	68bb      	ldr	r3, [r7, #8]
 8021a66:	699b      	ldr	r3, [r3, #24]
 8021a68:	6453      	str	r3, [r2, #68]	; 0x44
    }

    WRITE_REG(RTC->ALRABINR, sAlarm->AlarmTime.SubSeconds);
 8021a6a:	4a2c      	ldr	r2, [pc, #176]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a6c:	68bb      	ldr	r3, [r7, #8]
 8021a6e:	685b      	ldr	r3, [r3, #4]
 8021a70:	6713      	str	r3, [r2, #112]	; 0x70

    /* Store in the handle the Alarm A enabled */
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8021a72:	68fb      	ldr	r3, [r7, #12]
 8021a74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021a76:	2201      	movs	r2, #1
 8021a78:	431a      	orrs	r2, r3
 8021a7a:	68fb      	ldr	r3, [r7, #12]
 8021a7c:	631a      	str	r2, [r3, #48]	; 0x30

    /* Configure the Alarm interrupt */
    SET_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8021a7e:	4b27      	ldr	r3, [pc, #156]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a80:	699a      	ldr	r2, [r3, #24]
 8021a82:	4b26      	ldr	r3, [pc, #152]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a84:	2188      	movs	r1, #136	; 0x88
 8021a86:	0149      	lsls	r1, r1, #5
 8021a88:	430a      	orrs	r2, r1
 8021a8a:	619a      	str	r2, [r3, #24]
 8021a8c:	e02d      	b.n	8021aea <HAL_RTC_SetAlarm_IT+0x1e2>
  }
  else
  {
    /* Disable the Alarm B interrupt */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8021a8e:	4b23      	ldr	r3, [pc, #140]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a90:	699a      	ldr	r2, [r3, #24]
 8021a92:	4b22      	ldr	r3, [pc, #136]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a94:	4924      	ldr	r1, [pc, #144]	; (8021b28 <HAL_RTC_SetAlarm_IT+0x220>)
 8021a96:	400a      	ands	r2, r1
 8021a98:	619a      	str	r2, [r3, #24]
    /* Clear flag alarm B */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8021a9a:	4b20      	ldr	r3, [pc, #128]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021a9c:	2202      	movs	r2, #2
 8021a9e:	65da      	str	r2, [r3, #92]	; 0x5c

    if (binaryMode == RTC_BINARY_ONLY)
 8021aa0:	693a      	ldr	r2, [r7, #16]
 8021aa2:	2380      	movs	r3, #128	; 0x80
 8021aa4:	005b      	lsls	r3, r3, #1
 8021aa6:	429a      	cmp	r2, r3
 8021aa8:	d107      	bne.n	8021aba <HAL_RTC_SetAlarm_IT+0x1b2>
    {
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 8021aaa:	68bb      	ldr	r3, [r7, #8]
 8021aac:	6999      	ldr	r1, [r3, #24]
 8021aae:	68bb      	ldr	r3, [r7, #8]
 8021ab0:	69da      	ldr	r2, [r3, #28]
 8021ab2:	4b1a      	ldr	r3, [pc, #104]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021ab4:	430a      	orrs	r2, r1
 8021ab6:	64da      	str	r2, [r3, #76]	; 0x4c
 8021ab8:	e006      	b.n	8021ac8 <HAL_RTC_SetAlarm_IT+0x1c0>
    }
    else
    {
      WRITE_REG(RTC->ALRMBR, tmpreg);
 8021aba:	4b18      	ldr	r3, [pc, #96]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021abc:	697a      	ldr	r2, [r7, #20]
 8021abe:	649a      	str	r2, [r3, #72]	; 0x48
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 8021ac0:	4a16      	ldr	r2, [pc, #88]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021ac2:	68bb      	ldr	r3, [r7, #8]
 8021ac4:	699b      	ldr	r3, [r3, #24]
 8021ac6:	64d3      	str	r3, [r2, #76]	; 0x4c
    }

    WRITE_REG(RTC->ALRBBINR, sAlarm->AlarmTime.SubSeconds);
 8021ac8:	4a14      	ldr	r2, [pc, #80]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021aca:	68bb      	ldr	r3, [r7, #8]
 8021acc:	685b      	ldr	r3, [r3, #4]
 8021ace:	6753      	str	r3, [r2, #116]	; 0x74

    /* Store in the handle the Alarm B enabled */
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8021ad0:	68fb      	ldr	r3, [r7, #12]
 8021ad2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021ad4:	2202      	movs	r2, #2
 8021ad6:	431a      	orrs	r2, r3
 8021ad8:	68fb      	ldr	r3, [r7, #12]
 8021ada:	631a      	str	r2, [r3, #48]	; 0x30

    /* Configure the Alarm interrupt */
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8021adc:	4b0f      	ldr	r3, [pc, #60]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021ade:	699a      	ldr	r2, [r3, #24]
 8021ae0:	4b0e      	ldr	r3, [pc, #56]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021ae2:	2188      	movs	r1, #136	; 0x88
 8021ae4:	0189      	lsls	r1, r1, #6
 8021ae6:	430a      	orrs	r2, r1
 8021ae8:	619a      	str	r2, [r3, #24]
  }

  /* RTC Alarm Interrupt Configuration: EXTI configuration */
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8021aea:	4a10      	ldr	r2, [pc, #64]	; (8021b2c <HAL_RTC_SetAlarm_IT+0x224>)
 8021aec:	23c0      	movs	r3, #192	; 0xc0
 8021aee:	58d3      	ldr	r3, [r2, r3]
 8021af0:	490e      	ldr	r1, [pc, #56]	; (8021b2c <HAL_RTC_SetAlarm_IT+0x224>)
 8021af2:	2280      	movs	r2, #128	; 0x80
 8021af4:	0292      	lsls	r2, r2, #10
 8021af6:	4313      	orrs	r3, r2
 8021af8:	22c0      	movs	r2, #192	; 0xc0
 8021afa:	508b      	str	r3, [r1, r2]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8021afc:	4b07      	ldr	r3, [pc, #28]	; (8021b1c <HAL_RTC_SetAlarm_IT+0x214>)
 8021afe:	22ff      	movs	r2, #255	; 0xff
 8021b00:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8021b02:	68fb      	ldr	r3, [r7, #12]
 8021b04:	222d      	movs	r2, #45	; 0x2d
 8021b06:	2101      	movs	r1, #1
 8021b08:	5499      	strb	r1, [r3, r2]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8021b0a:	68fb      	ldr	r3, [r7, #12]
 8021b0c:	222c      	movs	r2, #44	; 0x2c
 8021b0e:	2100      	movs	r1, #0
 8021b10:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 8021b12:	2300      	movs	r3, #0
}
 8021b14:	0018      	movs	r0, r3
 8021b16:	46bd      	mov	sp, r7
 8021b18:	b007      	add	sp, #28
 8021b1a:	bd90      	pop	{r4, r7, pc}
 8021b1c:	40002800 	.word	0x40002800
 8021b20:	80808080 	.word	0x80808080
 8021b24:	ffffeeff 	.word	0xffffeeff
 8021b28:	ffffddff 	.word	0xffffddff
 8021b2c:	58000800 	.word	0x58000800

08021b30 <HAL_RTC_DeactivateAlarm>:
  *            @arg RTC_ALARM_A:  AlarmA
  *            @arg RTC_ALARM_B:  AlarmB
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
{
 8021b30:	b580      	push	{r7, lr}
 8021b32:	b082      	sub	sp, #8
 8021b34:	af00      	add	r7, sp, #0
 8021b36:	6078      	str	r0, [r7, #4]
 8021b38:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8021b3a:	687b      	ldr	r3, [r7, #4]
 8021b3c:	222c      	movs	r2, #44	; 0x2c
 8021b3e:	5c9b      	ldrb	r3, [r3, r2]
 8021b40:	2b01      	cmp	r3, #1
 8021b42:	d101      	bne.n	8021b48 <HAL_RTC_DeactivateAlarm+0x18>
 8021b44:	2302      	movs	r3, #2
 8021b46:	e04b      	b.n	8021be0 <HAL_RTC_DeactivateAlarm+0xb0>
 8021b48:	687b      	ldr	r3, [r7, #4]
 8021b4a:	222c      	movs	r2, #44	; 0x2c
 8021b4c:	2101      	movs	r1, #1
 8021b4e:	5499      	strb	r1, [r3, r2]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8021b50:	687b      	ldr	r3, [r7, #4]
 8021b52:	222d      	movs	r2, #45	; 0x2d
 8021b54:	2102      	movs	r1, #2
 8021b56:	5499      	strb	r1, [r3, r2]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8021b58:	4b23      	ldr	r3, [pc, #140]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021b5a:	22ca      	movs	r2, #202	; 0xca
 8021b5c:	625a      	str	r2, [r3, #36]	; 0x24
 8021b5e:	4b22      	ldr	r3, [pc, #136]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021b60:	2253      	movs	r2, #83	; 0x53
 8021b62:	625a      	str	r2, [r3, #36]	; 0x24

  if (Alarm == RTC_ALARM_A)
 8021b64:	683a      	ldr	r2, [r7, #0]
 8021b66:	2380      	movs	r3, #128	; 0x80
 8021b68:	005b      	lsls	r3, r3, #1
 8021b6a:	429a      	cmp	r2, r3
 8021b6c:	d116      	bne.n	8021b9c <HAL_RTC_DeactivateAlarm+0x6c>
  {
    /* AlarmA, In case of interrupt mode is used, the interrupt source must disabled */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8021b6e:	4b1e      	ldr	r3, [pc, #120]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021b70:	699a      	ldr	r2, [r3, #24]
 8021b72:	4b1d      	ldr	r3, [pc, #116]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021b74:	491d      	ldr	r1, [pc, #116]	; (8021bec <HAL_RTC_DeactivateAlarm+0xbc>)
 8021b76:	400a      	ands	r2, r1
 8021b78:	619a      	str	r2, [r3, #24]

    /* AlarmA, Clear SSCLR */
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 8021b7a:	4b1b      	ldr	r3, [pc, #108]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021b7c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8021b7e:	4b1a      	ldr	r3, [pc, #104]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021b80:	0052      	lsls	r2, r2, #1
 8021b82:	0852      	lsrs	r2, r2, #1
 8021b84:	645a      	str	r2, [r3, #68]	; 0x44

    /* Store in the handle the Alarm A disabled */
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8021b86:	687b      	ldr	r3, [r7, #4]
 8021b88:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021b8a:	2201      	movs	r2, #1
 8021b8c:	4393      	bics	r3, r2
 8021b8e:	001a      	movs	r2, r3
 8021b90:	687b      	ldr	r3, [r7, #4]
 8021b92:	631a      	str	r2, [r3, #48]	; 0x30

    /* Clear AlarmA flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8021b94:	4b14      	ldr	r3, [pc, #80]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021b96:	2201      	movs	r2, #1
 8021b98:	65da      	str	r2, [r3, #92]	; 0x5c
 8021b9a:	e015      	b.n	8021bc8 <HAL_RTC_DeactivateAlarm+0x98>
  }
  else
  {
    /* AlarmB, In case of interrupt mode is used, the interrupt source must disabled */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8021b9c:	4b12      	ldr	r3, [pc, #72]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021b9e:	699a      	ldr	r2, [r3, #24]
 8021ba0:	4b11      	ldr	r3, [pc, #68]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021ba2:	4913      	ldr	r1, [pc, #76]	; (8021bf0 <HAL_RTC_DeactivateAlarm+0xc0>)
 8021ba4:	400a      	ands	r2, r1
 8021ba6:	619a      	str	r2, [r3, #24]

    /* AlarmB, Clear SSCLR */
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 8021ba8:	4b0f      	ldr	r3, [pc, #60]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021baa:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8021bac:	4b0e      	ldr	r3, [pc, #56]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021bae:	0052      	lsls	r2, r2, #1
 8021bb0:	0852      	lsrs	r2, r2, #1
 8021bb2:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Store in the handle the Alarm B disabled */
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8021bb4:	687b      	ldr	r3, [r7, #4]
 8021bb6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021bb8:	2202      	movs	r2, #2
 8021bba:	4393      	bics	r3, r2
 8021bbc:	001a      	movs	r2, r3
 8021bbe:	687b      	ldr	r3, [r7, #4]
 8021bc0:	631a      	str	r2, [r3, #48]	; 0x30

    /* Clear AlarmB flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8021bc2:	4b09      	ldr	r3, [pc, #36]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021bc4:	2202      	movs	r2, #2
 8021bc6:	65da      	str	r2, [r3, #92]	; 0x5c
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8021bc8:	4b07      	ldr	r3, [pc, #28]	; (8021be8 <HAL_RTC_DeactivateAlarm+0xb8>)
 8021bca:	22ff      	movs	r2, #255	; 0xff
 8021bcc:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8021bce:	687b      	ldr	r3, [r7, #4]
 8021bd0:	222d      	movs	r2, #45	; 0x2d
 8021bd2:	2101      	movs	r1, #1
 8021bd4:	5499      	strb	r1, [r3, r2]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8021bd6:	687b      	ldr	r3, [r7, #4]
 8021bd8:	222c      	movs	r2, #44	; 0x2c
 8021bda:	2100      	movs	r1, #0
 8021bdc:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 8021bde:	2300      	movs	r3, #0
}
 8021be0:	0018      	movs	r0, r3
 8021be2:	46bd      	mov	sp, r7
 8021be4:	b002      	add	sp, #8
 8021be6:	bd80      	pop	{r7, pc}
 8021be8:	40002800 	.word	0x40002800
 8021bec:	ffffeeff 	.word	0xffffeeff
 8021bf0:	ffffddff 	.word	0xffffddff

08021bf4 <HAL_RTC_AlarmIRQHandler>:
  * @brief  Handle Alarm interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
{
 8021bf4:	b580      	push	{r7, lr}
 8021bf6:	b084      	sub	sp, #16
 8021bf8:	af00      	add	r7, sp, #0
 8021bfa:	6078      	str	r0, [r7, #4]
  uint32_t tmp = READ_REG(RTC->MISR) & READ_REG(hrtc->IsEnabled.RtcFeatures);
 8021bfc:	4b11      	ldr	r3, [pc, #68]	; (8021c44 <HAL_RTC_AlarmIRQHandler+0x50>)
 8021bfe:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8021c00:	687b      	ldr	r3, [r7, #4]
 8021c02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021c04:	4013      	ands	r3, r2
 8021c06:	60fb      	str	r3, [r7, #12]

  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 8021c08:	68fb      	ldr	r3, [r7, #12]
 8021c0a:	2201      	movs	r2, #1
 8021c0c:	4013      	ands	r3, r2
 8021c0e:	d006      	beq.n	8021c1e <HAL_RTC_AlarmIRQHandler+0x2a>
  {
    /* Clear the AlarmA interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8021c10:	4b0c      	ldr	r3, [pc, #48]	; (8021c44 <HAL_RTC_AlarmIRQHandler+0x50>)
 8021c12:	2201      	movs	r2, #1
 8021c14:	65da      	str	r2, [r3, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmAEventCallback(hrtc);
#else
    HAL_RTC_AlarmAEventCallback(hrtc);
 8021c16:	687b      	ldr	r3, [r7, #4]
 8021c18:	0018      	movs	r0, r3
 8021c1a:	f7fe fc07 	bl	802042c <HAL_RTC_AlarmAEventCallback>
#endif
  }

  if ((tmp & RTC_MISR_ALRBMF) != 0U)
 8021c1e:	68fb      	ldr	r3, [r7, #12]
 8021c20:	2202      	movs	r2, #2
 8021c22:	4013      	ands	r3, r2
 8021c24:	d006      	beq.n	8021c34 <HAL_RTC_AlarmIRQHandler+0x40>
  {
    /* Clear the AlarmB interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8021c26:	4b07      	ldr	r3, [pc, #28]	; (8021c44 <HAL_RTC_AlarmIRQHandler+0x50>)
 8021c28:	2202      	movs	r2, #2
 8021c2a:	65da      	str	r2, [r3, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmBEventCallback(hrtc);
#else
    HAL_RTCEx_AlarmBEventCallback(hrtc);
 8021c2c:	687b      	ldr	r3, [r7, #4]
 8021c2e:	0018      	movs	r0, r3
 8021c30:	f000 f8f9 	bl	8021e26 <HAL_RTCEx_AlarmBEventCallback>
#endif
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8021c34:	687b      	ldr	r3, [r7, #4]
 8021c36:	222d      	movs	r2, #45	; 0x2d
 8021c38:	2101      	movs	r1, #1
 8021c3a:	5499      	strb	r1, [r3, r2]
}
 8021c3c:	46c0      	nop			; (mov r8, r8)
 8021c3e:	46bd      	mov	sp, r7
 8021c40:	b004      	add	sp, #16
 8021c42:	bd80      	pop	{r7, pc}
 8021c44:	40002800 	.word	0x40002800

08021c48 <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 8021c48:	b580      	push	{r7, lr}
 8021c4a:	b084      	sub	sp, #16
 8021c4c:	af00      	add	r7, sp, #0
 8021c4e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  UNUSED(hrtc);
  /* Clear RSF flag */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 8021c50:	4b0f      	ldr	r3, [pc, #60]	; (8021c90 <HAL_RTC_WaitForSynchro+0x48>)
 8021c52:	68da      	ldr	r2, [r3, #12]
 8021c54:	4b0e      	ldr	r3, [pc, #56]	; (8021c90 <HAL_RTC_WaitForSynchro+0x48>)
 8021c56:	2120      	movs	r1, #32
 8021c58:	438a      	bics	r2, r1
 8021c5a:	60da      	str	r2, [r3, #12]

  tickstart = HAL_GetTick();
 8021c5c:	f7fe fd24 	bl	80206a8 <HAL_GetTick>
 8021c60:	0003      	movs	r3, r0
 8021c62:	60fb      	str	r3, [r7, #12]

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 8021c64:	e00a      	b.n	8021c7c <HAL_RTC_WaitForSynchro+0x34>
  {
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8021c66:	f7fe fd1f 	bl	80206a8 <HAL_GetTick>
 8021c6a:	0002      	movs	r2, r0
 8021c6c:	68fb      	ldr	r3, [r7, #12]
 8021c6e:	1ad2      	subs	r2, r2, r3
 8021c70:	23fa      	movs	r3, #250	; 0xfa
 8021c72:	009b      	lsls	r3, r3, #2
 8021c74:	429a      	cmp	r2, r3
 8021c76:	d901      	bls.n	8021c7c <HAL_RTC_WaitForSynchro+0x34>
    {
      return HAL_TIMEOUT;
 8021c78:	2303      	movs	r3, #3
 8021c7a:	e005      	b.n	8021c88 <HAL_RTC_WaitForSynchro+0x40>
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 8021c7c:	4b04      	ldr	r3, [pc, #16]	; (8021c90 <HAL_RTC_WaitForSynchro+0x48>)
 8021c7e:	68db      	ldr	r3, [r3, #12]
 8021c80:	2220      	movs	r2, #32
 8021c82:	4013      	ands	r3, r2
 8021c84:	d0ef      	beq.n	8021c66 <HAL_RTC_WaitForSynchro+0x1e>
    }
  }

  return HAL_OK;
 8021c86:	2300      	movs	r3, #0
}
 8021c88:	0018      	movs	r0, r3
 8021c8a:	46bd      	mov	sp, r7
 8021c8c:	b004      	add	sp, #16
 8021c8e:	bd80      	pop	{r7, pc}
 8021c90:	40002800 	.word	0x40002800

08021c94 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 8021c94:	b580      	push	{r7, lr}
 8021c96:	b084      	sub	sp, #16
 8021c98:	af00      	add	r7, sp, #0
 8021c9a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 8021c9c:	230f      	movs	r3, #15
 8021c9e:	18fb      	adds	r3, r7, r3
 8021ca0:	2200      	movs	r2, #0
 8021ca2:	701a      	strb	r2, [r3, #0]

  UNUSED(hrtc);
  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 8021ca4:	4b1a      	ldr	r3, [pc, #104]	; (8021d10 <RTC_EnterInitMode+0x7c>)
 8021ca6:	68db      	ldr	r3, [r3, #12]
 8021ca8:	2240      	movs	r2, #64	; 0x40
 8021caa:	4013      	ands	r3, r2
 8021cac:	d129      	bne.n	8021d02 <RTC_EnterInitMode+0x6e>
  {
    /* Set the Initialization mode */
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8021cae:	4b18      	ldr	r3, [pc, #96]	; (8021d10 <RTC_EnterInitMode+0x7c>)
 8021cb0:	68da      	ldr	r2, [r3, #12]
 8021cb2:	4b17      	ldr	r3, [pc, #92]	; (8021d10 <RTC_EnterInitMode+0x7c>)
 8021cb4:	2180      	movs	r1, #128	; 0x80
 8021cb6:	430a      	orrs	r2, r1
 8021cb8:	60da      	str	r2, [r3, #12]

    tickstart = HAL_GetTick();
 8021cba:	f7fe fcf5 	bl	80206a8 <HAL_GetTick>
 8021cbe:	0003      	movs	r3, r0
 8021cc0:	60bb      	str	r3, [r7, #8]
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8021cc2:	e014      	b.n	8021cee <RTC_EnterInitMode+0x5a>
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 8021cc4:	f7fe fcf0 	bl	80206a8 <HAL_GetTick>
 8021cc8:	0002      	movs	r2, r0
 8021cca:	68bb      	ldr	r3, [r7, #8]
 8021ccc:	1ad2      	subs	r2, r2, r3
 8021cce:	200f      	movs	r0, #15
 8021cd0:	183b      	adds	r3, r7, r0
 8021cd2:	1839      	adds	r1, r7, r0
 8021cd4:	7809      	ldrb	r1, [r1, #0]
 8021cd6:	7019      	strb	r1, [r3, #0]
 8021cd8:	23fa      	movs	r3, #250	; 0xfa
 8021cda:	009b      	lsls	r3, r3, #2
 8021cdc:	429a      	cmp	r2, r3
 8021cde:	d906      	bls.n	8021cee <RTC_EnterInitMode+0x5a>
      {
        status = HAL_TIMEOUT;
 8021ce0:	183b      	adds	r3, r7, r0
 8021ce2:	2203      	movs	r2, #3
 8021ce4:	701a      	strb	r2, [r3, #0]
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8021ce6:	687b      	ldr	r3, [r7, #4]
 8021ce8:	222d      	movs	r2, #45	; 0x2d
 8021cea:	2103      	movs	r1, #3
 8021cec:	5499      	strb	r1, [r3, r2]
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8021cee:	4b08      	ldr	r3, [pc, #32]	; (8021d10 <RTC_EnterInitMode+0x7c>)
 8021cf0:	68db      	ldr	r3, [r3, #12]
 8021cf2:	2240      	movs	r2, #64	; 0x40
 8021cf4:	4013      	ands	r3, r2
 8021cf6:	d104      	bne.n	8021d02 <RTC_EnterInitMode+0x6e>
 8021cf8:	230f      	movs	r3, #15
 8021cfa:	18fb      	adds	r3, r7, r3
 8021cfc:	781b      	ldrb	r3, [r3, #0]
 8021cfe:	2b03      	cmp	r3, #3
 8021d00:	d1e0      	bne.n	8021cc4 <RTC_EnterInitMode+0x30>
      }
    }
  }

  return status;
 8021d02:	230f      	movs	r3, #15
 8021d04:	18fb      	adds	r3, r7, r3
 8021d06:	781b      	ldrb	r3, [r3, #0]
}
 8021d08:	0018      	movs	r0, r3
 8021d0a:	46bd      	mov	sp, r7
 8021d0c:	b004      	add	sp, #16
 8021d0e:	bd80      	pop	{r7, pc}
 8021d10:	40002800 	.word	0x40002800

08021d14 <RTC_ExitInitMode>:
  * @brief  Exit the RTC Initialization mode.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
 8021d14:	b590      	push	{r4, r7, lr}
 8021d16:	b085      	sub	sp, #20
 8021d18:	af00      	add	r7, sp, #0
 8021d1a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8021d1c:	240f      	movs	r4, #15
 8021d1e:	193b      	adds	r3, r7, r4
 8021d20:	2200      	movs	r2, #0
 8021d22:	701a      	strb	r2, [r3, #0]

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8021d24:	4b1c      	ldr	r3, [pc, #112]	; (8021d98 <RTC_ExitInitMode+0x84>)
 8021d26:	68da      	ldr	r2, [r3, #12]
 8021d28:	4b1b      	ldr	r3, [pc, #108]	; (8021d98 <RTC_ExitInitMode+0x84>)
 8021d2a:	2180      	movs	r1, #128	; 0x80
 8021d2c:	438a      	bics	r2, r1
 8021d2e:	60da      	str	r2, [r3, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 8021d30:	4b19      	ldr	r3, [pc, #100]	; (8021d98 <RTC_ExitInitMode+0x84>)
 8021d32:	699b      	ldr	r3, [r3, #24]
 8021d34:	2220      	movs	r2, #32
 8021d36:	4013      	ands	r3, r2
 8021d38:	d10d      	bne.n	8021d56 <RTC_ExitInitMode+0x42>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8021d3a:	687b      	ldr	r3, [r7, #4]
 8021d3c:	0018      	movs	r0, r3
 8021d3e:	f7ff ff83 	bl	8021c48 <HAL_RTC_WaitForSynchro>
 8021d42:	1e03      	subs	r3, r0, #0
 8021d44:	d021      	beq.n	8021d8a <RTC_ExitInitMode+0x76>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8021d46:	687b      	ldr	r3, [r7, #4]
 8021d48:	222d      	movs	r2, #45	; 0x2d
 8021d4a:	2103      	movs	r1, #3
 8021d4c:	5499      	strb	r1, [r3, r2]
      status = HAL_TIMEOUT;
 8021d4e:	193b      	adds	r3, r7, r4
 8021d50:	2203      	movs	r2, #3
 8021d52:	701a      	strb	r2, [r3, #0]
 8021d54:	e019      	b.n	8021d8a <RTC_ExitInitMode+0x76>
    }
  }
  else /* WA 2.9.6 Calendar initialization may fail in case of consecutive INIT mode entry. */
  {
    /* Clear BYPSHAD bit */
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8021d56:	4b10      	ldr	r3, [pc, #64]	; (8021d98 <RTC_ExitInitMode+0x84>)
 8021d58:	699a      	ldr	r2, [r3, #24]
 8021d5a:	4b0f      	ldr	r3, [pc, #60]	; (8021d98 <RTC_ExitInitMode+0x84>)
 8021d5c:	2120      	movs	r1, #32
 8021d5e:	438a      	bics	r2, r1
 8021d60:	619a      	str	r2, [r3, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8021d62:	687b      	ldr	r3, [r7, #4]
 8021d64:	0018      	movs	r0, r3
 8021d66:	f7ff ff6f 	bl	8021c48 <HAL_RTC_WaitForSynchro>
 8021d6a:	1e03      	subs	r3, r0, #0
 8021d6c:	d007      	beq.n	8021d7e <RTC_ExitInitMode+0x6a>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8021d6e:	687b      	ldr	r3, [r7, #4]
 8021d70:	222d      	movs	r2, #45	; 0x2d
 8021d72:	2103      	movs	r1, #3
 8021d74:	5499      	strb	r1, [r3, r2]
      status = HAL_TIMEOUT;
 8021d76:	230f      	movs	r3, #15
 8021d78:	18fb      	adds	r3, r7, r3
 8021d7a:	2203      	movs	r2, #3
 8021d7c:	701a      	strb	r2, [r3, #0]
    }
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8021d7e:	4b06      	ldr	r3, [pc, #24]	; (8021d98 <RTC_ExitInitMode+0x84>)
 8021d80:	699a      	ldr	r2, [r3, #24]
 8021d82:	4b05      	ldr	r3, [pc, #20]	; (8021d98 <RTC_ExitInitMode+0x84>)
 8021d84:	2120      	movs	r1, #32
 8021d86:	430a      	orrs	r2, r1
 8021d88:	619a      	str	r2, [r3, #24]
  }

  return status;
 8021d8a:	230f      	movs	r3, #15
 8021d8c:	18fb      	adds	r3, r7, r3
 8021d8e:	781b      	ldrb	r3, [r3, #0]
}
 8021d90:	0018      	movs	r0, r3
 8021d92:	46bd      	mov	sp, r7
 8021d94:	b005      	add	sp, #20
 8021d96:	bd90      	pop	{r4, r7, pc}
 8021d98:	40002800 	.word	0x40002800

08021d9c <RTC_ByteToBcd2>:
  * @brief  Convert a 2 digit decimal to BCD format.
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
 8021d9c:	b580      	push	{r7, lr}
 8021d9e:	b084      	sub	sp, #16
 8021da0:	af00      	add	r7, sp, #0
 8021da2:	0002      	movs	r2, r0
 8021da4:	1dfb      	adds	r3, r7, #7
 8021da6:	701a      	strb	r2, [r3, #0]
  uint32_t bcdhigh = 0U;
 8021da8:	2300      	movs	r3, #0
 8021daa:	60fb      	str	r3, [r7, #12]
  uint8_t tmp_Value = Value;
 8021dac:	230b      	movs	r3, #11
 8021dae:	18fb      	adds	r3, r7, r3
 8021db0:	1dfa      	adds	r2, r7, #7
 8021db2:	7812      	ldrb	r2, [r2, #0]
 8021db4:	701a      	strb	r2, [r3, #0]

  while (tmp_Value >= 10U)
 8021db6:	e008      	b.n	8021dca <RTC_ByteToBcd2+0x2e>
  {
    bcdhigh++;
 8021db8:	68fb      	ldr	r3, [r7, #12]
 8021dba:	3301      	adds	r3, #1
 8021dbc:	60fb      	str	r3, [r7, #12]
    tmp_Value -= 10U;
 8021dbe:	220b      	movs	r2, #11
 8021dc0:	18bb      	adds	r3, r7, r2
 8021dc2:	18ba      	adds	r2, r7, r2
 8021dc4:	7812      	ldrb	r2, [r2, #0]
 8021dc6:	3a0a      	subs	r2, #10
 8021dc8:	701a      	strb	r2, [r3, #0]
  while (tmp_Value >= 10U)
 8021dca:	210b      	movs	r1, #11
 8021dcc:	187b      	adds	r3, r7, r1
 8021dce:	781b      	ldrb	r3, [r3, #0]
 8021dd0:	2b09      	cmp	r3, #9
 8021dd2:	d8f1      	bhi.n	8021db8 <RTC_ByteToBcd2+0x1c>
  }

  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 8021dd4:	68fb      	ldr	r3, [r7, #12]
 8021dd6:	b2db      	uxtb	r3, r3
 8021dd8:	011b      	lsls	r3, r3, #4
 8021dda:	b2da      	uxtb	r2, r3
 8021ddc:	187b      	adds	r3, r7, r1
 8021dde:	781b      	ldrb	r3, [r3, #0]
 8021de0:	4313      	orrs	r3, r2
 8021de2:	b2db      	uxtb	r3, r3
}
 8021de4:	0018      	movs	r0, r3
 8021de6:	46bd      	mov	sp, r7
 8021de8:	b004      	add	sp, #16
 8021dea:	bd80      	pop	{r7, pc}

08021dec <RTC_Bcd2ToByte>:
  * @brief  Convert from 2 digit BCD to Binary.
  * @param  Value BCD value to be converted
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
 8021dec:	b580      	push	{r7, lr}
 8021dee:	b084      	sub	sp, #16
 8021df0:	af00      	add	r7, sp, #0
 8021df2:	0002      	movs	r2, r0
 8021df4:	1dfb      	adds	r3, r7, #7
 8021df6:	701a      	strb	r2, [r3, #0]
  uint32_t tmp;
  tmp = (((uint32_t)Value & 0xF0U) >> 4) * 10U;
 8021df8:	1dfb      	adds	r3, r7, #7
 8021dfa:	781b      	ldrb	r3, [r3, #0]
 8021dfc:	091b      	lsrs	r3, r3, #4
 8021dfe:	b2db      	uxtb	r3, r3
 8021e00:	001a      	movs	r2, r3
 8021e02:	0013      	movs	r3, r2
 8021e04:	009b      	lsls	r3, r3, #2
 8021e06:	189b      	adds	r3, r3, r2
 8021e08:	005b      	lsls	r3, r3, #1
 8021e0a:	60fb      	str	r3, [r7, #12]
  return (uint8_t)(tmp + ((uint32_t)Value & 0x0FU));
 8021e0c:	68fb      	ldr	r3, [r7, #12]
 8021e0e:	b2da      	uxtb	r2, r3
 8021e10:	1dfb      	adds	r3, r7, #7
 8021e12:	781b      	ldrb	r3, [r3, #0]
 8021e14:	210f      	movs	r1, #15
 8021e16:	400b      	ands	r3, r1
 8021e18:	b2db      	uxtb	r3, r3
 8021e1a:	18d3      	adds	r3, r2, r3
 8021e1c:	b2db      	uxtb	r3, r3
}
 8021e1e:	0018      	movs	r0, r3
 8021e20:	46bd      	mov	sp, r7
 8021e22:	b004      	add	sp, #16
 8021e24:	bd80      	pop	{r7, pc}

08021e26 <HAL_RTCEx_AlarmBEventCallback>:
  * @brief  Alarm B callback.
  * @param  hrtc RTC handle
  * @retval None
  */
__weak void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)
{
 8021e26:	b580      	push	{r7, lr}
 8021e28:	b082      	sub	sp, #8
 8021e2a:	af00      	add	r7, sp, #0
 8021e2c:	6078      	str	r0, [r7, #4]
  UNUSED(hrtc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_RTCEx_AlarmBEventCallback could be implemented in the user file
   */
}
 8021e2e:	46c0      	nop			; (mov r8, r8)
 8021e30:	46bd      	mov	sp, r7
 8021e32:	b002      	add	sp, #8
 8021e34:	bd80      	pop	{r7, pc}
	...

08021e38 <calendar_init>:
 * this module.
 *
 * Note: will not reinitialize/reset if already initialized.
 */
CalendarStatus calendar_init(RTC_HandleTypeDef* hrtc)
{
 8021e38:	b580      	push	{r7, lr}
 8021e3a:	b082      	sub	sp, #8
 8021e3c:	af00      	add	r7, sp, #0
 8021e3e:	6078      	str	r0, [r7, #4]
	// check for pointer to initialized RTC handle
	if (hrtc != NULL && hrtc->Instance != NULL)
 8021e40:	687b      	ldr	r3, [r7, #4]
 8021e42:	2b00      	cmp	r3, #0
 8021e44:	d017      	beq.n	8021e76 <calendar_init+0x3e>
 8021e46:	687b      	ldr	r3, [r7, #4]
 8021e48:	681b      	ldr	r3, [r3, #0]
 8021e4a:	2b00      	cmp	r3, #0
 8021e4c:	d013      	beq.n	8021e76 <calendar_init+0x3e>
	{
		// initialize only if not already initialized
		if (!_isInit)
 8021e4e:	4b0c      	ldr	r3, [pc, #48]	; (8021e80 <calendar_init+0x48>)
 8021e50:	781b      	ldrb	r3, [r3, #0]
 8021e52:	2201      	movs	r2, #1
 8021e54:	4053      	eors	r3, r2
 8021e56:	b2db      	uxtb	r3, r3
 8021e58:	2b00      	cmp	r3, #0
 8021e5a:	d00a      	beq.n	8021e72 <calendar_init+0x3a>
		{
			// pass pointer to alarm control
			rtcCalendarControl_init(hrtc);
 8021e5c:	687b      	ldr	r3, [r7, #4]
 8021e5e:	0018      	movs	r0, r3
 8021e60:	f000 fc0a 	bl	8022678 <rtcCalendarControl_init>

			// initialize the calendar
			eventSLL_reset(&_eventQueue);
 8021e64:	4b07      	ldr	r3, [pc, #28]	; (8021e84 <calendar_init+0x4c>)
 8021e66:	0018      	movs	r0, r3
 8021e68:	f000 f93c 	bl	80220e4 <eventSLL_reset>

			// set init flag
			_isInit = true;
 8021e6c:	4b04      	ldr	r3, [pc, #16]	; (8021e80 <calendar_init+0x48>)
 8021e6e:	2201      	movs	r2, #1
 8021e70:	701a      	strb	r2, [r3, #0]
		}

		return CALENDAR_OKAY;
 8021e72:	2300      	movs	r3, #0
 8021e74:	e000      	b.n	8021e78 <calendar_init+0x40>
	}

	// module already initialized
	else
	{
		return CALENDAR_PARAMETER_ERROR;
 8021e76:	2301      	movs	r3, #1
	}
}
 8021e78:	0018      	movs	r0, r3
 8021e7a:	46bd      	mov	sp, r7
 8021e7c:	b002      	add	sp, #8
 8021e7e:	bd80      	pop	{r7, pc}
 8021e80:	20008064 	.word	0x20008064
 8021e84:	20008068 	.word	0x20008068

08021e88 <calendar_startScheduler>:
 * and sets RTC Alarm A for the next event transition (start or end of event).
 * Executes start of event callback if starting within an event.  Ignores past
 * events.
 */
CalendarStatus calendar_startScheduler(void)
{
 8021e88:	b580      	push	{r7, lr}
 8021e8a:	af00      	add	r7, sp, #0
	// if the module has been initialized
	if (_isInit)
 8021e8c:	4b0b      	ldr	r3, [pc, #44]	; (8021ebc <calendar_startScheduler+0x34>)
 8021e8e:	781b      	ldrb	r3, [r3, #0]
 8021e90:	2b00      	cmp	r3, #0
 8021e92:	d00f      	beq.n	8021eb4 <calendar_startScheduler+0x2c>
	{
		// only start if the calendar has been paused
		if (!_isRunning)
 8021e94:	4b0a      	ldr	r3, [pc, #40]	; (8021ec0 <calendar_startScheduler+0x38>)
 8021e96:	781b      	ldrb	r3, [r3, #0]
 8021e98:	2201      	movs	r2, #1
 8021e9a:	4053      	eors	r3, r2
 8021e9c:	b2db      	uxtb	r3, r3
 8021e9e:	2b00      	cmp	r3, #0
 8021ea0:	d006      	beq.n	8021eb0 <calendar_startScheduler+0x28>
		{
			_update();
 8021ea2:	f000 f8a3 	bl	8021fec <_update>

			// set is running flag
			_isRunning = true;
 8021ea6:	4b06      	ldr	r3, [pc, #24]	; (8021ec0 <calendar_startScheduler+0x38>)
 8021ea8:	2201      	movs	r2, #1
 8021eaa:	701a      	strb	r2, [r3, #0]

			return CALENDAR_OKAY;
 8021eac:	2300      	movs	r3, #0
 8021eae:	e002      	b.n	8021eb6 <calendar_startScheduler+0x2e>
		}

		// report that the calendar is already running
		else
		{
			return CALENDAR_RUNNING;
 8021eb0:	2305      	movs	r3, #5
 8021eb2:	e000      	b.n	8021eb6 <calendar_startScheduler+0x2e>
	}

	// module is not initialized
	else
	{
		return CALENDAR_NOT_INIT;
 8021eb4:	2302      	movs	r3, #2
	}
}
 8021eb6:	0018      	movs	r0, r3
 8021eb8:	46bd      	mov	sp, r7
 8021eba:	bd80      	pop	{r7, pc}
 8021ebc:	20008064 	.word	0x20008064
 8021ec0:	20008065 	.word	0x20008065

08021ec4 <calendar_setDateTime>:
/* calendar_setDateTime
 *
 * Set the date/time within the RTC.
 */
CalendarStatus calendar_setDateTime(const DateTime dateTime)
{
 8021ec4:	b5b0      	push	{r4, r5, r7, lr}
 8021ec6:	b084      	sub	sp, #16
 8021ec8:	af02      	add	r7, sp, #8
 8021eca:	003b      	movs	r3, r7
 8021ecc:	6018      	str	r0, [r3, #0]
 8021ece:	6059      	str	r1, [r3, #4]
	// if the module has been initialized
	if (_isInit)
 8021ed0:	4b12      	ldr	r3, [pc, #72]	; (8021f1c <calendar_setDateTime+0x58>)
 8021ed2:	781b      	ldrb	r3, [r3, #0]
 8021ed4:	2b00      	cmp	r3, #0
 8021ed6:	d01c      	beq.n	8021f12 <calendar_setDateTime+0x4e>
	{
		// if the calendar is paused
		if (!_isRunning)
 8021ed8:	4b11      	ldr	r3, [pc, #68]	; (8021f20 <calendar_setDateTime+0x5c>)
 8021eda:	781b      	ldrb	r3, [r3, #0]
 8021edc:	2201      	movs	r2, #1
 8021ede:	4053      	eors	r3, r2
 8021ee0:	b2db      	uxtb	r3, r3
 8021ee2:	2b00      	cmp	r3, #0
 8021ee4:	d013      	beq.n	8021f0e <calendar_setDateTime+0x4a>
		{
			// set the date and time in the RTC
			rtcCalendarControl_setDateTime(dateTime.year, dateTime.month, dateTime.day,
 8021ee6:	003b      	movs	r3, r7
 8021ee8:	7818      	ldrb	r0, [r3, #0]
 8021eea:	003b      	movs	r3, r7
 8021eec:	7859      	ldrb	r1, [r3, #1]
 8021eee:	003b      	movs	r3, r7
 8021ef0:	789c      	ldrb	r4, [r3, #2]
 8021ef2:	003b      	movs	r3, r7
 8021ef4:	78dd      	ldrb	r5, [r3, #3]
 8021ef6:	003b      	movs	r3, r7
 8021ef8:	791b      	ldrb	r3, [r3, #4]
 8021efa:	003a      	movs	r2, r7
 8021efc:	7952      	ldrb	r2, [r2, #5]
 8021efe:	9201      	str	r2, [sp, #4]
 8021f00:	9300      	str	r3, [sp, #0]
 8021f02:	002b      	movs	r3, r5
 8021f04:	0022      	movs	r2, r4
 8021f06:	f000 fbd1 	bl	80226ac <rtcCalendarControl_setDateTime>
					dateTime.hour, dateTime.minute, dateTime.second);

			return CALENDAR_OKAY;
 8021f0a:	2300      	movs	r3, #0
 8021f0c:	e002      	b.n	8021f14 <calendar_setDateTime+0x50>
		}

		else
		{
			return CALENDAR_RUNNING;
 8021f0e:	2305      	movs	r3, #5
 8021f10:	e000      	b.n	8021f14 <calendar_setDateTime+0x50>
	}

	// if the module has not been initialized
	else
	{
		return CALENDAR_NOT_INIT;
 8021f12:	2302      	movs	r3, #2
	}
}
 8021f14:	0018      	movs	r0, r3
 8021f16:	46bd      	mov	sp, r7
 8021f18:	b002      	add	sp, #8
 8021f1a:	bdb0      	pop	{r4, r5, r7, pc}
 8021f1c:	20008064 	.word	0x20008064
 8021f20:	20008065 	.word	0x20008065

08021f24 <calendar_addEvent>:
/* calendar_addEvent
 *
 * Add an event to the calendar's event linked list.
 */
CalendarStatus calendar_addEvent(const struct CalendarEvent event)
{
 8021f24:	b084      	sub	sp, #16
 8021f26:	b5b0      	push	{r4, r5, r7, lr}
 8021f28:	b082      	sub	sp, #8
 8021f2a:	af02      	add	r7, sp, #8
 8021f2c:	2510      	movs	r5, #16
 8021f2e:	197c      	adds	r4, r7, r5
 8021f30:	6020      	str	r0, [r4, #0]
 8021f32:	6061      	str	r1, [r4, #4]
 8021f34:	60a2      	str	r2, [r4, #8]
 8021f36:	60e3      	str	r3, [r4, #12]
	// add only if the calendar has been initialized
	if (_isInit)
 8021f38:	4b13      	ldr	r3, [pc, #76]	; (8021f88 <calendar_addEvent+0x64>)
 8021f3a:	781b      	ldrb	r3, [r3, #0]
 8021f3c:	2b00      	cmp	r3, #0
 8021f3e:	d01b      	beq.n	8021f78 <calendar_addEvent+0x54>
	{
		// if the calendar is paused
		if (!_isRunning)
 8021f40:	4b12      	ldr	r3, [pc, #72]	; (8021f8c <calendar_addEvent+0x68>)
 8021f42:	781b      	ldrb	r3, [r3, #0]
 8021f44:	2201      	movs	r2, #1
 8021f46:	4053      	eors	r3, r2
 8021f48:	b2db      	uxtb	r3, r3
 8021f4a:	2b00      	cmp	r3, #0
 8021f4c:	d012      	beq.n	8021f74 <calendar_addEvent+0x50>
		{
			// attempt to add event and report success/failure
			if (eventSLL_insert(&_eventQueue, event))
 8021f4e:	197b      	adds	r3, r7, r5
 8021f50:	480f      	ldr	r0, [pc, #60]	; (8021f90 <calendar_addEvent+0x6c>)
 8021f52:	466a      	mov	r2, sp
 8021f54:	0011      	movs	r1, r2
 8021f56:	001a      	movs	r2, r3
 8021f58:	320c      	adds	r2, #12
 8021f5a:	ca30      	ldmia	r2!, {r4, r5}
 8021f5c:	c130      	stmia	r1!, {r4, r5}
 8021f5e:	6819      	ldr	r1, [r3, #0]
 8021f60:	685a      	ldr	r2, [r3, #4]
 8021f62:	689b      	ldr	r3, [r3, #8]
 8021f64:	f000 f913 	bl	802218e <eventSLL_insert>
 8021f68:	1e03      	subs	r3, r0, #0
 8021f6a:	d001      	beq.n	8021f70 <calendar_addEvent+0x4c>
			{
				return CALENDAR_OKAY;
 8021f6c:	2300      	movs	r3, #0
 8021f6e:	e004      	b.n	8021f7a <calendar_addEvent+0x56>
			}
			else
			{
				return CALENDAR_FULL;
 8021f70:	2303      	movs	r3, #3
 8021f72:	e002      	b.n	8021f7a <calendar_addEvent+0x56>
			}
		}

		else
		{
			return CALENDAR_RUNNING;
 8021f74:	2305      	movs	r3, #5
 8021f76:	e000      	b.n	8021f7a <calendar_addEvent+0x56>
	}

	// the calendar has not been initialized
	else
	{
		return CALENDAR_NOT_INIT;
 8021f78:	2302      	movs	r3, #2
	}
}
 8021f7a:	0018      	movs	r0, r3
 8021f7c:	46bd      	mov	sp, r7
 8021f7e:	bcb0      	pop	{r4, r5, r7}
 8021f80:	bc08      	pop	{r3}
 8021f82:	b004      	add	sp, #16
 8021f84:	4718      	bx	r3
 8021f86:	46c0      	nop			; (mov r8, r8)
 8021f88:	20008064 	.word	0x20008064
 8021f8c:	20008065 	.word	0x20008065
 8021f90:	20008068 	.word	0x20008068

08021f94 <calendar_updateScheduler>:
 * Note:
 * 	Will not run if the module has not been initialized and if the calendar
 * 	is not running.
 */
CalendarStatus calendar_updateScheduler(void)
{
 8021f94:	b580      	push	{r7, lr}
 8021f96:	af00      	add	r7, sp, #0
	// if the calendar module has been initialized
	if (_isInit)
 8021f98:	4b0c      	ldr	r3, [pc, #48]	; (8021fcc <calendar_updateScheduler+0x38>)
 8021f9a:	781b      	ldrb	r3, [r3, #0]
 8021f9c:	2b00      	cmp	r3, #0
 8021f9e:	d011      	beq.n	8021fc4 <calendar_updateScheduler+0x30>
	{
		// only update if the calendar is running
		if (_isRunning)
 8021fa0:	4b0b      	ldr	r3, [pc, #44]	; (8021fd0 <calendar_updateScheduler+0x3c>)
 8021fa2:	781b      	ldrb	r3, [r3, #0]
 8021fa4:	2b00      	cmp	r3, #0
 8021fa6:	d00b      	beq.n	8021fc0 <calendar_updateScheduler+0x2c>
		{
			// only update if an alarm has fired
			if (_alarmAFired) {
 8021fa8:	4b0a      	ldr	r3, [pc, #40]	; (8021fd4 <calendar_updateScheduler+0x40>)
 8021faa:	781b      	ldrb	r3, [r3, #0]
 8021fac:	b2db      	uxtb	r3, r3
 8021fae:	2b00      	cmp	r3, #0
 8021fb0:	d004      	beq.n	8021fbc <calendar_updateScheduler+0x28>
				// update the calendar's state
				_update();
 8021fb2:	f000 f81b 	bl	8021fec <_update>

				// reset alarm fired flag
				_alarmAFired = false;
 8021fb6:	4b07      	ldr	r3, [pc, #28]	; (8021fd4 <calendar_updateScheduler+0x40>)
 8021fb8:	2200      	movs	r2, #0
 8021fba:	701a      	strb	r2, [r3, #0]
			}

			return CALENDAR_OKAY;
 8021fbc:	2300      	movs	r3, #0
 8021fbe:	e002      	b.n	8021fc6 <calendar_updateScheduler+0x32>
		}

		// report that the calendar is paused
		else
		{
			return CALENDAR_PAUSED;
 8021fc0:	2304      	movs	r3, #4
 8021fc2:	e000      	b.n	8021fc6 <calendar_updateScheduler+0x32>
	}

	// the module is not initialized
	else
	{
		return CALENDAR_NOT_INIT;
 8021fc4:	2302      	movs	r3, #2
	}
}
 8021fc6:	0018      	movs	r0, r3
 8021fc8:	46bd      	mov	sp, r7
 8021fca:	bd80      	pop	{r7, pc}
 8021fcc:	20008064 	.word	0x20008064
 8021fd0:	20008065 	.word	0x20008065
 8021fd4:	20008066 	.word	0x20008066

08021fd8 <calendar_AlarmA_ISR>:
 *
 * RTC Alarm A interrupt service routine.  To only be called within the
 * RTC Alarm A ISR (HAL_RTC_AlarmAEventCallback()).
 */
void calendar_AlarmA_ISR(void)
{
 8021fd8:	b580      	push	{r7, lr}
 8021fda:	af00      	add	r7, sp, #0
	// set flag that an alarm fired
	_alarmAFired = true;
 8021fdc:	4b02      	ldr	r3, [pc, #8]	; (8021fe8 <calendar_AlarmA_ISR+0x10>)
 8021fde:	2201      	movs	r2, #1
 8021fe0:	701a      	strb	r2, [r3, #0]
}
 8021fe2:	46c0      	nop			; (mov r8, r8)
 8021fe4:	46bd      	mov	sp, r7
 8021fe6:	bd80      	pop	{r7, pc}
 8021fe8:	20008066 	.word	0x20008066

08021fec <_update>:
 * appropriately.
 *
 * Also handles reseting the alarm for events that occur in a following month/year.
 */
void _update(void)
{
 8021fec:	b590      	push	{r4, r7, lr}
 8021fee:	b089      	sub	sp, #36	; 0x24
 8021ff0:	af02      	add	r7, sp, #8
	DateTime nextAlarm;
	DateTime now;
	int prevInProgress;

	// get calendar alarm for next alarm in event list relative to now
	rtcCalendarControl_getDateTime(&(now.year), &(now.month), &(now.day),
 8021ff2:	1d3b      	adds	r3, r7, #4
 8021ff4:	1cdc      	adds	r4, r3, #3
 8021ff6:	1d3b      	adds	r3, r7, #4
 8021ff8:	1c9a      	adds	r2, r3, #2
 8021ffa:	1d3b      	adds	r3, r7, #4
 8021ffc:	1c59      	adds	r1, r3, #1
 8021ffe:	1d38      	adds	r0, r7, #4
 8022000:	1d3b      	adds	r3, r7, #4
 8022002:	3305      	adds	r3, #5
 8022004:	9301      	str	r3, [sp, #4]
 8022006:	1d3b      	adds	r3, r7, #4
 8022008:	3304      	adds	r3, #4
 802200a:	9300      	str	r3, [sp, #0]
 802200c:	0023      	movs	r3, r4
 802200e:	f000 fc2d 	bl	802286c <rtcCalendarControl_getDateTime>
			&(now.hour), &(now.minute), &(now.second));

	// store the currently running event to test index to check if an
	// event change has occurred
	prevInProgress = _eventQueue.inProgress;
 8022012:	4a33      	ldr	r2, [pc, #204]	; (80220e0 <_update+0xf4>)
 8022014:	23e2      	movs	r3, #226	; 0xe2
 8022016:	009b      	lsls	r3, r3, #2
 8022018:	58d3      	ldr	r3, [r2, r3]
 802201a:	617b      	str	r3, [r7, #20]

	// if there is an alarm to set upon updating the events queue
	if (eventSLL_getNextAlarm(&_eventQueue, now, &nextAlarm))
 802201c:	240c      	movs	r4, #12
 802201e:	193b      	adds	r3, r7, r4
 8022020:	1d3a      	adds	r2, r7, #4
 8022022:	482f      	ldr	r0, [pc, #188]	; (80220e0 <_update+0xf4>)
 8022024:	6811      	ldr	r1, [r2, #0]
 8022026:	6852      	ldr	r2, [r2, #4]
 8022028:	f000 f9e1 	bl	80223ee <eventSLL_getNextAlarm>
 802202c:	1e03      	subs	r3, r0, #0
 802202e:	d00a      	beq.n	8022046 <_update+0x5a>
	{
		// set Alarm A
		rtcCalendarControl_setAlarm_A(nextAlarm.day, nextAlarm.hour,
 8022030:	193b      	adds	r3, r7, r4
 8022032:	7898      	ldrb	r0, [r3, #2]
 8022034:	193b      	adds	r3, r7, r4
 8022036:	78d9      	ldrb	r1, [r3, #3]
 8022038:	193b      	adds	r3, r7, r4
 802203a:	791a      	ldrb	r2, [r3, #4]
 802203c:	193b      	adds	r3, r7, r4
 802203e:	795b      	ldrb	r3, [r3, #5]
 8022040:	f000 fcbe 	bl	80229c0 <rtcCalendarControl_setAlarm_A>
 8022044:	e001      	b.n	802204a <_update+0x5e>
	}

	// if there is no alarm to set, disable the alarm
	else
	{
		rtcCalendarControl_diableAlarm_A();
 8022046:	f000 fd69 	bl	8022b1c <rtcCalendarControl_diableAlarm_A>
	}

	// if exiting an event
	if (_eventQueue.inProgress != prevInProgress
 802204a:	4a25      	ldr	r2, [pc, #148]	; (80220e0 <_update+0xf4>)
 802204c:	23e2      	movs	r3, #226	; 0xe2
 802204e:	009b      	lsls	r3, r3, #2
 8022050:	58d3      	ldr	r3, [r2, r3]
 8022052:	697a      	ldr	r2, [r7, #20]
 8022054:	429a      	cmp	r2, r3
 8022056:	d017      	beq.n	8022088 <_update+0x9c>
			&& prevInProgress != EVENTS_SLL_NO_EVENT)
 8022058:	697b      	ldr	r3, [r7, #20]
 802205a:	3301      	adds	r3, #1
 802205c:	d014      	beq.n	8022088 <_update+0x9c>
	{
		// call end event callback for exited event (if registered)
		if (_eventQueue.events[prevInProgress].event.end_callback != NULL)
 802205e:	4920      	ldr	r1, [pc, #128]	; (80220e0 <_update+0xf4>)
 8022060:	697a      	ldr	r2, [r7, #20]
 8022062:	0013      	movs	r3, r2
 8022064:	00db      	lsls	r3, r3, #3
 8022066:	1a9b      	subs	r3, r3, r2
 8022068:	009b      	lsls	r3, r3, #2
 802206a:	18cb      	adds	r3, r1, r3
 802206c:	3310      	adds	r3, #16
 802206e:	681b      	ldr	r3, [r3, #0]
 8022070:	2b00      	cmp	r3, #0
 8022072:	d009      	beq.n	8022088 <_update+0x9c>
			(*_eventQueue.events[prevInProgress].event.end_callback)();
 8022074:	491a      	ldr	r1, [pc, #104]	; (80220e0 <_update+0xf4>)
 8022076:	697a      	ldr	r2, [r7, #20]
 8022078:	0013      	movs	r3, r2
 802207a:	00db      	lsls	r3, r3, #3
 802207c:	1a9b      	subs	r3, r3, r2
 802207e:	009b      	lsls	r3, r3, #2
 8022080:	18cb      	adds	r3, r1, r3
 8022082:	3310      	adds	r3, #16
 8022084:	681b      	ldr	r3, [r3, #0]
 8022086:	4798      	blx	r3
	}

	// if entering an event
	if (_eventQueue.inProgress != EVENTS_SLL_NO_EVENT
 8022088:	4a15      	ldr	r2, [pc, #84]	; (80220e0 <_update+0xf4>)
 802208a:	23e2      	movs	r3, #226	; 0xe2
 802208c:	009b      	lsls	r3, r3, #2
 802208e:	58d3      	ldr	r3, [r2, r3]
 8022090:	3301      	adds	r3, #1
 8022092:	d021      	beq.n	80220d8 <_update+0xec>
			&& _eventQueue.inProgress != prevInProgress)
 8022094:	4a12      	ldr	r2, [pc, #72]	; (80220e0 <_update+0xf4>)
 8022096:	23e2      	movs	r3, #226	; 0xe2
 8022098:	009b      	lsls	r3, r3, #2
 802209a:	58d3      	ldr	r3, [r2, r3]
 802209c:	697a      	ldr	r2, [r7, #20]
 802209e:	429a      	cmp	r2, r3
 80220a0:	d01a      	beq.n	80220d8 <_update+0xec>
	{
		// call start event callback for entered event (if registered)
		if (_eventQueue.events[_eventQueue.inProgress].event.start_callback != NULL)
 80220a2:	4a0f      	ldr	r2, [pc, #60]	; (80220e0 <_update+0xf4>)
 80220a4:	23e2      	movs	r3, #226	; 0xe2
 80220a6:	009b      	lsls	r3, r3, #2
 80220a8:	58d2      	ldr	r2, [r2, r3]
 80220aa:	490d      	ldr	r1, [pc, #52]	; (80220e0 <_update+0xf4>)
 80220ac:	0013      	movs	r3, r2
 80220ae:	00db      	lsls	r3, r3, #3
 80220b0:	1a9b      	subs	r3, r3, r2
 80220b2:	009b      	lsls	r3, r3, #2
 80220b4:	18cb      	adds	r3, r1, r3
 80220b6:	330c      	adds	r3, #12
 80220b8:	681b      	ldr	r3, [r3, #0]
 80220ba:	2b00      	cmp	r3, #0
 80220bc:	d00c      	beq.n	80220d8 <_update+0xec>
			(*_eventQueue.events[_eventQueue.inProgress].event.start_callback)();
 80220be:	4a08      	ldr	r2, [pc, #32]	; (80220e0 <_update+0xf4>)
 80220c0:	23e2      	movs	r3, #226	; 0xe2
 80220c2:	009b      	lsls	r3, r3, #2
 80220c4:	58d2      	ldr	r2, [r2, r3]
 80220c6:	4906      	ldr	r1, [pc, #24]	; (80220e0 <_update+0xf4>)
 80220c8:	0013      	movs	r3, r2
 80220ca:	00db      	lsls	r3, r3, #3
 80220cc:	1a9b      	subs	r3, r3, r2
 80220ce:	009b      	lsls	r3, r3, #2
 80220d0:	18cb      	adds	r3, r1, r3
 80220d2:	330c      	adds	r3, #12
 80220d4:	681b      	ldr	r3, [r3, #0]
 80220d6:	4798      	blx	r3
	}
}
 80220d8:	46c0      	nop			; (mov r8, r8)
 80220da:	46bd      	mov	sp, r7
 80220dc:	b007      	add	sp, #28
 80220de:	bd90      	pop	{r4, r7, pc}
 80220e0:	20008068 	.word	0x20008068

080220e4 <eventSLL_reset>:
/* eventSLL_reset
 *
 * Resets operation variables and clears events storage.
 */
bool eventSLL_reset(Event_SLL* const sll)
{
 80220e4:	b580      	push	{r7, lr}
 80220e6:	b084      	sub	sp, #16
 80220e8:	af00      	add	r7, sp, #0
 80220ea:	6078      	str	r0, [r7, #4]
	if (sll != NULL)
 80220ec:	687b      	ldr	r3, [r7, #4]
 80220ee:	2b00      	cmp	r3, #0
 80220f0:	d048      	beq.n	8022184 <eventSLL_reset+0xa0>
	{
		int idx;

		sll->inProgress = EVENTS_SLL_NO_EVENT;
 80220f2:	687a      	ldr	r2, [r7, #4]
 80220f4:	23e2      	movs	r3, #226	; 0xe2
 80220f6:	009b      	lsls	r3, r3, #2
 80220f8:	2101      	movs	r1, #1
 80220fa:	4249      	negs	r1, r1
 80220fc:	50d1      	str	r1, [r2, r3]
		sll->freeHead = 0;
 80220fe:	687a      	ldr	r2, [r7, #4]
 8022100:	23e1      	movs	r3, #225	; 0xe1
 8022102:	009b      	lsls	r3, r3, #2
 8022104:	2100      	movs	r1, #0
 8022106:	50d1      	str	r1, [r2, r3]
		sll->usedHead = EVENTS_SLL_NO_EVENT;
 8022108:	687a      	ldr	r2, [r7, #4]
 802210a:	23e0      	movs	r3, #224	; 0xe0
 802210c:	009b      	lsls	r3, r3, #2
 802210e:	2101      	movs	r1, #1
 8022110:	4249      	negs	r1, r1
 8022112:	50d1      	str	r1, [r2, r3]
		sll->count = 0;
 8022114:	687a      	ldr	r2, [r7, #4]
 8022116:	23e3      	movs	r3, #227	; 0xe3
 8022118:	009b      	lsls	r3, r3, #2
 802211a:	2100      	movs	r1, #0
 802211c:	50d1      	str	r1, [r2, r3]

		memset(sll->events, 0, sizeof(struct EventSLL_Node) * MAX_NUM_EVENTS);
 802211e:	687b      	ldr	r3, [r7, #4]
 8022120:	22e0      	movs	r2, #224	; 0xe0
 8022122:	0092      	lsls	r2, r2, #2
 8022124:	2100      	movs	r1, #0
 8022126:	0018      	movs	r0, r3
 8022128:	f000 fde7 	bl	8022cfa <memset>
		for (idx = 0; idx < MAX_NUM_EVENTS - 1; idx++)
 802212c:	2300      	movs	r3, #0
 802212e:	60fb      	str	r3, [r7, #12]
 8022130:	e018      	b.n	8022164 <eventSLL_reset+0x80>
		{
			sll->events[idx].id = EVENTS_SLL_NO_EVENT;
 8022132:	6879      	ldr	r1, [r7, #4]
 8022134:	68fa      	ldr	r2, [r7, #12]
 8022136:	0013      	movs	r3, r2
 8022138:	00db      	lsls	r3, r3, #3
 802213a:	1a9b      	subs	r3, r3, r2
 802213c:	009b      	lsls	r3, r3, #2
 802213e:	18cb      	adds	r3, r1, r3
 8022140:	3314      	adds	r3, #20
 8022142:	2201      	movs	r2, #1
 8022144:	4252      	negs	r2, r2
 8022146:	601a      	str	r2, [r3, #0]
			sll->events[idx].next = idx + 1;
 8022148:	68fb      	ldr	r3, [r7, #12]
 802214a:	1c59      	adds	r1, r3, #1
 802214c:	6878      	ldr	r0, [r7, #4]
 802214e:	68fa      	ldr	r2, [r7, #12]
 8022150:	0013      	movs	r3, r2
 8022152:	00db      	lsls	r3, r3, #3
 8022154:	1a9b      	subs	r3, r3, r2
 8022156:	009b      	lsls	r3, r3, #2
 8022158:	18c3      	adds	r3, r0, r3
 802215a:	3318      	adds	r3, #24
 802215c:	6019      	str	r1, [r3, #0]
		for (idx = 0; idx < MAX_NUM_EVENTS - 1; idx++)
 802215e:	68fb      	ldr	r3, [r7, #12]
 8022160:	3301      	adds	r3, #1
 8022162:	60fb      	str	r3, [r7, #12]
 8022164:	68fb      	ldr	r3, [r7, #12]
 8022166:	2b1e      	cmp	r3, #30
 8022168:	dde3      	ble.n	8022132 <eventSLL_reset+0x4e>
		}
		sll->events[idx].next = EVENTS_SLL_NO_EVENT;
 802216a:	6879      	ldr	r1, [r7, #4]
 802216c:	68fa      	ldr	r2, [r7, #12]
 802216e:	0013      	movs	r3, r2
 8022170:	00db      	lsls	r3, r3, #3
 8022172:	1a9b      	subs	r3, r3, r2
 8022174:	009b      	lsls	r3, r3, #2
 8022176:	18cb      	adds	r3, r1, r3
 8022178:	3318      	adds	r3, #24
 802217a:	2201      	movs	r2, #1
 802217c:	4252      	negs	r2, r2
 802217e:	601a      	str	r2, [r3, #0]

		return true;
 8022180:	2301      	movs	r3, #1
 8022182:	e000      	b.n	8022186 <eventSLL_reset+0xa2>
	}

	else
	{
		return false;
 8022184:	2300      	movs	r3, #0
	}
}
 8022186:	0018      	movs	r0, r3
 8022188:	46bd      	mov	sp, r7
 802218a:	b004      	add	sp, #16
 802218c:	bd80      	pop	{r7, pc}

0802218e <eventSLL_insert>:
/* eventSLL_insert
 *
 * Inserts an event while maintaining monotonic ordering on event start times.
 */
bool eventSLL_insert(Event_SLL* const sll, const struct CalendarEvent event)
{
 802218e:	b084      	sub	sp, #16
 8022190:	b590      	push	{r4, r7, lr}
 8022192:	b087      	sub	sp, #28
 8022194:	af00      	add	r7, sp, #0
 8022196:	6078      	str	r0, [r7, #4]
 8022198:	2004      	movs	r0, #4
 802219a:	2420      	movs	r4, #32
 802219c:	1900      	adds	r0, r0, r4
 802219e:	2408      	movs	r4, #8
 80221a0:	46a4      	mov	ip, r4
 80221a2:	44bc      	add	ip, r7
 80221a4:	4460      	add	r0, ip
 80221a6:	6001      	str	r1, [r0, #0]
 80221a8:	6042      	str	r2, [r0, #4]
 80221aa:	6083      	str	r3, [r0, #8]
	int prevToInsertIdx;
	int toInsertIdx;
	int tempIdx;

	// if list is not full
	if (sll->count < MAX_NUM_EVENTS)
 80221ac:	687a      	ldr	r2, [r7, #4]
 80221ae:	23e3      	movs	r3, #227	; 0xe3
 80221b0:	009b      	lsls	r3, r3, #2
 80221b2:	58d3      	ldr	r3, [r2, r3]
 80221b4:	2b1f      	cmp	r3, #31
 80221b6:	d900      	bls.n	80221ba <eventSLL_insert+0x2c>
 80221b8:	e111      	b.n	80223de <eventSLL_insert+0x250>
	{
		// if the list is empty, insert at beginning
		if (sll->usedHead == EVENTS_SLL_NO_EVENT)
 80221ba:	687a      	ldr	r2, [r7, #4]
 80221bc:	23e0      	movs	r3, #224	; 0xe0
 80221be:	009b      	lsls	r3, r3, #2
 80221c0:	58d3      	ldr	r3, [r2, r3]
 80221c2:	3301      	adds	r3, #1
 80221c4:	d128      	bne.n	8022218 <eventSLL_insert+0x8a>
		{
			// set used and free heads
			sll->usedHead = sll->freeHead;							// point head of used to head of free
 80221c6:	687a      	ldr	r2, [r7, #4]
 80221c8:	23e1      	movs	r3, #225	; 0xe1
 80221ca:	009b      	lsls	r3, r3, #2
 80221cc:	58d1      	ldr	r1, [r2, r3]
 80221ce:	687a      	ldr	r2, [r7, #4]
 80221d0:	23e0      	movs	r3, #224	; 0xe0
 80221d2:	009b      	lsls	r3, r3, #2
 80221d4:	50d1      	str	r1, [r2, r3]
			sll->freeHead = sll->events[sll->freeHead].next;		// point head of free to next of free
 80221d6:	687a      	ldr	r2, [r7, #4]
 80221d8:	23e1      	movs	r3, #225	; 0xe1
 80221da:	009b      	lsls	r3, r3, #2
 80221dc:	58d2      	ldr	r2, [r2, r3]
 80221de:	6879      	ldr	r1, [r7, #4]
 80221e0:	0013      	movs	r3, r2
 80221e2:	00db      	lsls	r3, r3, #3
 80221e4:	1a9b      	subs	r3, r3, r2
 80221e6:	009b      	lsls	r3, r3, #2
 80221e8:	18cb      	adds	r3, r1, r3
 80221ea:	3318      	adds	r3, #24
 80221ec:	6819      	ldr	r1, [r3, #0]
 80221ee:	687a      	ldr	r2, [r7, #4]
 80221f0:	23e1      	movs	r3, #225	; 0xe1
 80221f2:	009b      	lsls	r3, r3, #2
 80221f4:	50d1      	str	r1, [r2, r3]
			toInsertIdx = sll->usedHead;
 80221f6:	687a      	ldr	r2, [r7, #4]
 80221f8:	23e0      	movs	r3, #224	; 0xe0
 80221fa:	009b      	lsls	r3, r3, #2
 80221fc:	58d3      	ldr	r3, [r2, r3]
 80221fe:	613b      	str	r3, [r7, #16]
			sll->events[toInsertIdx].next = EVENTS_SLL_NO_EVENT;	// point head of used to none
 8022200:	6879      	ldr	r1, [r7, #4]
 8022202:	693a      	ldr	r2, [r7, #16]
 8022204:	0013      	movs	r3, r2
 8022206:	00db      	lsls	r3, r3, #3
 8022208:	1a9b      	subs	r3, r3, r2
 802220a:	009b      	lsls	r3, r3, #2
 802220c:	18cb      	adds	r3, r1, r3
 802220e:	3318      	adds	r3, #24
 8022210:	2201      	movs	r2, #1
 8022212:	4252      	negs	r2, r2
 8022214:	601a      	str	r2, [r3, #0]
 8022216:	e0be      	b.n	8022396 <eventSLL_insert+0x208>
		}

		// the list is not empty
		// iterate over list and insert where appropriate for monotonic ordering
		else if (sll->count < MAX_NUM_EVENTS)
 8022218:	687a      	ldr	r2, [r7, #4]
 802221a:	23e3      	movs	r3, #227	; 0xe3
 802221c:	009b      	lsls	r3, r3, #2
 802221e:	58d3      	ldr	r3, [r2, r3]
 8022220:	2b1f      	cmp	r3, #31
 8022222:	d900      	bls.n	8022226 <eventSLL_insert+0x98>
 8022224:	e0b7      	b.n	8022396 <eventSLL_insert+0x208>
		{
			// if inserting at start
			if (_compareDateTime(event.start, sll->events[sll->usedHead].event.start) < 0)
 8022226:	687a      	ldr	r2, [r7, #4]
 8022228:	23e0      	movs	r3, #224	; 0xe0
 802222a:	009b      	lsls	r3, r3, #2
 802222c:	58d2      	ldr	r2, [r2, r3]
 802222e:	6878      	ldr	r0, [r7, #4]
 8022230:	0013      	movs	r3, r2
 8022232:	00db      	lsls	r3, r3, #3
 8022234:	1a9b      	subs	r3, r3, r2
 8022236:	009b      	lsls	r3, r3, #2
 8022238:	2204      	movs	r2, #4
 802223a:	2120      	movs	r1, #32
 802223c:	1852      	adds	r2, r2, r1
 802223e:	2108      	movs	r1, #8
 8022240:	1879      	adds	r1, r7, r1
 8022242:	1851      	adds	r1, r2, r1
 8022244:	581a      	ldr	r2, [r3, r0]
 8022246:	18c3      	adds	r3, r0, r3
 8022248:	685b      	ldr	r3, [r3, #4]
 802224a:	6808      	ldr	r0, [r1, #0]
 802224c:	6849      	ldr	r1, [r1, #4]
 802224e:	f000 f9ad 	bl	80225ac <_compareDateTime>
 8022252:	1e03      	subs	r3, r0, #0
 8022254:	da34      	bge.n	80222c0 <eventSLL_insert+0x132>
			{
				// take from head of free nodes and move to start of used nodes
				tempIdx = sll->usedHead;							// store head of used in temp
 8022256:	687a      	ldr	r2, [r7, #4]
 8022258:	23e0      	movs	r3, #224	; 0xe0
 802225a:	009b      	lsls	r3, r3, #2
 802225c:	58d3      	ldr	r3, [r2, r3]
 802225e:	60fb      	str	r3, [r7, #12]
				sll->events[sll->usedHead].next = sll->freeHead;	// point head of used to head of free
 8022260:	687a      	ldr	r2, [r7, #4]
 8022262:	23e0      	movs	r3, #224	; 0xe0
 8022264:	009b      	lsls	r3, r3, #2
 8022266:	58d2      	ldr	r2, [r2, r3]
 8022268:	6879      	ldr	r1, [r7, #4]
 802226a:	23e1      	movs	r3, #225	; 0xe1
 802226c:	009b      	lsls	r3, r3, #2
 802226e:	58c9      	ldr	r1, [r1, r3]
 8022270:	6878      	ldr	r0, [r7, #4]
 8022272:	0013      	movs	r3, r2
 8022274:	00db      	lsls	r3, r3, #3
 8022276:	1a9b      	subs	r3, r3, r2
 8022278:	009b      	lsls	r3, r3, #2
 802227a:	18c3      	adds	r3, r0, r3
 802227c:	3318      	adds	r3, #24
 802227e:	6019      	str	r1, [r3, #0]
				sll->freeHead = sll->events[sll->freeHead].next;	// point head of free to next of free
 8022280:	687a      	ldr	r2, [r7, #4]
 8022282:	23e1      	movs	r3, #225	; 0xe1
 8022284:	009b      	lsls	r3, r3, #2
 8022286:	58d2      	ldr	r2, [r2, r3]
 8022288:	6879      	ldr	r1, [r7, #4]
 802228a:	0013      	movs	r3, r2
 802228c:	00db      	lsls	r3, r3, #3
 802228e:	1a9b      	subs	r3, r3, r2
 8022290:	009b      	lsls	r3, r3, #2
 8022292:	18cb      	adds	r3, r1, r3
 8022294:	3318      	adds	r3, #24
 8022296:	6819      	ldr	r1, [r3, #0]
 8022298:	687a      	ldr	r2, [r7, #4]
 802229a:	23e1      	movs	r3, #225	; 0xe1
 802229c:	009b      	lsls	r3, r3, #2
 802229e:	50d1      	str	r1, [r2, r3]
				toInsertIdx = sll->usedHead;
 80222a0:	687a      	ldr	r2, [r7, #4]
 80222a2:	23e0      	movs	r3, #224	; 0xe0
 80222a4:	009b      	lsls	r3, r3, #2
 80222a6:	58d3      	ldr	r3, [r2, r3]
 80222a8:	613b      	str	r3, [r7, #16]
				sll->events[toInsertIdx].next = tempIdx;			// point head of used to stored in temp
 80222aa:	6879      	ldr	r1, [r7, #4]
 80222ac:	693a      	ldr	r2, [r7, #16]
 80222ae:	0013      	movs	r3, r2
 80222b0:	00db      	lsls	r3, r3, #3
 80222b2:	1a9b      	subs	r3, r3, r2
 80222b4:	009b      	lsls	r3, r3, #2
 80222b6:	18cb      	adds	r3, r1, r3
 80222b8:	3318      	adds	r3, #24
 80222ba:	68fa      	ldr	r2, [r7, #12]
 80222bc:	601a      	str	r2, [r3, #0]
 80222be:	e06a      	b.n	8022396 <eventSLL_insert+0x208>

			// if inserting not at the start
			else
			{
				// find node previous to where to insert
				prevToInsertIdx = sll->usedHead;
 80222c0:	687a      	ldr	r2, [r7, #4]
 80222c2:	23e0      	movs	r3, #224	; 0xe0
 80222c4:	009b      	lsls	r3, r3, #2
 80222c6:	58d3      	ldr	r3, [r2, r3]
 80222c8:	617b      	str	r3, [r7, #20]
				// while insert event's start time is less than each event's start time
				// already in the list, iterate list
				// if the start times are equal, then inserting after the current iteration
				// does not care about end times of events
				while (_compareDateTime(event.start, sll->events[prevToInsertIdx].event.start) >= 0
 80222ca:	e009      	b.n	80222e0 <eventSLL_insert+0x152>
						&& sll->events[prevToInsertIdx].next != EVENTS_SLL_NO_EVENT)
					prevToInsertIdx = sll->events[prevToInsertIdx].next;
 80222cc:	6879      	ldr	r1, [r7, #4]
 80222ce:	697a      	ldr	r2, [r7, #20]
 80222d0:	0013      	movs	r3, r2
 80222d2:	00db      	lsls	r3, r3, #3
 80222d4:	1a9b      	subs	r3, r3, r2
 80222d6:	009b      	lsls	r3, r3, #2
 80222d8:	18cb      	adds	r3, r1, r3
 80222da:	3318      	adds	r3, #24
 80222dc:	681b      	ldr	r3, [r3, #0]
 80222de:	617b      	str	r3, [r7, #20]
				while (_compareDateTime(event.start, sll->events[prevToInsertIdx].event.start) >= 0
 80222e0:	6878      	ldr	r0, [r7, #4]
 80222e2:	697a      	ldr	r2, [r7, #20]
 80222e4:	0013      	movs	r3, r2
 80222e6:	00db      	lsls	r3, r3, #3
 80222e8:	1a9b      	subs	r3, r3, r2
 80222ea:	009b      	lsls	r3, r3, #2
 80222ec:	2204      	movs	r2, #4
 80222ee:	2120      	movs	r1, #32
 80222f0:	1852      	adds	r2, r2, r1
 80222f2:	2108      	movs	r1, #8
 80222f4:	1879      	adds	r1, r7, r1
 80222f6:	1851      	adds	r1, r2, r1
 80222f8:	581a      	ldr	r2, [r3, r0]
 80222fa:	18c3      	adds	r3, r0, r3
 80222fc:	685b      	ldr	r3, [r3, #4]
 80222fe:	6808      	ldr	r0, [r1, #0]
 8022300:	6849      	ldr	r1, [r1, #4]
 8022302:	f000 f953 	bl	80225ac <_compareDateTime>
 8022306:	1e03      	subs	r3, r0, #0
 8022308:	db0a      	blt.n	8022320 <eventSLL_insert+0x192>
						&& sll->events[prevToInsertIdx].next != EVENTS_SLL_NO_EVENT)
 802230a:	6879      	ldr	r1, [r7, #4]
 802230c:	697a      	ldr	r2, [r7, #20]
 802230e:	0013      	movs	r3, r2
 8022310:	00db      	lsls	r3, r3, #3
 8022312:	1a9b      	subs	r3, r3, r2
 8022314:	009b      	lsls	r3, r3, #2
 8022316:	18cb      	adds	r3, r1, r3
 8022318:	3318      	adds	r3, #24
 802231a:	681b      	ldr	r3, [r3, #0]
 802231c:	3301      	adds	r3, #1
 802231e:	d1d5      	bne.n	80222cc <eventSLL_insert+0x13e>

				// perform insert
				tempIdx = sll->events[prevToInsertIdx].next;		// store previous to insert in temp
 8022320:	6879      	ldr	r1, [r7, #4]
 8022322:	697a      	ldr	r2, [r7, #20]
 8022324:	0013      	movs	r3, r2
 8022326:	00db      	lsls	r3, r3, #3
 8022328:	1a9b      	subs	r3, r3, r2
 802232a:	009b      	lsls	r3, r3, #2
 802232c:	18cb      	adds	r3, r1, r3
 802232e:	3318      	adds	r3, #24
 8022330:	681b      	ldr	r3, [r3, #0]
 8022332:	60fb      	str	r3, [r7, #12]
				sll->events[prevToInsertIdx].next = sll->freeHead;	// point next to insert to head of free
 8022334:	687a      	ldr	r2, [r7, #4]
 8022336:	23e1      	movs	r3, #225	; 0xe1
 8022338:	009b      	lsls	r3, r3, #2
 802233a:	58d1      	ldr	r1, [r2, r3]
 802233c:	6878      	ldr	r0, [r7, #4]
 802233e:	697a      	ldr	r2, [r7, #20]
 8022340:	0013      	movs	r3, r2
 8022342:	00db      	lsls	r3, r3, #3
 8022344:	1a9b      	subs	r3, r3, r2
 8022346:	009b      	lsls	r3, r3, #2
 8022348:	18c3      	adds	r3, r0, r3
 802234a:	3318      	adds	r3, #24
 802234c:	6019      	str	r1, [r3, #0]
				sll->freeHead = sll->events[sll->freeHead].next;	// point head of free to next of free
 802234e:	687a      	ldr	r2, [r7, #4]
 8022350:	23e1      	movs	r3, #225	; 0xe1
 8022352:	009b      	lsls	r3, r3, #2
 8022354:	58d2      	ldr	r2, [r2, r3]
 8022356:	6879      	ldr	r1, [r7, #4]
 8022358:	0013      	movs	r3, r2
 802235a:	00db      	lsls	r3, r3, #3
 802235c:	1a9b      	subs	r3, r3, r2
 802235e:	009b      	lsls	r3, r3, #2
 8022360:	18cb      	adds	r3, r1, r3
 8022362:	3318      	adds	r3, #24
 8022364:	6819      	ldr	r1, [r3, #0]
 8022366:	687a      	ldr	r2, [r7, #4]
 8022368:	23e1      	movs	r3, #225	; 0xe1
 802236a:	009b      	lsls	r3, r3, #2
 802236c:	50d1      	str	r1, [r2, r3]
				toInsertIdx = sll->events[prevToInsertIdx].next;
 802236e:	6879      	ldr	r1, [r7, #4]
 8022370:	697a      	ldr	r2, [r7, #20]
 8022372:	0013      	movs	r3, r2
 8022374:	00db      	lsls	r3, r3, #3
 8022376:	1a9b      	subs	r3, r3, r2
 8022378:	009b      	lsls	r3, r3, #2
 802237a:	18cb      	adds	r3, r1, r3
 802237c:	3318      	adds	r3, #24
 802237e:	681b      	ldr	r3, [r3, #0]
 8022380:	613b      	str	r3, [r7, #16]
				sll->events[toInsertIdx].next = tempIdx;			// point new node to stored in temp
 8022382:	6879      	ldr	r1, [r7, #4]
 8022384:	693a      	ldr	r2, [r7, #16]
 8022386:	0013      	movs	r3, r2
 8022388:	00db      	lsls	r3, r3, #3
 802238a:	1a9b      	subs	r3, r3, r2
 802238c:	009b      	lsls	r3, r3, #2
 802238e:	18cb      	adds	r3, r1, r3
 8022390:	3318      	adds	r3, #24
 8022392:	68fa      	ldr	r2, [r7, #12]
 8022394:	601a      	str	r2, [r3, #0]
			}
		}

		// copy event into new node
		_copyEvent(&(sll->events[toInsertIdx].event), &event);
 8022396:	693a      	ldr	r2, [r7, #16]
 8022398:	0013      	movs	r3, r2
 802239a:	00db      	lsls	r3, r3, #3
 802239c:	1a9b      	subs	r3, r3, r2
 802239e:	009b      	lsls	r3, r3, #2
 80223a0:	687a      	ldr	r2, [r7, #4]
 80223a2:	18d3      	adds	r3, r2, r3
 80223a4:	2224      	movs	r2, #36	; 0x24
 80223a6:	2108      	movs	r1, #8
 80223a8:	1852      	adds	r2, r2, r1
 80223aa:	19d2      	adds	r2, r2, r7
 80223ac:	0011      	movs	r1, r2
 80223ae:	0018      	movs	r0, r3
 80223b0:	f000 f89a 	bl	80224e8 <_copyEvent>

		// set ID
		sll->events[toInsertIdx].id = toInsertIdx;
 80223b4:	6879      	ldr	r1, [r7, #4]
 80223b6:	693a      	ldr	r2, [r7, #16]
 80223b8:	0013      	movs	r3, r2
 80223ba:	00db      	lsls	r3, r3, #3
 80223bc:	1a9b      	subs	r3, r3, r2
 80223be:	009b      	lsls	r3, r3, #2
 80223c0:	18cb      	adds	r3, r1, r3
 80223c2:	3314      	adds	r3, #20
 80223c4:	693a      	ldr	r2, [r7, #16]
 80223c6:	601a      	str	r2, [r3, #0]

		// increment count
		(sll->count)++;
 80223c8:	687a      	ldr	r2, [r7, #4]
 80223ca:	23e3      	movs	r3, #227	; 0xe3
 80223cc:	009b      	lsls	r3, r3, #2
 80223ce:	58d3      	ldr	r3, [r2, r3]
 80223d0:	1c59      	adds	r1, r3, #1
 80223d2:	687a      	ldr	r2, [r7, #4]
 80223d4:	23e3      	movs	r3, #227	; 0xe3
 80223d6:	009b      	lsls	r3, r3, #2
 80223d8:	50d1      	str	r1, [r2, r3]

		return true;
 80223da:	2301      	movs	r3, #1
 80223dc:	e000      	b.n	80223e0 <eventSLL_insert+0x252>
	}

	// if the list is full
	else
	{
		return false;
 80223de:	2300      	movs	r3, #0
	}
}
 80223e0:	0018      	movs	r0, r3
 80223e2:	46bd      	mov	sp, r7
 80223e4:	b007      	add	sp, #28
 80223e6:	bc90      	pop	{r4, r7}
 80223e8:	bc08      	pop	{r3}
 80223ea:	b004      	add	sp, #16
 80223ec:	4718      	bx	r3

080223ee <eventSLL_getNextAlarm>:
 *
 * Finds the next alarm to set to a given DateTime.  This will be either the start
 * or end alarm for an event.
 */
bool eventSLL_getNextAlarm(Event_SLL* const sll, const DateTime dateTime, DateTime* const alarm)
{
 80223ee:	b590      	push	{r4, r7, lr}
 80223f0:	b087      	sub	sp, #28
 80223f2:	af00      	add	r7, sp, #0
 80223f4:	60f8      	str	r0, [r7, #12]
 80223f6:	1d38      	adds	r0, r7, #4
 80223f8:	6001      	str	r1, [r0, #0]
 80223fa:	6042      	str	r2, [r0, #4]
 80223fc:	603b      	str	r3, [r7, #0]
	int idx;

	idx = sll->usedHead;
 80223fe:	68fa      	ldr	r2, [r7, #12]
 8022400:	23e0      	movs	r3, #224	; 0xe0
 8022402:	009b      	lsls	r3, r3, #2
 8022404:	58d3      	ldr	r3, [r2, r3]
 8022406:	617b      	str	r3, [r7, #20]
	while (idx != EVENTS_SLL_NO_EVENT)
 8022408:	e060      	b.n	80224cc <eventSLL_getNextAlarm+0xde>
	{
		// if the current iteration's end time has past
		// mark as past
		if (_compareDateTime(dateTime, sll->events[idx].event.end) >= 0)
 802240a:	68f8      	ldr	r0, [r7, #12]
 802240c:	6979      	ldr	r1, [r7, #20]
 802240e:	2206      	movs	r2, #6
 8022410:	000b      	movs	r3, r1
 8022412:	00db      	lsls	r3, r3, #3
 8022414:	1a5b      	subs	r3, r3, r1
 8022416:	009b      	lsls	r3, r3, #2
 8022418:	18c3      	adds	r3, r0, r3
 802241a:	1d39      	adds	r1, r7, #4
 802241c:	5a98      	ldrh	r0, [r3, r2]
 802241e:	189c      	adds	r4, r3, r2
 8022420:	8864      	ldrh	r4, [r4, #2]
 8022422:	0424      	lsls	r4, r4, #16
 8022424:	4304      	orrs	r4, r0
 8022426:	0020      	movs	r0, r4
 8022428:	189b      	adds	r3, r3, r2
 802242a:	889a      	ldrh	r2, [r3, #4]
 802242c:	2300      	movs	r3, #0
 802242e:	0412      	lsls	r2, r2, #16
 8022430:	0c12      	lsrs	r2, r2, #16
 8022432:	0c1b      	lsrs	r3, r3, #16
 8022434:	041b      	lsls	r3, r3, #16
 8022436:	4313      	orrs	r3, r2
 8022438:	0002      	movs	r2, r0
 802243a:	6808      	ldr	r0, [r1, #0]
 802243c:	6849      	ldr	r1, [r1, #4]
 802243e:	f000 f8b5 	bl	80225ac <_compareDateTime>
 8022442:	1e03      	subs	r3, r0, #0
 8022444:	db0a      	blt.n	802245c <eventSLL_getNextAlarm+0x6e>
		{
			// go to next event
			idx = sll->events[idx].next;
 8022446:	68f9      	ldr	r1, [r7, #12]
 8022448:	697a      	ldr	r2, [r7, #20]
 802244a:	0013      	movs	r3, r2
 802244c:	00db      	lsls	r3, r3, #3
 802244e:	1a9b      	subs	r3, r3, r2
 8022450:	009b      	lsls	r3, r3, #2
 8022452:	18cb      	adds	r3, r1, r3
 8022454:	3318      	adds	r3, #24
 8022456:	681b      	ldr	r3, [r3, #0]
 8022458:	617b      	str	r3, [r7, #20]
 802245a:	e037      	b.n	80224cc <eventSLL_getNextAlarm+0xde>
		}

		// now is within event
		// return alarm for end of event
		else if (_compareDateTime(dateTime, sll->events[idx].event.start) >= 0)
 802245c:	68f8      	ldr	r0, [r7, #12]
 802245e:	697a      	ldr	r2, [r7, #20]
 8022460:	0013      	movs	r3, r2
 8022462:	00db      	lsls	r3, r3, #3
 8022464:	1a9b      	subs	r3, r3, r2
 8022466:	009b      	lsls	r3, r3, #2
 8022468:	1d39      	adds	r1, r7, #4
 802246a:	581a      	ldr	r2, [r3, r0]
 802246c:	18c3      	adds	r3, r0, r3
 802246e:	685b      	ldr	r3, [r3, #4]
 8022470:	6808      	ldr	r0, [r1, #0]
 8022472:	6849      	ldr	r1, [r1, #4]
 8022474:	f000 f89a 	bl	80225ac <_compareDateTime>
 8022478:	1e03      	subs	r3, r0, #0
 802247a:	db13      	blt.n	80224a4 <eventSLL_getNextAlarm+0xb6>
		{
			// set sll inProgress pointer to this event and exit
			sll->inProgress = idx;
 802247c:	68fa      	ldr	r2, [r7, #12]
 802247e:	23e2      	movs	r3, #226	; 0xe2
 8022480:	009b      	lsls	r3, r3, #2
 8022482:	6979      	ldr	r1, [r7, #20]
 8022484:	50d1      	str	r1, [r2, r3]
			_copyDateTime(alarm, &(sll->events[idx].event.end));
 8022486:	697a      	ldr	r2, [r7, #20]
 8022488:	0013      	movs	r3, r2
 802248a:	00db      	lsls	r3, r3, #3
 802248c:	1a9b      	subs	r3, r3, r2
 802248e:	009b      	lsls	r3, r3, #2
 8022490:	68fa      	ldr	r2, [r7, #12]
 8022492:	18d3      	adds	r3, r2, r3
 8022494:	1d9a      	adds	r2, r3, #6
 8022496:	683b      	ldr	r3, [r7, #0]
 8022498:	0011      	movs	r1, r2
 802249a:	0018      	movs	r0, r3
 802249c:	f000 f865 	bl	802256a <_copyDateTime>
			return true;
 80224a0:	2301      	movs	r3, #1
 80224a2:	e01d      	b.n	80224e0 <eventSLL_getNextAlarm+0xf2>

		// event is in the future (next)
		// return alarm for start of event
		else
		{
			sll->inProgress = EVENTS_SLL_NO_EVENT;
 80224a4:	68fa      	ldr	r2, [r7, #12]
 80224a6:	23e2      	movs	r3, #226	; 0xe2
 80224a8:	009b      	lsls	r3, r3, #2
 80224aa:	2101      	movs	r1, #1
 80224ac:	4249      	negs	r1, r1
 80224ae:	50d1      	str	r1, [r2, r3]
			_copyDateTime(alarm, &(sll->events[idx].event.start));
 80224b0:	697a      	ldr	r2, [r7, #20]
 80224b2:	0013      	movs	r3, r2
 80224b4:	00db      	lsls	r3, r3, #3
 80224b6:	1a9b      	subs	r3, r3, r2
 80224b8:	009b      	lsls	r3, r3, #2
 80224ba:	68fa      	ldr	r2, [r7, #12]
 80224bc:	18d2      	adds	r2, r2, r3
 80224be:	683b      	ldr	r3, [r7, #0]
 80224c0:	0011      	movs	r1, r2
 80224c2:	0018      	movs	r0, r3
 80224c4:	f000 f851 	bl	802256a <_copyDateTime>
			return true;
 80224c8:	2301      	movs	r3, #1
 80224ca:	e009      	b.n	80224e0 <eventSLL_getNextAlarm+0xf2>
	while (idx != EVENTS_SLL_NO_EVENT)
 80224cc:	697b      	ldr	r3, [r7, #20]
 80224ce:	3301      	adds	r3, #1
 80224d0:	d19b      	bne.n	802240a <eventSLL_getNextAlarm+0x1c>
		}
	}

	// no alarms to set
	sll->inProgress = EVENTS_SLL_NO_EVENT;
 80224d2:	68fa      	ldr	r2, [r7, #12]
 80224d4:	23e2      	movs	r3, #226	; 0xe2
 80224d6:	009b      	lsls	r3, r3, #2
 80224d8:	2101      	movs	r1, #1
 80224da:	4249      	negs	r1, r1
 80224dc:	50d1      	str	r1, [r2, r3]
	return false;
 80224de:	2300      	movs	r3, #0
}
 80224e0:	0018      	movs	r0, r3
 80224e2:	46bd      	mov	sp, r7
 80224e4:	b007      	add	sp, #28
 80224e6:	bd90      	pop	{r4, r7, pc}

080224e8 <_copyEvent>:
/* _copyEvent
 *
 * Copy the contents of one CalenderEvent into another.
 */
void _copyEvent(struct CalendarEvent* const to, const struct CalendarEvent* const from)
{
 80224e8:	b580      	push	{r7, lr}
 80224ea:	b082      	sub	sp, #8
 80224ec:	af00      	add	r7, sp, #0
 80224ee:	6078      	str	r0, [r7, #4]
 80224f0:	6039      	str	r1, [r7, #0]
	to->start.year = from->start.year;
 80224f2:	683b      	ldr	r3, [r7, #0]
 80224f4:	781a      	ldrb	r2, [r3, #0]
 80224f6:	687b      	ldr	r3, [r7, #4]
 80224f8:	701a      	strb	r2, [r3, #0]
	to->start.month = from->start.month;
 80224fa:	683b      	ldr	r3, [r7, #0]
 80224fc:	785a      	ldrb	r2, [r3, #1]
 80224fe:	687b      	ldr	r3, [r7, #4]
 8022500:	705a      	strb	r2, [r3, #1]
	to->start.day = from->start.day;
 8022502:	683b      	ldr	r3, [r7, #0]
 8022504:	789a      	ldrb	r2, [r3, #2]
 8022506:	687b      	ldr	r3, [r7, #4]
 8022508:	709a      	strb	r2, [r3, #2]
	to->start.hour = from->start.hour;
 802250a:	683b      	ldr	r3, [r7, #0]
 802250c:	78da      	ldrb	r2, [r3, #3]
 802250e:	687b      	ldr	r3, [r7, #4]
 8022510:	70da      	strb	r2, [r3, #3]
	to->start.minute = from->start.minute;
 8022512:	683b      	ldr	r3, [r7, #0]
 8022514:	791a      	ldrb	r2, [r3, #4]
 8022516:	687b      	ldr	r3, [r7, #4]
 8022518:	711a      	strb	r2, [r3, #4]
	to->start.second = from->start.second;
 802251a:	683b      	ldr	r3, [r7, #0]
 802251c:	795a      	ldrb	r2, [r3, #5]
 802251e:	687b      	ldr	r3, [r7, #4]
 8022520:	715a      	strb	r2, [r3, #5]
	to->start_callback = from->start_callback;
 8022522:	683b      	ldr	r3, [r7, #0]
 8022524:	68da      	ldr	r2, [r3, #12]
 8022526:	687b      	ldr	r3, [r7, #4]
 8022528:	60da      	str	r2, [r3, #12]
	to->end.year = from->end.year;
 802252a:	683b      	ldr	r3, [r7, #0]
 802252c:	799a      	ldrb	r2, [r3, #6]
 802252e:	687b      	ldr	r3, [r7, #4]
 8022530:	719a      	strb	r2, [r3, #6]
	to->end.month = from->end.month;
 8022532:	683b      	ldr	r3, [r7, #0]
 8022534:	79da      	ldrb	r2, [r3, #7]
 8022536:	687b      	ldr	r3, [r7, #4]
 8022538:	71da      	strb	r2, [r3, #7]
	to->end.day = from->end.day;
 802253a:	683b      	ldr	r3, [r7, #0]
 802253c:	7a1a      	ldrb	r2, [r3, #8]
 802253e:	687b      	ldr	r3, [r7, #4]
 8022540:	721a      	strb	r2, [r3, #8]
	to->end.hour = from->end.hour;
 8022542:	683b      	ldr	r3, [r7, #0]
 8022544:	7a5a      	ldrb	r2, [r3, #9]
 8022546:	687b      	ldr	r3, [r7, #4]
 8022548:	725a      	strb	r2, [r3, #9]
	to->end.minute = from->end.minute;
 802254a:	683b      	ldr	r3, [r7, #0]
 802254c:	7a9a      	ldrb	r2, [r3, #10]
 802254e:	687b      	ldr	r3, [r7, #4]
 8022550:	729a      	strb	r2, [r3, #10]
	to->end.second = from->end.second;
 8022552:	683b      	ldr	r3, [r7, #0]
 8022554:	7ada      	ldrb	r2, [r3, #11]
 8022556:	687b      	ldr	r3, [r7, #4]
 8022558:	72da      	strb	r2, [r3, #11]
	to->end_callback = from->end_callback;
 802255a:	683b      	ldr	r3, [r7, #0]
 802255c:	691a      	ldr	r2, [r3, #16]
 802255e:	687b      	ldr	r3, [r7, #4]
 8022560:	611a      	str	r2, [r3, #16]
}
 8022562:	46c0      	nop			; (mov r8, r8)
 8022564:	46bd      	mov	sp, r7
 8022566:	b002      	add	sp, #8
 8022568:	bd80      	pop	{r7, pc}

0802256a <_copyDateTime>:
/* _copyDateTime
 *
 * Copy the contents of one DateTime into another.
 */
void _copyDateTime(DateTime* const to, DateTime* const from)
{
 802256a:	b580      	push	{r7, lr}
 802256c:	b082      	sub	sp, #8
 802256e:	af00      	add	r7, sp, #0
 8022570:	6078      	str	r0, [r7, #4]
 8022572:	6039      	str	r1, [r7, #0]
	to->year = from->year;
 8022574:	683b      	ldr	r3, [r7, #0]
 8022576:	781a      	ldrb	r2, [r3, #0]
 8022578:	687b      	ldr	r3, [r7, #4]
 802257a:	701a      	strb	r2, [r3, #0]
	to->month = from->month;
 802257c:	683b      	ldr	r3, [r7, #0]
 802257e:	785a      	ldrb	r2, [r3, #1]
 8022580:	687b      	ldr	r3, [r7, #4]
 8022582:	705a      	strb	r2, [r3, #1]
	to->day = from->day;
 8022584:	683b      	ldr	r3, [r7, #0]
 8022586:	789a      	ldrb	r2, [r3, #2]
 8022588:	687b      	ldr	r3, [r7, #4]
 802258a:	709a      	strb	r2, [r3, #2]
	to->hour = from->hour;
 802258c:	683b      	ldr	r3, [r7, #0]
 802258e:	78da      	ldrb	r2, [r3, #3]
 8022590:	687b      	ldr	r3, [r7, #4]
 8022592:	70da      	strb	r2, [r3, #3]
	to->minute = from->minute;
 8022594:	683b      	ldr	r3, [r7, #0]
 8022596:	791a      	ldrb	r2, [r3, #4]
 8022598:	687b      	ldr	r3, [r7, #4]
 802259a:	711a      	strb	r2, [r3, #4]
	to->second = from->second;
 802259c:	683b      	ldr	r3, [r7, #0]
 802259e:	795a      	ldrb	r2, [r3, #5]
 80225a0:	687b      	ldr	r3, [r7, #4]
 80225a2:	715a      	strb	r2, [r3, #5]
}
 80225a4:	46c0      	nop			; (mov r8, r8)
 80225a6:	46bd      	mov	sp, r7
 80225a8:	b002      	add	sp, #8
 80225aa:	bd80      	pop	{r7, pc}

080225ac <_compareDateTime>:
 * Find the time difference in seconds of dateTime1 and dateTime2.
 *
 * Note: Does not account for leap years.
 */
int32_t _compareDateTime(DateTime dateTime_1, DateTime dateTime_2)
{
 80225ac:	b5b0      	push	{r4, r5, r7, lr}
 80225ae:	b086      	sub	sp, #24
 80225b0:	af00      	add	r7, sp, #0
 80225b2:	2508      	movs	r5, #8
 80225b4:	197c      	adds	r4, r7, r5
 80225b6:	6020      	str	r0, [r4, #0]
 80225b8:	6061      	str	r1, [r4, #4]
 80225ba:	0039      	movs	r1, r7
 80225bc:	600a      	str	r2, [r1, #0]
 80225be:	604b      	str	r3, [r1, #4]
	uint32_t dateTimeSeconds_1, dateTimeSeconds_2;

	dateTimeSeconds_1 = _dateTimeToSeconds(dateTime_1);
 80225c0:	197b      	adds	r3, r7, r5
 80225c2:	6818      	ldr	r0, [r3, #0]
 80225c4:	6859      	ldr	r1, [r3, #4]
 80225c6:	f000 f811 	bl	80225ec <_dateTimeToSeconds>
 80225ca:	0003      	movs	r3, r0
 80225cc:	617b      	str	r3, [r7, #20]
	dateTimeSeconds_2 = _dateTimeToSeconds(dateTime_2);
 80225ce:	003b      	movs	r3, r7
 80225d0:	6818      	ldr	r0, [r3, #0]
 80225d2:	6859      	ldr	r1, [r3, #4]
 80225d4:	f000 f80a 	bl	80225ec <_dateTimeToSeconds>
 80225d8:	0003      	movs	r3, r0
 80225da:	613b      	str	r3, [r7, #16]

	// return net comparison (date time 1 - date time 2)
	return dateTimeSeconds_1 - dateTimeSeconds_2;
 80225dc:	697a      	ldr	r2, [r7, #20]
 80225de:	693b      	ldr	r3, [r7, #16]
 80225e0:	1ad3      	subs	r3, r2, r3
}
 80225e2:	0018      	movs	r0, r3
 80225e4:	46bd      	mov	sp, r7
 80225e6:	b006      	add	sp, #24
 80225e8:	bdb0      	pop	{r4, r5, r7, pc}
	...

080225ec <_dateTimeToSeconds>:
 *
 * Note: assumes 30 days in a month and no leap years, it is not needed for the
 * calculation because they are used for relative comparisons, not absolute values.
 */
uint32_t _dateTimeToSeconds(DateTime dateTime)
{
 80225ec:	b580      	push	{r7, lr}
 80225ee:	b082      	sub	sp, #8
 80225f0:	af00      	add	r7, sp, #0
 80225f2:	003b      	movs	r3, r7
 80225f4:	6018      	str	r0, [r3, #0]
 80225f6:	6059      	str	r1, [r3, #4]
	// Convert to seconds
	return (dateTime.second
 80225f8:	003b      	movs	r3, r7
 80225fa:	795b      	ldrb	r3, [r3, #5]
 80225fc:	0019      	movs	r1, r3
			+ (dateTime.minute * 60)
 80225fe:	003b      	movs	r3, r7
 8022600:	791b      	ldrb	r3, [r3, #4]
 8022602:	001a      	movs	r2, r3
 8022604:	0013      	movs	r3, r2
 8022606:	011b      	lsls	r3, r3, #4
 8022608:	1a9b      	subs	r3, r3, r2
 802260a:	009b      	lsls	r3, r3, #2
 802260c:	18c9      	adds	r1, r1, r3
			+ (dateTime.hour * 3600)
 802260e:	003b      	movs	r3, r7
 8022610:	78db      	ldrb	r3, [r3, #3]
 8022612:	001a      	movs	r2, r3
 8022614:	0013      	movs	r3, r2
 8022616:	011b      	lsls	r3, r3, #4
 8022618:	1a9b      	subs	r3, r3, r2
 802261a:	011a      	lsls	r2, r3, #4
 802261c:	1ad2      	subs	r2, r2, r3
 802261e:	0113      	lsls	r3, r2, #4
 8022620:	001a      	movs	r2, r3
 8022622:	0013      	movs	r3, r2
 8022624:	18c9      	adds	r1, r1, r3
			+ ((dateTime.day - 1) * 86400)
 8022626:	003b      	movs	r3, r7
 8022628:	789b      	ldrb	r3, [r3, #2]
 802262a:	1e5a      	subs	r2, r3, #1
 802262c:	0013      	movs	r3, r2
 802262e:	005b      	lsls	r3, r3, #1
 8022630:	189b      	adds	r3, r3, r2
 8022632:	011a      	lsls	r2, r3, #4
 8022634:	1ad2      	subs	r2, r2, r3
 8022636:	0113      	lsls	r3, r2, #4
 8022638:	1a9b      	subs	r3, r3, r2
 802263a:	01db      	lsls	r3, r3, #7
 802263c:	18ca      	adds	r2, r1, r3
			+ ((dateTime.month - 1) * 2592000)
 802263e:	003b      	movs	r3, r7
 8022640:	785b      	ldrb	r3, [r3, #1]
 8022642:	3b01      	subs	r3, #1
 8022644:	490b      	ldr	r1, [pc, #44]	; (8022674 <_dateTimeToSeconds+0x88>)
 8022646:	434b      	muls	r3, r1
 8022648:	18d1      	adds	r1, r2, r3
			+ (dateTime.year * 31104000));
 802264a:	003b      	movs	r3, r7
 802264c:	781b      	ldrb	r3, [r3, #0]
 802264e:	001a      	movs	r2, r3
 8022650:	0013      	movs	r3, r2
 8022652:	00db      	lsls	r3, r3, #3
 8022654:	189b      	adds	r3, r3, r2
 8022656:	011a      	lsls	r2, r3, #4
 8022658:	1ad2      	subs	r2, r2, r3
 802265a:	0113      	lsls	r3, r2, #4
 802265c:	1a9b      	subs	r3, r3, r2
 802265e:	011a      	lsls	r2, r3, #4
 8022660:	1ad2      	subs	r2, r2, r3
 8022662:	0293      	lsls	r3, r2, #10
 8022664:	001a      	movs	r2, r3
 8022666:	0013      	movs	r3, r2
 8022668:	18cb      	adds	r3, r1, r3
}
 802266a:	0018      	movs	r0, r3
 802266c:	46bd      	mov	sp, r7
 802266e:	b002      	add	sp, #8
 8022670:	bd80      	pop	{r7, pc}
 8022672:	46c0      	nop			; (mov r8, r8)
 8022674:	00278d00 	.word	0x00278d00

08022678 <rtcCalendarControl_init>:
 * Initializes the module and stores a pointer to the HAL RTC handle.
 *
 * Note: will not reinitialize if already initialized.
 */
RtcUtilsStatus rtcCalendarControl_init(RTC_HandleTypeDef* const hrtc)
{
 8022678:	b580      	push	{r7, lr}
 802267a:	b082      	sub	sp, #8
 802267c:	af00      	add	r7, sp, #0
 802267e:	6078      	str	r0, [r7, #4]
	// if an initialized RTC handle has been passed
	if (!IS_RTC_INIT(_rtc_handle))
 8022680:	4b09      	ldr	r3, [pc, #36]	; (80226a8 <rtcCalendarControl_init+0x30>)
 8022682:	681b      	ldr	r3, [r3, #0]
 8022684:	2b00      	cmp	r3, #0
 8022686:	d004      	beq.n	8022692 <rtcCalendarControl_init+0x1a>
 8022688:	4b07      	ldr	r3, [pc, #28]	; (80226a8 <rtcCalendarControl_init+0x30>)
 802268a:	681b      	ldr	r3, [r3, #0]
 802268c:	681b      	ldr	r3, [r3, #0]
 802268e:	2b00      	cmp	r3, #0
 8022690:	d104      	bne.n	802269c <rtcCalendarControl_init+0x24>
	{
		_rtc_handle = hrtc;		// store handle pointer
 8022692:	4b05      	ldr	r3, [pc, #20]	; (80226a8 <rtcCalendarControl_init+0x30>)
 8022694:	687a      	ldr	r2, [r7, #4]
 8022696:	601a      	str	r2, [r3, #0]
		return RTC_CALENDAR_CONTROL_OKAY;
 8022698:	2300      	movs	r3, #0
 802269a:	e000      	b.n	802269e <rtcCalendarControl_init+0x26>
	}

	// an invalid handle or uninitialized handle passed
	else
	{
		return RTC_CALENDAR_CONTROL_NOT_INIT;
 802269c:	2301      	movs	r3, #1
	}
}
 802269e:	0018      	movs	r0, r3
 80226a0:	46bd      	mov	sp, r7
 80226a2:	b002      	add	sp, #8
 80226a4:	bd80      	pop	{r7, pc}
 80226a6:	46c0      	nop			; (mov r8, r8)
 80226a8:	200083f8 	.word	0x200083f8

080226ac <rtcCalendarControl_setDateTime>:
 * Note: does not check if parameters are within correct range.
 */
RtcUtilsStatus rtcCalendarControl_setDateTime(const uint8_t year, const uint8_t month,
		const uint8_t day, const uint8_t hour, const uint8_t minute,
		const uint8_t second)
{
 80226ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80226ae:	b089      	sub	sp, #36	; 0x24
 80226b0:	af00      	add	r7, sp, #0
 80226b2:	0005      	movs	r5, r0
 80226b4:	000c      	movs	r4, r1
 80226b6:	0010      	movs	r0, r2
 80226b8:	0019      	movs	r1, r3
 80226ba:	1dfb      	adds	r3, r7, #7
 80226bc:	1c2a      	adds	r2, r5, #0
 80226be:	701a      	strb	r2, [r3, #0]
 80226c0:	1dbb      	adds	r3, r7, #6
 80226c2:	1c22      	adds	r2, r4, #0
 80226c4:	701a      	strb	r2, [r3, #0]
 80226c6:	1d7b      	adds	r3, r7, #5
 80226c8:	1c02      	adds	r2, r0, #0
 80226ca:	701a      	strb	r2, [r3, #0]
 80226cc:	1d3b      	adds	r3, r7, #4
 80226ce:	1c0a      	adds	r2, r1, #0
 80226d0:	701a      	strb	r2, [r3, #0]
	RTC_DateTypeDef date;
	RTC_TimeTypeDef time;

	// if module has been initialized
	if (IS_RTC_INIT(_rtc_handle))
 80226d2:	4b65      	ldr	r3, [pc, #404]	; (8022868 <rtcCalendarControl_setDateTime+0x1bc>)
 80226d4:	681b      	ldr	r3, [r3, #0]
 80226d6:	2b00      	cmp	r3, #0
 80226d8:	d100      	bne.n	80226dc <rtcCalendarControl_setDateTime+0x30>
 80226da:	e0bf      	b.n	802285c <rtcCalendarControl_setDateTime+0x1b0>
 80226dc:	4b62      	ldr	r3, [pc, #392]	; (8022868 <rtcCalendarControl_setDateTime+0x1bc>)
 80226de:	681b      	ldr	r3, [r3, #0]
 80226e0:	681b      	ldr	r3, [r3, #0]
 80226e2:	2b00      	cmp	r3, #0
 80226e4:	d100      	bne.n	80226e8 <rtcCalendarControl_setDateTime+0x3c>
 80226e6:	e0b9      	b.n	802285c <rtcCalendarControl_setDateTime+0x1b0>
	{
		// convert from decimal to BCD
		date.Year = ((year/10) << 4) | (year % 10);
 80226e8:	1dfb      	adds	r3, r7, #7
 80226ea:	781b      	ldrb	r3, [r3, #0]
 80226ec:	210a      	movs	r1, #10
 80226ee:	0018      	movs	r0, r3
 80226f0:	f7fd fd0a 	bl	8020108 <__udivsi3>
 80226f4:	0003      	movs	r3, r0
 80226f6:	b2db      	uxtb	r3, r3
 80226f8:	011b      	lsls	r3, r3, #4
 80226fa:	b25c      	sxtb	r4, r3
 80226fc:	1dfb      	adds	r3, r7, #7
 80226fe:	781b      	ldrb	r3, [r3, #0]
 8022700:	210a      	movs	r1, #10
 8022702:	0018      	movs	r0, r3
 8022704:	f7fd fd86 	bl	8020214 <__aeabi_uidivmod>
 8022708:	000b      	movs	r3, r1
 802270a:	b2db      	uxtb	r3, r3
 802270c:	b25b      	sxtb	r3, r3
 802270e:	4323      	orrs	r3, r4
 8022710:	b25b      	sxtb	r3, r3
 8022712:	b2da      	uxtb	r2, r3
 8022714:	251c      	movs	r5, #28
 8022716:	197b      	adds	r3, r7, r5
 8022718:	70da      	strb	r2, [r3, #3]
		date.Month = ((month/10) << 4) | (month % 10);
 802271a:	1dbb      	adds	r3, r7, #6
 802271c:	781b      	ldrb	r3, [r3, #0]
 802271e:	210a      	movs	r1, #10
 8022720:	0018      	movs	r0, r3
 8022722:	f7fd fcf1 	bl	8020108 <__udivsi3>
 8022726:	0003      	movs	r3, r0
 8022728:	b2db      	uxtb	r3, r3
 802272a:	011b      	lsls	r3, r3, #4
 802272c:	b25c      	sxtb	r4, r3
 802272e:	1dbb      	adds	r3, r7, #6
 8022730:	781b      	ldrb	r3, [r3, #0]
 8022732:	210a      	movs	r1, #10
 8022734:	0018      	movs	r0, r3
 8022736:	f7fd fd6d 	bl	8020214 <__aeabi_uidivmod>
 802273a:	000b      	movs	r3, r1
 802273c:	b2db      	uxtb	r3, r3
 802273e:	b25b      	sxtb	r3, r3
 8022740:	4323      	orrs	r3, r4
 8022742:	b25b      	sxtb	r3, r3
 8022744:	b2da      	uxtb	r2, r3
 8022746:	197b      	adds	r3, r7, r5
 8022748:	705a      	strb	r2, [r3, #1]
		date.Date = ((day/10) << 4) | (day % 10);
 802274a:	1d7b      	adds	r3, r7, #5
 802274c:	781b      	ldrb	r3, [r3, #0]
 802274e:	210a      	movs	r1, #10
 8022750:	0018      	movs	r0, r3
 8022752:	f7fd fcd9 	bl	8020108 <__udivsi3>
 8022756:	0003      	movs	r3, r0
 8022758:	b2db      	uxtb	r3, r3
 802275a:	011b      	lsls	r3, r3, #4
 802275c:	b25c      	sxtb	r4, r3
 802275e:	1d7b      	adds	r3, r7, #5
 8022760:	781b      	ldrb	r3, [r3, #0]
 8022762:	210a      	movs	r1, #10
 8022764:	0018      	movs	r0, r3
 8022766:	f7fd fd55 	bl	8020214 <__aeabi_uidivmod>
 802276a:	000b      	movs	r3, r1
 802276c:	b2db      	uxtb	r3, r3
 802276e:	b25b      	sxtb	r3, r3
 8022770:	4323      	orrs	r3, r4
 8022772:	b25b      	sxtb	r3, r3
 8022774:	b2da      	uxtb	r2, r3
 8022776:	197b      	adds	r3, r7, r5
 8022778:	709a      	strb	r2, [r3, #2]
		date.WeekDay = 0;
 802277a:	197b      	adds	r3, r7, r5
 802277c:	2200      	movs	r2, #0
 802277e:	701a      	strb	r2, [r3, #0]
		time.Hours = ((hour/10) << 4) | (hour % 10);
 8022780:	1d3b      	adds	r3, r7, #4
 8022782:	781b      	ldrb	r3, [r3, #0]
 8022784:	210a      	movs	r1, #10
 8022786:	0018      	movs	r0, r3
 8022788:	f7fd fcbe 	bl	8020108 <__udivsi3>
 802278c:	0003      	movs	r3, r0
 802278e:	b2db      	uxtb	r3, r3
 8022790:	011b      	lsls	r3, r3, #4
 8022792:	b25c      	sxtb	r4, r3
 8022794:	1d3b      	adds	r3, r7, #4
 8022796:	781b      	ldrb	r3, [r3, #0]
 8022798:	210a      	movs	r1, #10
 802279a:	0018      	movs	r0, r3
 802279c:	f7fd fd3a 	bl	8020214 <__aeabi_uidivmod>
 80227a0:	000b      	movs	r3, r1
 80227a2:	b2db      	uxtb	r3, r3
 80227a4:	b25b      	sxtb	r3, r3
 80227a6:	4323      	orrs	r3, r4
 80227a8:	b25b      	sxtb	r3, r3
 80227aa:	b2da      	uxtb	r2, r3
 80227ac:	2608      	movs	r6, #8
 80227ae:	19bb      	adds	r3, r7, r6
 80227b0:	701a      	strb	r2, [r3, #0]
		time.Minutes = ((minute/10) << 4) | (minute % 10);
 80227b2:	2330      	movs	r3, #48	; 0x30
 80227b4:	2208      	movs	r2, #8
 80227b6:	189b      	adds	r3, r3, r2
 80227b8:	19db      	adds	r3, r3, r7
 80227ba:	781b      	ldrb	r3, [r3, #0]
 80227bc:	210a      	movs	r1, #10
 80227be:	0018      	movs	r0, r3
 80227c0:	f7fd fca2 	bl	8020108 <__udivsi3>
 80227c4:	0003      	movs	r3, r0
 80227c6:	b2db      	uxtb	r3, r3
 80227c8:	011b      	lsls	r3, r3, #4
 80227ca:	b25c      	sxtb	r4, r3
 80227cc:	2330      	movs	r3, #48	; 0x30
 80227ce:	2208      	movs	r2, #8
 80227d0:	189b      	adds	r3, r3, r2
 80227d2:	19db      	adds	r3, r3, r7
 80227d4:	781b      	ldrb	r3, [r3, #0]
 80227d6:	210a      	movs	r1, #10
 80227d8:	0018      	movs	r0, r3
 80227da:	f7fd fd1b 	bl	8020214 <__aeabi_uidivmod>
 80227de:	000b      	movs	r3, r1
 80227e0:	b2db      	uxtb	r3, r3
 80227e2:	b25b      	sxtb	r3, r3
 80227e4:	4323      	orrs	r3, r4
 80227e6:	b25b      	sxtb	r3, r3
 80227e8:	b2da      	uxtb	r2, r3
 80227ea:	19bb      	adds	r3, r7, r6
 80227ec:	705a      	strb	r2, [r3, #1]
		time.Seconds = ((second/10) << 4) | (second % 10);
 80227ee:	2334      	movs	r3, #52	; 0x34
 80227f0:	2208      	movs	r2, #8
 80227f2:	189b      	adds	r3, r3, r2
 80227f4:	19db      	adds	r3, r3, r7
 80227f6:	781b      	ldrb	r3, [r3, #0]
 80227f8:	210a      	movs	r1, #10
 80227fa:	0018      	movs	r0, r3
 80227fc:	f7fd fc84 	bl	8020108 <__udivsi3>
 8022800:	0003      	movs	r3, r0
 8022802:	b2db      	uxtb	r3, r3
 8022804:	011b      	lsls	r3, r3, #4
 8022806:	b25c      	sxtb	r4, r3
 8022808:	2334      	movs	r3, #52	; 0x34
 802280a:	2208      	movs	r2, #8
 802280c:	189b      	adds	r3, r3, r2
 802280e:	19db      	adds	r3, r3, r7
 8022810:	781b      	ldrb	r3, [r3, #0]
 8022812:	210a      	movs	r1, #10
 8022814:	0018      	movs	r0, r3
 8022816:	f7fd fcfd 	bl	8020214 <__aeabi_uidivmod>
 802281a:	000b      	movs	r3, r1
 802281c:	b2db      	uxtb	r3, r3
 802281e:	b25b      	sxtb	r3, r3
 8022820:	4323      	orrs	r3, r4
 8022822:	b25b      	sxtb	r3, r3
 8022824:	b2da      	uxtb	r2, r3
 8022826:	19bb      	adds	r3, r7, r6
 8022828:	709a      	strb	r2, [r3, #2]

		// Set the date.
		if (HAL_RTC_SetDate(_rtc_handle, &date, RTC_FORMAT_BCD) != HAL_OK) {
 802282a:	4b0f      	ldr	r3, [pc, #60]	; (8022868 <rtcCalendarControl_setDateTime+0x1bc>)
 802282c:	681b      	ldr	r3, [r3, #0]
 802282e:	1979      	adds	r1, r7, r5
 8022830:	2201      	movs	r2, #1
 8022832:	0018      	movs	r0, r3
 8022834:	f7fe ff8a 	bl	802174c <HAL_RTC_SetDate>
 8022838:	1e03      	subs	r3, r0, #0
 802283a:	d001      	beq.n	8022840 <rtcCalendarControl_setDateTime+0x194>
			// HAL timeout
			return RTC_CALENDAR_CONTROL_TIMEOUT;
 802283c:	2302      	movs	r3, #2
 802283e:	e00e      	b.n	802285e <rtcCalendarControl_setDateTime+0x1b2>
		}

		// Set the time.
		if (HAL_RTC_SetTime(_rtc_handle, &time, RTC_FORMAT_BCD) != HAL_OK) {
 8022840:	4b09      	ldr	r3, [pc, #36]	; (8022868 <rtcCalendarControl_setDateTime+0x1bc>)
 8022842:	681b      	ldr	r3, [r3, #0]
 8022844:	2208      	movs	r2, #8
 8022846:	18b9      	adds	r1, r7, r2
 8022848:	2201      	movs	r2, #1
 802284a:	0018      	movs	r0, r3
 802284c:	f7fe fe72 	bl	8021534 <HAL_RTC_SetTime>
 8022850:	1e03      	subs	r3, r0, #0
 8022852:	d001      	beq.n	8022858 <rtcCalendarControl_setDateTime+0x1ac>
			// HAL timeout
			return RTC_CALENDAR_CONTROL_TIMEOUT;
 8022854:	2302      	movs	r3, #2
 8022856:	e002      	b.n	802285e <rtcCalendarControl_setDateTime+0x1b2>
		}

		return RTC_CALENDAR_CONTROL_OKAY;
 8022858:	2300      	movs	r3, #0
 802285a:	e000      	b.n	802285e <rtcCalendarControl_setDateTime+0x1b2>
	}

	// the module has not been initialized
	else
	{
		return RTC_CALENDAR_CONTROL_NOT_INIT;
 802285c:	2301      	movs	r3, #1
	}
}
 802285e:	0018      	movs	r0, r3
 8022860:	46bd      	mov	sp, r7
 8022862:	b009      	add	sp, #36	; 0x24
 8022864:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8022866:	46c0      	nop			; (mov r8, r8)
 8022868:	200083f8 	.word	0x200083f8

0802286c <rtcCalendarControl_getDateTime>:
 * Gets the date and time within the RTC.
 */
RtcUtilsStatus rtcCalendarControl_getDateTime(uint8_t* const year, uint8_t* const month,
		uint8_t* const day, uint8_t* const hour, uint8_t* const minute,
		uint8_t* const second)
{
 802286c:	b5b0      	push	{r4, r5, r7, lr}
 802286e:	b08a      	sub	sp, #40	; 0x28
 8022870:	af00      	add	r7, sp, #0
 8022872:	60f8      	str	r0, [r7, #12]
 8022874:	60b9      	str	r1, [r7, #8]
 8022876:	607a      	str	r2, [r7, #4]
 8022878:	603b      	str	r3, [r7, #0]
	RTC_TimeTypeDef time = {0};
 802287a:	2414      	movs	r4, #20
 802287c:	193b      	adds	r3, r7, r4
 802287e:	0018      	movs	r0, r3
 8022880:	2314      	movs	r3, #20
 8022882:	001a      	movs	r2, r3
 8022884:	2100      	movs	r1, #0
 8022886:	f000 fa38 	bl	8022cfa <memset>
	RTC_DateTypeDef date = {0};
 802288a:	2510      	movs	r5, #16
 802288c:	197b      	adds	r3, r7, r5
 802288e:	2200      	movs	r2, #0
 8022890:	601a      	str	r2, [r3, #0]

	// if the module has been initialized
	if (IS_RTC_INIT(_rtc_handle))
 8022892:	4b4a      	ldr	r3, [pc, #296]	; (80229bc <rtcCalendarControl_getDateTime+0x150>)
 8022894:	681b      	ldr	r3, [r3, #0]
 8022896:	2b00      	cmp	r3, #0
 8022898:	d100      	bne.n	802289c <rtcCalendarControl_getDateTime+0x30>
 802289a:	e089      	b.n	80229b0 <rtcCalendarControl_getDateTime+0x144>
 802289c:	4b47      	ldr	r3, [pc, #284]	; (80229bc <rtcCalendarControl_getDateTime+0x150>)
 802289e:	681b      	ldr	r3, [r3, #0]
 80228a0:	681b      	ldr	r3, [r3, #0]
 80228a2:	2b00      	cmp	r3, #0
 80228a4:	d100      	bne.n	80228a8 <rtcCalendarControl_getDateTime+0x3c>
 80228a6:	e083      	b.n	80229b0 <rtcCalendarControl_getDateTime+0x144>
	{
		// Get the time and the date.
		HAL_RTC_GetTime(_rtc_handle, &time, RTC_FORMAT_BCD);
 80228a8:	4b44      	ldr	r3, [pc, #272]	; (80229bc <rtcCalendarControl_getDateTime+0x150>)
 80228aa:	681b      	ldr	r3, [r3, #0]
 80228ac:	1939      	adds	r1, r7, r4
 80228ae:	2201      	movs	r2, #1
 80228b0:	0018      	movs	r0, r3
 80228b2:	f7fe fee7 	bl	8021684 <HAL_RTC_GetTime>
		HAL_RTC_GetDate(_rtc_handle, &date, RTC_FORMAT_BCD);
 80228b6:	4b41      	ldr	r3, [pc, #260]	; (80229bc <rtcCalendarControl_getDateTime+0x150>)
 80228b8:	681b      	ldr	r3, [r3, #0]
 80228ba:	1979      	adds	r1, r7, r5
 80228bc:	2201      	movs	r2, #1
 80228be:	0018      	movs	r0, r3
 80228c0:	f7fe ffd4 	bl	802186c <HAL_RTC_GetDate>

		// Return through parameters
		*year = ((date.Year & 0xF0) >> 4) * 10 + (date.Year & 0x0F);
 80228c4:	0029      	movs	r1, r5
 80228c6:	197b      	adds	r3, r7, r5
 80228c8:	78db      	ldrb	r3, [r3, #3]
 80228ca:	091b      	lsrs	r3, r3, #4
 80228cc:	b2db      	uxtb	r3, r3
 80228ce:	1c1a      	adds	r2, r3, #0
 80228d0:	0092      	lsls	r2, r2, #2
 80228d2:	18d3      	adds	r3, r2, r3
 80228d4:	18db      	adds	r3, r3, r3
 80228d6:	b2da      	uxtb	r2, r3
 80228d8:	0008      	movs	r0, r1
 80228da:	187b      	adds	r3, r7, r1
 80228dc:	78db      	ldrb	r3, [r3, #3]
 80228de:	210f      	movs	r1, #15
 80228e0:	400b      	ands	r3, r1
 80228e2:	b2db      	uxtb	r3, r3
 80228e4:	18d3      	adds	r3, r2, r3
 80228e6:	b2da      	uxtb	r2, r3
 80228e8:	68fb      	ldr	r3, [r7, #12]
 80228ea:	701a      	strb	r2, [r3, #0]
		*month = ((date.Month & 0xF0) >> 4) * 10 + (date.Month & 0x0F);
 80228ec:	0001      	movs	r1, r0
 80228ee:	187b      	adds	r3, r7, r1
 80228f0:	785b      	ldrb	r3, [r3, #1]
 80228f2:	091b      	lsrs	r3, r3, #4
 80228f4:	b2db      	uxtb	r3, r3
 80228f6:	1c1a      	adds	r2, r3, #0
 80228f8:	0092      	lsls	r2, r2, #2
 80228fa:	18d3      	adds	r3, r2, r3
 80228fc:	18db      	adds	r3, r3, r3
 80228fe:	b2da      	uxtb	r2, r3
 8022900:	0008      	movs	r0, r1
 8022902:	187b      	adds	r3, r7, r1
 8022904:	785b      	ldrb	r3, [r3, #1]
 8022906:	210f      	movs	r1, #15
 8022908:	400b      	ands	r3, r1
 802290a:	b2db      	uxtb	r3, r3
 802290c:	18d3      	adds	r3, r2, r3
 802290e:	b2da      	uxtb	r2, r3
 8022910:	68bb      	ldr	r3, [r7, #8]
 8022912:	701a      	strb	r2, [r3, #0]
		*day = ((date.Date & 0xF0) >> 4) * 10 + (date.Date & 0x0F);
 8022914:	0001      	movs	r1, r0
 8022916:	187b      	adds	r3, r7, r1
 8022918:	789b      	ldrb	r3, [r3, #2]
 802291a:	091b      	lsrs	r3, r3, #4
 802291c:	b2db      	uxtb	r3, r3
 802291e:	1c1a      	adds	r2, r3, #0
 8022920:	0092      	lsls	r2, r2, #2
 8022922:	18d3      	adds	r3, r2, r3
 8022924:	18db      	adds	r3, r3, r3
 8022926:	b2da      	uxtb	r2, r3
 8022928:	187b      	adds	r3, r7, r1
 802292a:	789b      	ldrb	r3, [r3, #2]
 802292c:	210f      	movs	r1, #15
 802292e:	400b      	ands	r3, r1
 8022930:	b2db      	uxtb	r3, r3
 8022932:	18d3      	adds	r3, r2, r3
 8022934:	b2da      	uxtb	r2, r3
 8022936:	687b      	ldr	r3, [r7, #4]
 8022938:	701a      	strb	r2, [r3, #0]
		*hour = ((time.Hours & 0xF0) >> 4) * 10 + (time.Hours & 0x0F);
 802293a:	193b      	adds	r3, r7, r4
 802293c:	781b      	ldrb	r3, [r3, #0]
 802293e:	091b      	lsrs	r3, r3, #4
 8022940:	b2db      	uxtb	r3, r3
 8022942:	1c1a      	adds	r2, r3, #0
 8022944:	0092      	lsls	r2, r2, #2
 8022946:	18d3      	adds	r3, r2, r3
 8022948:	18db      	adds	r3, r3, r3
 802294a:	b2da      	uxtb	r2, r3
 802294c:	193b      	adds	r3, r7, r4
 802294e:	781b      	ldrb	r3, [r3, #0]
 8022950:	210f      	movs	r1, #15
 8022952:	400b      	ands	r3, r1
 8022954:	b2db      	uxtb	r3, r3
 8022956:	18d3      	adds	r3, r2, r3
 8022958:	b2da      	uxtb	r2, r3
 802295a:	683b      	ldr	r3, [r7, #0]
 802295c:	701a      	strb	r2, [r3, #0]
		*minute = ((time.Minutes & 0xF0) >> 4) * 10 + (time.Minutes & 0x0F);
 802295e:	0021      	movs	r1, r4
 8022960:	193b      	adds	r3, r7, r4
 8022962:	785b      	ldrb	r3, [r3, #1]
 8022964:	091b      	lsrs	r3, r3, #4
 8022966:	b2db      	uxtb	r3, r3
 8022968:	1c1a      	adds	r2, r3, #0
 802296a:	0092      	lsls	r2, r2, #2
 802296c:	18d3      	adds	r3, r2, r3
 802296e:	18db      	adds	r3, r3, r3
 8022970:	b2da      	uxtb	r2, r3
 8022972:	0008      	movs	r0, r1
 8022974:	187b      	adds	r3, r7, r1
 8022976:	785b      	ldrb	r3, [r3, #1]
 8022978:	210f      	movs	r1, #15
 802297a:	400b      	ands	r3, r1
 802297c:	b2db      	uxtb	r3, r3
 802297e:	18d3      	adds	r3, r2, r3
 8022980:	b2da      	uxtb	r2, r3
 8022982:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8022984:	701a      	strb	r2, [r3, #0]
		*second = ((time.Seconds & 0xF0) >> 4) * 10 + (time.Seconds & 0x0F);
 8022986:	0001      	movs	r1, r0
 8022988:	187b      	adds	r3, r7, r1
 802298a:	789b      	ldrb	r3, [r3, #2]
 802298c:	091b      	lsrs	r3, r3, #4
 802298e:	b2db      	uxtb	r3, r3
 8022990:	1c1a      	adds	r2, r3, #0
 8022992:	0092      	lsls	r2, r2, #2
 8022994:	18d3      	adds	r3, r2, r3
 8022996:	18db      	adds	r3, r3, r3
 8022998:	b2da      	uxtb	r2, r3
 802299a:	187b      	adds	r3, r7, r1
 802299c:	789b      	ldrb	r3, [r3, #2]
 802299e:	210f      	movs	r1, #15
 80229a0:	400b      	ands	r3, r1
 80229a2:	b2db      	uxtb	r3, r3
 80229a4:	18d3      	adds	r3, r2, r3
 80229a6:	b2da      	uxtb	r2, r3
 80229a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80229aa:	701a      	strb	r2, [r3, #0]

		return RTC_CALENDAR_CONTROL_OKAY;
 80229ac:	2300      	movs	r3, #0
 80229ae:	e000      	b.n	80229b2 <rtcCalendarControl_getDateTime+0x146>
	}

	// the module has not been initialized
	else
	{
		return RTC_CALENDAR_CONTROL_NOT_INIT;
 80229b0:	2301      	movs	r3, #1
	}
}
 80229b2:	0018      	movs	r0, r3
 80229b4:	46bd      	mov	sp, r7
 80229b6:	b00a      	add	sp, #40	; 0x28
 80229b8:	bdb0      	pop	{r4, r5, r7, pc}
 80229ba:	46c0      	nop			; (mov r8, r8)
 80229bc:	200083f8 	.word	0x200083f8

080229c0 <rtcCalendarControl_setAlarm_A>:
 *
 * Note: does not validate that parameters are within valid range.
 */
RtcUtilsStatus rtcCalendarControl_setAlarm_A(const uint8_t day, const uint8_t hour,
		const uint8_t minute, const uint8_t second)
{
 80229c0:	b5b0      	push	{r4, r5, r7, lr}
 80229c2:	b08e      	sub	sp, #56	; 0x38
 80229c4:	af00      	add	r7, sp, #0
 80229c6:	0005      	movs	r5, r0
 80229c8:	000c      	movs	r4, r1
 80229ca:	0010      	movs	r0, r2
 80229cc:	0019      	movs	r1, r3
 80229ce:	1dfb      	adds	r3, r7, #7
 80229d0:	1c2a      	adds	r2, r5, #0
 80229d2:	701a      	strb	r2, [r3, #0]
 80229d4:	1dbb      	adds	r3, r7, #6
 80229d6:	1c22      	adds	r2, r4, #0
 80229d8:	701a      	strb	r2, [r3, #0]
 80229da:	1d7b      	adds	r3, r7, #5
 80229dc:	1c02      	adds	r2, r0, #0
 80229de:	701a      	strb	r2, [r3, #0]
 80229e0:	1d3b      	adds	r3, r7, #4
 80229e2:	1c0a      	adds	r2, r1, #0
 80229e4:	701a      	strb	r2, [r3, #0]
  RTC_AlarmTypeDef alarm = {0};
 80229e6:	250c      	movs	r5, #12
 80229e8:	197b      	adds	r3, r7, r5
 80229ea:	0018      	movs	r0, r3
 80229ec:	232c      	movs	r3, #44	; 0x2c
 80229ee:	001a      	movs	r2, r3
 80229f0:	2100      	movs	r1, #0
 80229f2:	f000 f982 	bl	8022cfa <memset>

  // if the module has been initialized
  if (IS_RTC_INIT(_rtc_handle))
 80229f6:	4b48      	ldr	r3, [pc, #288]	; (8022b18 <rtcCalendarControl_setAlarm_A+0x158>)
 80229f8:	681b      	ldr	r3, [r3, #0]
 80229fa:	2b00      	cmp	r3, #0
 80229fc:	d100      	bne.n	8022a00 <rtcCalendarControl_setAlarm_A+0x40>
 80229fe:	e086      	b.n	8022b0e <rtcCalendarControl_setAlarm_A+0x14e>
 8022a00:	4b45      	ldr	r3, [pc, #276]	; (8022b18 <rtcCalendarControl_setAlarm_A+0x158>)
 8022a02:	681b      	ldr	r3, [r3, #0]
 8022a04:	681b      	ldr	r3, [r3, #0]
 8022a06:	2b00      	cmp	r3, #0
 8022a08:	d100      	bne.n	8022a0c <rtcCalendarControl_setAlarm_A+0x4c>
 8022a0a:	e080      	b.n	8022b0e <rtcCalendarControl_setAlarm_A+0x14e>
  {
	  // settings for alarm
	  // convert decimal to BCD
	  alarm.AlarmDateWeekDay = ((day/10) << 4) | (day % 10);
 8022a0c:	1dfb      	adds	r3, r7, #7
 8022a0e:	781b      	ldrb	r3, [r3, #0]
 8022a10:	210a      	movs	r1, #10
 8022a12:	0018      	movs	r0, r3
 8022a14:	f7fd fb78 	bl	8020108 <__udivsi3>
 8022a18:	0003      	movs	r3, r0
 8022a1a:	b2db      	uxtb	r3, r3
 8022a1c:	011b      	lsls	r3, r3, #4
 8022a1e:	b25c      	sxtb	r4, r3
 8022a20:	1dfb      	adds	r3, r7, #7
 8022a22:	781b      	ldrb	r3, [r3, #0]
 8022a24:	210a      	movs	r1, #10
 8022a26:	0018      	movs	r0, r3
 8022a28:	f7fd fbf4 	bl	8020214 <__aeabi_uidivmod>
 8022a2c:	000b      	movs	r3, r1
 8022a2e:	b2db      	uxtb	r3, r3
 8022a30:	b25b      	sxtb	r3, r3
 8022a32:	4323      	orrs	r3, r4
 8022a34:	b25b      	sxtb	r3, r3
 8022a36:	b2d9      	uxtb	r1, r3
 8022a38:	197b      	adds	r3, r7, r5
 8022a3a:	2224      	movs	r2, #36	; 0x24
 8022a3c:	5499      	strb	r1, [r3, r2]
	  alarm.AlarmTime.Hours = ((hour/10) << 4) | (hour % 10);
 8022a3e:	1dbb      	adds	r3, r7, #6
 8022a40:	781b      	ldrb	r3, [r3, #0]
 8022a42:	210a      	movs	r1, #10
 8022a44:	0018      	movs	r0, r3
 8022a46:	f7fd fb5f 	bl	8020108 <__udivsi3>
 8022a4a:	0003      	movs	r3, r0
 8022a4c:	b2db      	uxtb	r3, r3
 8022a4e:	011b      	lsls	r3, r3, #4
 8022a50:	b25c      	sxtb	r4, r3
 8022a52:	1dbb      	adds	r3, r7, #6
 8022a54:	781b      	ldrb	r3, [r3, #0]
 8022a56:	210a      	movs	r1, #10
 8022a58:	0018      	movs	r0, r3
 8022a5a:	f7fd fbdb 	bl	8020214 <__aeabi_uidivmod>
 8022a5e:	000b      	movs	r3, r1
 8022a60:	b2db      	uxtb	r3, r3
 8022a62:	b25b      	sxtb	r3, r3
 8022a64:	4323      	orrs	r3, r4
 8022a66:	b25b      	sxtb	r3, r3
 8022a68:	b2da      	uxtb	r2, r3
 8022a6a:	197b      	adds	r3, r7, r5
 8022a6c:	701a      	strb	r2, [r3, #0]
	  alarm.AlarmTime.Minutes = ((minute/10) << 4) | (minute % 10);
 8022a6e:	1d7b      	adds	r3, r7, #5
 8022a70:	781b      	ldrb	r3, [r3, #0]
 8022a72:	210a      	movs	r1, #10
 8022a74:	0018      	movs	r0, r3
 8022a76:	f7fd fb47 	bl	8020108 <__udivsi3>
 8022a7a:	0003      	movs	r3, r0
 8022a7c:	b2db      	uxtb	r3, r3
 8022a7e:	011b      	lsls	r3, r3, #4
 8022a80:	b25c      	sxtb	r4, r3
 8022a82:	1d7b      	adds	r3, r7, #5
 8022a84:	781b      	ldrb	r3, [r3, #0]
 8022a86:	210a      	movs	r1, #10
 8022a88:	0018      	movs	r0, r3
 8022a8a:	f7fd fbc3 	bl	8020214 <__aeabi_uidivmod>
 8022a8e:	000b      	movs	r3, r1
 8022a90:	b2db      	uxtb	r3, r3
 8022a92:	b25b      	sxtb	r3, r3
 8022a94:	4323      	orrs	r3, r4
 8022a96:	b25b      	sxtb	r3, r3
 8022a98:	b2da      	uxtb	r2, r3
 8022a9a:	197b      	adds	r3, r7, r5
 8022a9c:	705a      	strb	r2, [r3, #1]
	  alarm.AlarmTime.Seconds = ((second/10) << 4) | (second % 10);
 8022a9e:	1d3b      	adds	r3, r7, #4
 8022aa0:	781b      	ldrb	r3, [r3, #0]
 8022aa2:	210a      	movs	r1, #10
 8022aa4:	0018      	movs	r0, r3
 8022aa6:	f7fd fb2f 	bl	8020108 <__udivsi3>
 8022aaa:	0003      	movs	r3, r0
 8022aac:	b2db      	uxtb	r3, r3
 8022aae:	011b      	lsls	r3, r3, #4
 8022ab0:	b25c      	sxtb	r4, r3
 8022ab2:	1d3b      	adds	r3, r7, #4
 8022ab4:	781b      	ldrb	r3, [r3, #0]
 8022ab6:	210a      	movs	r1, #10
 8022ab8:	0018      	movs	r0, r3
 8022aba:	f7fd fbab 	bl	8020214 <__aeabi_uidivmod>
 8022abe:	000b      	movs	r3, r1
 8022ac0:	b2db      	uxtb	r3, r3
 8022ac2:	b25b      	sxtb	r3, r3
 8022ac4:	4323      	orrs	r3, r4
 8022ac6:	b25b      	sxtb	r3, r3
 8022ac8:	b2da      	uxtb	r2, r3
 8022aca:	197b      	adds	r3, r7, r5
 8022acc:	709a      	strb	r2, [r3, #2]
	  // other settings for setting alarm
	  alarm.AlarmTime.SubSeconds = 0x0;
 8022ace:	0029      	movs	r1, r5
 8022ad0:	187b      	adds	r3, r7, r1
 8022ad2:	2200      	movs	r2, #0
 8022ad4:	605a      	str	r2, [r3, #4]
	  alarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 8022ad6:	187b      	adds	r3, r7, r1
 8022ad8:	2200      	movs	r2, #0
 8022ada:	60da      	str	r2, [r3, #12]
	  alarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 8022adc:	187b      	adds	r3, r7, r1
 8022ade:	2200      	movs	r2, #0
 8022ae0:	611a      	str	r2, [r3, #16]
	  alarm.AlarmMask = RTC_ALARMMASK_NONE;
 8022ae2:	187b      	adds	r3, r7, r1
 8022ae4:	2200      	movs	r2, #0
 8022ae6:	615a      	str	r2, [r3, #20]
	  alarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 8022ae8:	187b      	adds	r3, r7, r1
 8022aea:	2200      	movs	r2, #0
 8022aec:	619a      	str	r2, [r3, #24]
	  alarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 8022aee:	187b      	adds	r3, r7, r1
 8022af0:	2200      	movs	r2, #0
 8022af2:	621a      	str	r2, [r3, #32]
	  alarm.Alarm = RTC_ALARM_A;
 8022af4:	187b      	adds	r3, r7, r1
 8022af6:	2280      	movs	r2, #128	; 0x80
 8022af8:	0052      	lsls	r2, r2, #1
 8022afa:	629a      	str	r2, [r3, #40]	; 0x28

	  // set the alarm and enable an interrupt to fire
	  HAL_RTC_SetAlarm_IT(_rtc_handle, &alarm, RTC_FORMAT_BCD);
 8022afc:	4b06      	ldr	r3, [pc, #24]	; (8022b18 <rtcCalendarControl_setAlarm_A+0x158>)
 8022afe:	681b      	ldr	r3, [r3, #0]
 8022b00:	1879      	adds	r1, r7, r1
 8022b02:	2201      	movs	r2, #1
 8022b04:	0018      	movs	r0, r3
 8022b06:	f7fe feff 	bl	8021908 <HAL_RTC_SetAlarm_IT>

	  return RTC_CALENDAR_CONTROL_OKAY;
 8022b0a:	2300      	movs	r3, #0
 8022b0c:	e000      	b.n	8022b10 <rtcCalendarControl_setAlarm_A+0x150>
  }

  // the module has not been initialized
  else
  {
	  return RTC_CALENDAR_CONTROL_NOT_INIT;
 8022b0e:	2301      	movs	r3, #1
  }
}
 8022b10:	0018      	movs	r0, r3
 8022b12:	46bd      	mov	sp, r7
 8022b14:	b00e      	add	sp, #56	; 0x38
 8022b16:	bdb0      	pop	{r4, r5, r7, pc}
 8022b18:	200083f8 	.word	0x200083f8

08022b1c <rtcCalendarControl_diableAlarm_A>:
/* rtcCalendarControl_diableAlarm_A
 *
 * Disables alarm A from firing.
 */
RtcUtilsStatus rtcCalendarControl_diableAlarm_A(void)
{
 8022b1c:	b580      	push	{r7, lr}
 8022b1e:	af00      	add	r7, sp, #0
	// if the module has been initlaized
	if (IS_RTC_INIT(_rtc_handle))
 8022b20:	4b0b      	ldr	r3, [pc, #44]	; (8022b50 <rtcCalendarControl_diableAlarm_A+0x34>)
 8022b22:	681b      	ldr	r3, [r3, #0]
 8022b24:	2b00      	cmp	r3, #0
 8022b26:	d00e      	beq.n	8022b46 <rtcCalendarControl_diableAlarm_A+0x2a>
 8022b28:	4b09      	ldr	r3, [pc, #36]	; (8022b50 <rtcCalendarControl_diableAlarm_A+0x34>)
 8022b2a:	681b      	ldr	r3, [r3, #0]
 8022b2c:	681b      	ldr	r3, [r3, #0]
 8022b2e:	2b00      	cmp	r3, #0
 8022b30:	d009      	beq.n	8022b46 <rtcCalendarControl_diableAlarm_A+0x2a>
	{
		HAL_RTC_DeactivateAlarm(_rtc_handle, RTC_ALARM_A);
 8022b32:	4b07      	ldr	r3, [pc, #28]	; (8022b50 <rtcCalendarControl_diableAlarm_A+0x34>)
 8022b34:	681b      	ldr	r3, [r3, #0]
 8022b36:	2280      	movs	r2, #128	; 0x80
 8022b38:	0052      	lsls	r2, r2, #1
 8022b3a:	0011      	movs	r1, r2
 8022b3c:	0018      	movs	r0, r3
 8022b3e:	f7fe fff7 	bl	8021b30 <HAL_RTC_DeactivateAlarm>

		return RTC_CALENDAR_CONTROL_OKAY;
 8022b42:	2300      	movs	r3, #0
 8022b44:	e000      	b.n	8022b48 <rtcCalendarControl_diableAlarm_A+0x2c>
	}

	// the module has not been initialized
	else
	{
		return RTC_CALENDAR_CONTROL_NOT_INIT;
 8022b46:	2301      	movs	r3, #1
	}
}
 8022b48:	0018      	movs	r0, r3
 8022b4a:	46bd      	mov	sp, r7
 8022b4c:	bd80      	pop	{r7, pc}
 8022b4e:	46c0      	nop			; (mov r8, r8)
 8022b50:	200083f8 	.word	0x200083f8

08022b54 <LL_C2_AHB2_GRP1_EnableClock>:
{
 8022b54:	b580      	push	{r7, lr}
 8022b56:	b084      	sub	sp, #16
 8022b58:	af00      	add	r7, sp, #0
 8022b5a:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->C2AHB2ENR, Periphs);
 8022b5c:	23b0      	movs	r3, #176	; 0xb0
 8022b5e:	05da      	lsls	r2, r3, #23
 8022b60:	23a6      	movs	r3, #166	; 0xa6
 8022b62:	005b      	lsls	r3, r3, #1
 8022b64:	58d1      	ldr	r1, [r2, r3]
 8022b66:	23b0      	movs	r3, #176	; 0xb0
 8022b68:	05da      	lsls	r2, r3, #23
 8022b6a:	687b      	ldr	r3, [r7, #4]
 8022b6c:	4319      	orrs	r1, r3
 8022b6e:	23a6      	movs	r3, #166	; 0xa6
 8022b70:	005b      	lsls	r3, r3, #1
 8022b72:	50d1      	str	r1, [r2, r3]
  tmpreg = READ_BIT(RCC->C2AHB2ENR, Periphs);
 8022b74:	23b0      	movs	r3, #176	; 0xb0
 8022b76:	05da      	lsls	r2, r3, #23
 8022b78:	23a6      	movs	r3, #166	; 0xa6
 8022b7a:	005b      	lsls	r3, r3, #1
 8022b7c:	58d3      	ldr	r3, [r2, r3]
 8022b7e:	687a      	ldr	r2, [r7, #4]
 8022b80:	4013      	ands	r3, r2
 8022b82:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8022b84:	68fb      	ldr	r3, [r7, #12]
}
 8022b86:	46c0      	nop			; (mov r8, r8)
 8022b88:	46bd      	mov	sp, r7
 8022b8a:	b004      	add	sp, #16
 8022b8c:	bd80      	pop	{r7, pc}

08022b8e <LL_C2_AHB2_GRP1_IsEnabledClock>:
{
 8022b8e:	b580      	push	{r7, lr}
 8022b90:	b082      	sub	sp, #8
 8022b92:	af00      	add	r7, sp, #0
 8022b94:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(RCC->C2AHB2ENR, Periphs) == (Periphs)) ? 1UL : 0UL);
 8022b96:	23b0      	movs	r3, #176	; 0xb0
 8022b98:	05da      	lsls	r2, r3, #23
 8022b9a:	23a6      	movs	r3, #166	; 0xa6
 8022b9c:	005b      	lsls	r3, r3, #1
 8022b9e:	58d3      	ldr	r3, [r2, r3]
 8022ba0:	687a      	ldr	r2, [r7, #4]
 8022ba2:	4013      	ands	r3, r2
 8022ba4:	687a      	ldr	r2, [r7, #4]
 8022ba6:	429a      	cmp	r2, r3
 8022ba8:	d101      	bne.n	8022bae <LL_C2_AHB2_GRP1_IsEnabledClock+0x20>
 8022baa:	2301      	movs	r3, #1
 8022bac:	e000      	b.n	8022bb0 <LL_C2_AHB2_GRP1_IsEnabledClock+0x22>
 8022bae:	2300      	movs	r3, #0
}
 8022bb0:	0018      	movs	r0, r3
 8022bb2:	46bd      	mov	sp, r7
 8022bb4:	b002      	add	sp, #8
 8022bb6:	bd80      	pop	{r7, pc}

08022bb8 <LL_C2_AHB2_GRP1_DisableClock>:
{
 8022bb8:	b580      	push	{r7, lr}
 8022bba:	b082      	sub	sp, #8
 8022bbc:	af00      	add	r7, sp, #0
 8022bbe:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(RCC->C2AHB2ENR, Periphs);
 8022bc0:	23b0      	movs	r3, #176	; 0xb0
 8022bc2:	05da      	lsls	r2, r3, #23
 8022bc4:	23a6      	movs	r3, #166	; 0xa6
 8022bc6:	005b      	lsls	r3, r3, #1
 8022bc8:	58d3      	ldr	r3, [r2, r3]
 8022bca:	687a      	ldr	r2, [r7, #4]
 8022bcc:	43d1      	mvns	r1, r2
 8022bce:	22b0      	movs	r2, #176	; 0xb0
 8022bd0:	05d2      	lsls	r2, r2, #23
 8022bd2:	4019      	ands	r1, r3
 8022bd4:	23a6      	movs	r3, #166	; 0xa6
 8022bd6:	005b      	lsls	r3, r3, #1
 8022bd8:	50d1      	str	r1, [r2, r3]
}
 8022bda:	46c0      	nop			; (mov r8, r8)
 8022bdc:	46bd      	mov	sp, r7
 8022bde:	b002      	add	sp, #8
 8022be0:	bd80      	pop	{r7, pc}
	...

08022be4 <activate_led>:

/* Activate LED
 *
 * Turns on an LED on the Nucleo board.
 */
void activate_led(LED_COLOR led) {
 8022be4:	b590      	push	{r4, r7, lr}
 8022be6:	b089      	sub	sp, #36	; 0x24
 8022be8:	af00      	add	r7, sp, #0
 8022bea:	0002      	movs	r2, r0
 8022bec:	1dbb      	adds	r3, r7, #6
 8022bee:	801a      	strh	r2, [r3, #0]
  // Start the GPIO clock the LED is attached to.
  gpioB_isEnabled = __HAL_RCC_GPIOB_IS_CLK_ENABLED();
 8022bf0:	2002      	movs	r0, #2
 8022bf2:	f7ff ffcc 	bl	8022b8e <LL_C2_AHB2_GRP1_IsEnabledClock>
 8022bf6:	0002      	movs	r2, r0
 8022bf8:	4b15      	ldr	r3, [pc, #84]	; (8022c50 <activate_led+0x6c>)
 8022bfa:	601a      	str	r2, [r3, #0]
  if (!gpioB_isEnabled) {
 8022bfc:	4b14      	ldr	r3, [pc, #80]	; (8022c50 <activate_led+0x6c>)
 8022bfe:	681b      	ldr	r3, [r3, #0]
 8022c00:	2b00      	cmp	r3, #0
 8022c02:	d102      	bne.n	8022c0a <activate_led+0x26>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8022c04:	2002      	movs	r0, #2
 8022c06:	f7ff ffa5 	bl	8022b54 <LL_C2_AHB2_GRP1_EnableClock>
  }

  // Initialize the LED to turn on.
  GPIO_InitTypeDef led_gpio_params = {
 8022c0a:	240c      	movs	r4, #12
 8022c0c:	193b      	adds	r3, r7, r4
 8022c0e:	0018      	movs	r0, r3
 8022c10:	2314      	movs	r3, #20
 8022c12:	001a      	movs	r2, r3
 8022c14:	2100      	movs	r1, #0
 8022c16:	f000 f870 	bl	8022cfa <memset>
 8022c1a:	1dbb      	adds	r3, r7, #6
 8022c1c:	881a      	ldrh	r2, [r3, #0]
 8022c1e:	193b      	adds	r3, r7, r4
 8022c20:	601a      	str	r2, [r3, #0]
 8022c22:	193b      	adds	r3, r7, r4
 8022c24:	2201      	movs	r2, #1
 8022c26:	605a      	str	r2, [r3, #4]
 8022c28:	193b      	adds	r3, r7, r4
 8022c2a:	2202      	movs	r2, #2
 8022c2c:	60da      	str	r2, [r3, #12]
      .Pin = led,
      .Mode = GPIO_MODE_OUTPUT_PP,
      .Pull = GPIO_NOPULL,
      .Speed = GPIO_SPEED_FREQ_HIGH
  };
  HAL_GPIO_Init(GPIOB, &led_gpio_params);
 8022c2e:	193b      	adds	r3, r7, r4
 8022c30:	4a08      	ldr	r2, [pc, #32]	; (8022c54 <activate_led+0x70>)
 8022c32:	0019      	movs	r1, r3
 8022c34:	0010      	movs	r0, r2
 8022c36:	f7fd fe1f 	bl	8020878 <HAL_GPIO_Init>

  // Turn LED on.
  HAL_GPIO_WritePin(GPIOB, led, GPIO_PIN_SET);
 8022c3a:	1dbb      	adds	r3, r7, #6
 8022c3c:	881b      	ldrh	r3, [r3, #0]
 8022c3e:	4805      	ldr	r0, [pc, #20]	; (8022c54 <activate_led+0x70>)
 8022c40:	2201      	movs	r2, #1
 8022c42:	0019      	movs	r1, r3
 8022c44:	f7fe f840 	bl	8020cc8 <HAL_GPIO_WritePin>
}
 8022c48:	46c0      	nop			; (mov r8, r8)
 8022c4a:	46bd      	mov	sp, r7
 8022c4c:	b009      	add	sp, #36	; 0x24
 8022c4e:	bd90      	pop	{r4, r7, pc}
 8022c50:	200083fc 	.word	0x200083fc
 8022c54:	48000400 	.word	0x48000400

08022c58 <deactivate_led>:

/* Deactivare LED
 *
 * Turns off an LED on the Nucleo board.
 */
void deactivate_led(LED_COLOR led) {
 8022c58:	b580      	push	{r7, lr}
 8022c5a:	b082      	sub	sp, #8
 8022c5c:	af00      	add	r7, sp, #0
 8022c5e:	0002      	movs	r2, r0
 8022c60:	1dbb      	adds	r3, r7, #6
 8022c62:	801a      	strh	r2, [r3, #0]
  // Turn LED off.
  HAL_GPIO_WritePin(GPIOB, led, GPIO_PIN_RESET);
 8022c64:	1dbb      	adds	r3, r7, #6
 8022c66:	881b      	ldrh	r3, [r3, #0]
 8022c68:	480b      	ldr	r0, [pc, #44]	; (8022c98 <deactivate_led+0x40>)
 8022c6a:	2200      	movs	r2, #0
 8022c6c:	0019      	movs	r1, r3
 8022c6e:	f7fe f82b 	bl	8020cc8 <HAL_GPIO_WritePin>

  // Deinitialize the LED.
  HAL_GPIO_DeInit(GPIOB, led);
 8022c72:	1dbb      	adds	r3, r7, #6
 8022c74:	881b      	ldrh	r3, [r3, #0]
 8022c76:	4a08      	ldr	r2, [pc, #32]	; (8022c98 <deactivate_led+0x40>)
 8022c78:	0019      	movs	r1, r3
 8022c7a:	0010      	movs	r0, r2
 8022c7c:	f7fd ff5a 	bl	8020b34 <HAL_GPIO_DeInit>

  // Disable the GPIO clock the LED is attached to.
  if (!gpioB_isEnabled) {
 8022c80:	4b06      	ldr	r3, [pc, #24]	; (8022c9c <deactivate_led+0x44>)
 8022c82:	681b      	ldr	r3, [r3, #0]
 8022c84:	2b00      	cmp	r3, #0
 8022c86:	d102      	bne.n	8022c8e <deactivate_led+0x36>
    __HAL_RCC_GPIOB_CLK_DISABLE();
 8022c88:	2002      	movs	r0, #2
 8022c8a:	f7ff ff95 	bl	8022bb8 <LL_C2_AHB2_GRP1_DisableClock>
  }
}
 8022c8e:	46c0      	nop			; (mov r8, r8)
 8022c90:	46bd      	mov	sp, r7
 8022c92:	b002      	add	sp, #8
 8022c94:	bd80      	pop	{r7, pc}
 8022c96:	46c0      	nop			; (mov r8, r8)
 8022c98:	48000400 	.word	0x48000400
 8022c9c:	200083fc 	.word	0x200083fc

08022ca0 <__libc_init_array>:
 8022ca0:	b570      	push	{r4, r5, r6, lr}
 8022ca2:	2600      	movs	r6, #0
 8022ca4:	4d0c      	ldr	r5, [pc, #48]	; (8022cd8 <__libc_init_array+0x38>)
 8022ca6:	4c0d      	ldr	r4, [pc, #52]	; (8022cdc <__libc_init_array+0x3c>)
 8022ca8:	1b64      	subs	r4, r4, r5
 8022caa:	10a4      	asrs	r4, r4, #2
 8022cac:	42a6      	cmp	r6, r4
 8022cae:	d109      	bne.n	8022cc4 <__libc_init_array+0x24>
 8022cb0:	2600      	movs	r6, #0
 8022cb2:	f000 f82b 	bl	8022d0c <_init>
 8022cb6:	4d0a      	ldr	r5, [pc, #40]	; (8022ce0 <__libc_init_array+0x40>)
 8022cb8:	4c0a      	ldr	r4, [pc, #40]	; (8022ce4 <__libc_init_array+0x44>)
 8022cba:	1b64      	subs	r4, r4, r5
 8022cbc:	10a4      	asrs	r4, r4, #2
 8022cbe:	42a6      	cmp	r6, r4
 8022cc0:	d105      	bne.n	8022cce <__libc_init_array+0x2e>
 8022cc2:	bd70      	pop	{r4, r5, r6, pc}
 8022cc4:	00b3      	lsls	r3, r6, #2
 8022cc6:	58eb      	ldr	r3, [r5, r3]
 8022cc8:	4798      	blx	r3
 8022cca:	3601      	adds	r6, #1
 8022ccc:	e7ee      	b.n	8022cac <__libc_init_array+0xc>
 8022cce:	00b3      	lsls	r3, r6, #2
 8022cd0:	58eb      	ldr	r3, [r5, r3]
 8022cd2:	4798      	blx	r3
 8022cd4:	3601      	adds	r6, #1
 8022cd6:	e7f2      	b.n	8022cbe <__libc_init_array+0x1e>
 8022cd8:	08022de8 	.word	0x08022de8
 8022cdc:	08022de8 	.word	0x08022de8
 8022ce0:	08022de8 	.word	0x08022de8
 8022ce4:	08022dec 	.word	0x08022dec

08022ce8 <memcpy>:
 8022ce8:	2300      	movs	r3, #0
 8022cea:	b510      	push	{r4, lr}
 8022cec:	429a      	cmp	r2, r3
 8022cee:	d100      	bne.n	8022cf2 <memcpy+0xa>
 8022cf0:	bd10      	pop	{r4, pc}
 8022cf2:	5ccc      	ldrb	r4, [r1, r3]
 8022cf4:	54c4      	strb	r4, [r0, r3]
 8022cf6:	3301      	adds	r3, #1
 8022cf8:	e7f8      	b.n	8022cec <memcpy+0x4>

08022cfa <memset>:
 8022cfa:	0003      	movs	r3, r0
 8022cfc:	1882      	adds	r2, r0, r2
 8022cfe:	4293      	cmp	r3, r2
 8022d00:	d100      	bne.n	8022d04 <memset+0xa>
 8022d02:	4770      	bx	lr
 8022d04:	7019      	strb	r1, [r3, #0]
 8022d06:	3301      	adds	r3, #1
 8022d08:	e7f9      	b.n	8022cfe <memset+0x4>
	...

08022d0c <_init>:
 8022d0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8022d0e:	46c0      	nop			; (mov r8, r8)
 8022d10:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8022d12:	bc08      	pop	{r3}
 8022d14:	469e      	mov	lr, r3
 8022d16:	4770      	bx	lr

08022d18 <_fini>:
 8022d18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8022d1a:	46c0      	nop			; (mov r8, r8)
 8022d1c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8022d1e:	bc08      	pop	{r3}
 8022d20:	469e      	mov	lr, r3
 8022d22:	4770      	bx	lr
